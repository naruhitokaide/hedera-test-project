{"ast":null,"code":"import * as cryptography from \"@hashgraph/cryptography\";\nimport CACHE from \"./Cache.js\";\n/**\n * @typedef {import(\"./PrivateKey.js\").default} PrivateKey\n */\n\n/**\n * Multi-word mnemonic phrase (BIP-39).\n *\n * Compatible with the official Hedera mobile\n * wallets (24-words or 22-words) and BRD (12-words).\n */\n\nexport default class Mnemonic {\n  /**\n   * @param {cryptography.Mnemonic} mnemonic\n   * @hideconstructor\n   * @private\n   */\n  constructor(mnemonic) {\n    this._mnemonic = mnemonic;\n  }\n  /**\n   * Returns a new random 24-word mnemonic from the BIP-39\n   * standard English word list.\n   *\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async generate() {\n    return new Mnemonic(await cryptography.Mnemonic._generate(24));\n  }\n  /**\n   * Returns a new random 12-word mnemonic from the BIP-39\n   * standard English word list.\n   *\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async generate12() {\n    return new Mnemonic(await cryptography.Mnemonic._generate(12));\n  }\n  /**\n   * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.\n   *\n   * An exception of BadMnemonicError will be thrown if the mnemonic\n   * contains unknown words or fails the checksum. An invalid mnemonic\n   * can still be used to create private keys, the exception will\n   * contain the failing mnemonic in case you wish to ignore the\n   * validation error and continue.\n   *\n   * @param {string[]} words\n   * @throws {BadMnemonicError}\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async fromWords(words) {\n    return new Mnemonic(await cryptography.Mnemonic.fromWords(words));\n  }\n  /**\n   * Recover a private key from this mnemonic phrase, with an\n   * optional passphrase.\n   *\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toPrivateKey() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n    if (CACHE.privateKeyConstructor == null) {\n      throw new Error(\"`PrivateKey` has not been loaded\");\n    }\n\n    return CACHE.privateKeyConstructor(await this._mnemonic.toPrivateKey(passphrase));\n  }\n  /**\n   * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.\n   *\n   * @param {string} mnemonic\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async fromString(mnemonic) {\n    return new Mnemonic(await cryptography.Mnemonic.fromString(mnemonic));\n  }\n  /**\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toLegacyPrivateKey() {\n    if (CACHE.privateKeyConstructor == null) {\n      throw new Error(\"`PrivateKey` has not been loaded\");\n    }\n\n    return CACHE.privateKeyConstructor(await this._mnemonic.toLegacyPrivateKey());\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    return this._mnemonic.toString();\n  }\n\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/Mnemonic.js"],"names":["cryptography","CACHE","Mnemonic","constructor","mnemonic","_mnemonic","generate","_generate","generate12","fromWords","words","toPrivateKey","passphrase","privateKeyConstructor","Error","fromString","toLegacyPrivateKey","toString"],"mappings":"AAAA,OAAO,KAAKA,YAAZ,MAA8B,yBAA9B;AACA,OAAOC,KAAP,MAAkB,YAAlB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,QAAN,CAAe;AAC1B;AACJ;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,QAAD,EAAW;AAClB,SAAKC,SAAL,GAAiBD,QAAjB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACyB,eAARE,QAAQ,GAAG;AACpB,WAAO,IAAIJ,QAAJ,CAAa,MAAMF,YAAY,CAACE,QAAb,CAAsBK,SAAtB,CAAgC,EAAhC,CAAnB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AAC2B,eAAVC,UAAU,GAAG;AACtB,WAAO,IAAIN,QAAJ,CAAa,MAAMF,YAAY,CAACE,QAAb,CAAsBK,SAAtB,CAAgC,EAAhC,CAAnB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC0B,eAATE,SAAS,CAACC,KAAD,EAAQ;AAC1B,WAAO,IAAIR,QAAJ,CAAa,MAAMF,YAAY,CAACE,QAAb,CAAsBO,SAAtB,CAAgCC,KAAhC,CAAnB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACsB,QAAZC,YAAY,GAAkB;AAAA,QAAjBC,UAAiB,uEAAJ,EAAI;;AAChC,QAAIX,KAAK,CAACY,qBAAN,IAA+B,IAAnC,EAAyC;AACrC,YAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;AACH;;AAED,WAAOb,KAAK,CAACY,qBAAN,CACH,MAAM,KAAKR,SAAL,CAAeM,YAAf,CAA4BC,UAA5B,CADH,CAAP;AAGH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AAC2B,eAAVG,UAAU,CAACX,QAAD,EAAW;AAC9B,WAAO,IAAIF,QAAJ,CAAa,MAAMF,YAAY,CAACE,QAAb,CAAsBa,UAAtB,CAAiCX,QAAjC,CAAnB,CAAP;AACH;AAED;AACJ;AACA;;;AAC4B,QAAlBY,kBAAkB,GAAG;AACvB,QAAIf,KAAK,CAACY,qBAAN,IAA+B,IAAnC,EAAyC;AACrC,YAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;AACH;;AAED,WAAOb,KAAK,CAACY,qBAAN,CACH,MAAM,KAAKR,SAAL,CAAeW,kBAAf,EADH,CAAP;AAGH;AAED;AACJ;AACA;;;AACIC,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAKZ,SAAL,CAAeY,QAAf,EAAP;AACH;;AA5FyB","sourcesContent":["import * as cryptography from \"@hashgraph/cryptography\";\nimport CACHE from \"./Cache.js\";\n\n/**\n * @typedef {import(\"./PrivateKey.js\").default} PrivateKey\n */\n\n/**\n * Multi-word mnemonic phrase (BIP-39).\n *\n * Compatible with the official Hedera mobile\n * wallets (24-words or 22-words) and BRD (12-words).\n */\nexport default class Mnemonic {\n    /**\n     * @param {cryptography.Mnemonic} mnemonic\n     * @hideconstructor\n     * @private\n     */\n    constructor(mnemonic) {\n        this._mnemonic = mnemonic;\n    }\n\n    /**\n     * Returns a new random 24-word mnemonic from the BIP-39\n     * standard English word list.\n     *\n     * @returns {Promise<Mnemonic>}\n     */\n    static async generate() {\n        return new Mnemonic(await cryptography.Mnemonic._generate(24));\n    }\n\n    /**\n     * Returns a new random 12-word mnemonic from the BIP-39\n     * standard English word list.\n     *\n     * @returns {Promise<Mnemonic>}\n     */\n    static async generate12() {\n        return new Mnemonic(await cryptography.Mnemonic._generate(12));\n    }\n\n    /**\n     * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.\n     *\n     * An exception of BadMnemonicError will be thrown if the mnemonic\n     * contains unknown words or fails the checksum. An invalid mnemonic\n     * can still be used to create private keys, the exception will\n     * contain the failing mnemonic in case you wish to ignore the\n     * validation error and continue.\n     *\n     * @param {string[]} words\n     * @throws {BadMnemonicError}\n     * @returns {Promise<Mnemonic>}\n     */\n    static async fromWords(words) {\n        return new Mnemonic(await cryptography.Mnemonic.fromWords(words));\n    }\n\n    /**\n     * Recover a private key from this mnemonic phrase, with an\n     * optional passphrase.\n     *\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    async toPrivateKey(passphrase = \"\") {\n        if (CACHE.privateKeyConstructor == null) {\n            throw new Error(\"`PrivateKey` has not been loaded\");\n        }\n\n        return CACHE.privateKeyConstructor(\n            await this._mnemonic.toPrivateKey(passphrase)\n        );\n    }\n\n    /**\n     * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.\n     *\n     * @param {string} mnemonic\n     * @returns {Promise<Mnemonic>}\n     */\n    static async fromString(mnemonic) {\n        return new Mnemonic(await cryptography.Mnemonic.fromString(mnemonic));\n    }\n\n    /**\n     * @returns {Promise<PrivateKey>}\n     */\n    async toLegacyPrivateKey() {\n        if (CACHE.privateKeyConstructor == null) {\n            throw new Error(\"`PrivateKey` has not been loaded\");\n        }\n\n        return CACHE.privateKeyConstructor(\n            await this._mnemonic.toLegacyPrivateKey()\n        );\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this._mnemonic.toString();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}