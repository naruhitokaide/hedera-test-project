{"ast":null,"code":"import BadKeyError from \"./BadKeyError.js\";\nimport Ed25519PublicKey from \"./Ed25519PublicKey.js\";\nimport nacl from \"tweetnacl\";\nimport { arrayStartsWith } from \"./util/array.js\";\nimport * as hex from \"./encoding/hex.js\";\nimport * as random from \"./primitive/random.js\";\nexport const derPrefix = \"302e020100300506032b657004220420\";\nexport const derPrefixBytes = hex.decode(derPrefix);\nexport default class Ed25519PrivateKey {\n  /**\n   * @hideconstructor\n   * @internal\n   * @param {nacl.SignKeyPair | Uint8Array} keyPair\n   * @param {Uint8Array=} chainCode\n   */\n  constructor(keyPair, chainCode) {\n    /**\n     * @type {nacl.SignKeyPair}\n     * @readonly\n     * @private\n     */\n    this._keyPair = keyPair instanceof Uint8Array ? nacl.sign.keyPair.fromSeed(keyPair) : keyPair;\n    /**\n     * @type {?Uint8Array}\n     * @readonly\n     */\n\n    this._chainCode = chainCode != null ? chainCode : null;\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  get _type() {\n    return \"ED25519\";\n  }\n  /**\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {Ed25519PrivateKey}\n   */\n\n\n  static generate() {\n    // 32 bytes for the secret key\n    // 32 bytes for the chain code (to support derivation)\n    const entropy = random.bytes(64);\n    return new Ed25519PrivateKey(nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)), entropy.subarray(32));\n  }\n  /**\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {Promise<Ed25519PrivateKey>}\n   */\n\n\n  static async generateAsync() {\n    // 32 bytes for the secret key\n    // 32 bytes for the chain code (to support derivation)\n    const entropy = await random.bytesAsync(64);\n    return new Ed25519PrivateKey(nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)), entropy.subarray(32));\n  }\n  /**\n   * Construct a private key from bytes.\n   *\n   * @param {Uint8Array} data\n   * @returns {Ed25519PrivateKey}\n   */\n\n\n  static fromBytes(data) {\n    switch (data.length) {\n      case 48:\n        return Ed25519PrivateKey.fromBytesDer(data);\n\n      case 32:\n      case 64:\n        return Ed25519PrivateKey.fromBytesRaw(data);\n\n      default:\n        throw new BadKeyError(`invalid private key length: ${data.length} bytes`);\n    }\n  }\n  /**\n   * Construct a private key from bytes with DER header.\n   *\n   * @param {Uint8Array} data\n   * @returns {Ed25519PrivateKey}\n   */\n\n\n  static fromBytesDer(data) {\n    if (data.length != 48 || !arrayStartsWith(data, derPrefixBytes)) {\n      throw new BadKeyError(`invalid private key length: ${data.length} bytes`);\n    }\n\n    const keyPair = nacl.sign.keyPair.fromSeed(data.subarray(16));\n    return new Ed25519PrivateKey(keyPair);\n  }\n  /**\n   * Construct a private key from bytes without DER header.\n   *\n   * @param {Uint8Array} data\n   * @returns {Ed25519PrivateKey}\n   */\n\n\n  static fromBytesRaw(data) {\n    switch (data.length) {\n      case 32:\n        return new Ed25519PrivateKey(nacl.sign.keyPair.fromSeed(data));\n\n      case 64:\n        // priv + pub key\n        return new Ed25519PrivateKey(nacl.sign.keyPair.fromSecretKey(data));\n\n      default:\n    }\n\n    throw new BadKeyError(`invalid private key length: ${data.length} bytes`);\n  }\n  /**\n   * Construct a private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {Ed25519PrivateKey}\n   */\n\n\n  static fromString(text) {\n    return Ed25519PrivateKey.fromBytes(hex.decode(text));\n  }\n  /**\n   * Construct a private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {Ed25519PrivateKey}\n   */\n\n\n  static fromStringDer(text) {\n    return Ed25519PrivateKey.fromBytesDer(hex.decode(text));\n  }\n  /**\n   * Construct a private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {Ed25519PrivateKey}\n   */\n\n\n  static fromStringRaw(text) {\n    return Ed25519PrivateKey.fromBytesRaw(hex.decode(text));\n  }\n  /**\n   * Get the public key associated with this private key.\n   *\n   * The public key can be freely given and used by other parties to verify\n   * the signatures generated by this private key.\n   *\n   * @returns {Ed25519PublicKey}\n   */\n\n\n  get publicKey() {\n    return new Ed25519PublicKey(this._keyPair.publicKey);\n  }\n  /**\n   * Sign a message with this private key.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {Uint8Array} - The signature bytes without the message\n   */\n\n\n  sign(bytes) {\n    return nacl.sign.detached(bytes, this._keyPair.secretKey);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesDer() {\n    const bytes = new Uint8Array(derPrefixBytes.length + 32);\n    bytes.set(derPrefixBytes, 0);\n    bytes.set(this._keyPair.secretKey.subarray(0, 32), derPrefixBytes.length);\n    return bytes;\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesRaw() {\n    // copy the bytes so they can't be modified accidentally\n    return this._keyPair.secretKey.slice(0, 32);\n  }\n\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/Ed25519PrivateKey.js"],"names":["BadKeyError","Ed25519PublicKey","nacl","arrayStartsWith","hex","random","derPrefix","derPrefixBytes","decode","Ed25519PrivateKey","constructor","keyPair","chainCode","_keyPair","Uint8Array","sign","fromSeed","_chainCode","_type","generate","entropy","bytes","subarray","generateAsync","bytesAsync","fromBytes","data","length","fromBytesDer","fromBytesRaw","fromSecretKey","fromString","text","fromStringDer","fromStringRaw","publicKey","detached","secretKey","toBytesDer","set","toBytesRaw","slice"],"mappings":"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","sourcesContent":["import BadKeyError from \"./BadKeyError.js\";\nimport Ed25519PublicKey from \"./Ed25519PublicKey.js\";\nimport nacl from \"tweetnacl\";\nimport { arrayStartsWith } from \"./util/array.js\";\nimport * as hex from \"./encoding/hex.js\";\nimport * as random from \"./primitive/random.js\";\n\nexport const derPrefix = \"302e020100300506032b657004220420\";\nexport const derPrefixBytes = hex.decode(derPrefix);\n\nexport default class Ed25519PrivateKey {\n    /**\n     * @hideconstructor\n     * @internal\n     * @param {nacl.SignKeyPair | Uint8Array} keyPair\n     * @param {Uint8Array=} chainCode\n     */\n    constructor(keyPair, chainCode) {\n        /**\n         * @type {nacl.SignKeyPair}\n         * @readonly\n         * @private\n         */\n        this._keyPair =\n            keyPair instanceof Uint8Array\n                ? nacl.sign.keyPair.fromSeed(keyPair)\n                : keyPair;\n\n        /**\n         * @type {?Uint8Array}\n         * @readonly\n         */\n        this._chainCode = chainCode != null ? chainCode : null;\n    }\n\n    /**\n     * @returns {string}\n     */\n    get _type() {\n        return \"ED25519\";\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Ed25519PrivateKey}\n     */\n    static generate() {\n        // 32 bytes for the secret key\n        // 32 bytes for the chain code (to support derivation)\n        const entropy = random.bytes(64);\n\n        return new Ed25519PrivateKey(\n            nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)),\n            entropy.subarray(32)\n        );\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<Ed25519PrivateKey>}\n     */\n    static async generateAsync() {\n        // 32 bytes for the secret key\n        // 32 bytes for the chain code (to support derivation)\n        const entropy = await random.bytesAsync(64);\n\n        return new Ed25519PrivateKey(\n            nacl.sign.keyPair.fromSeed(entropy.subarray(0, 32)),\n            entropy.subarray(32)\n        );\n    }\n\n    /**\n     * Construct a private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {Ed25519PrivateKey}\n     */\n    static fromBytes(data) {\n        switch (data.length) {\n            case 48:\n                return Ed25519PrivateKey.fromBytesDer(data);\n            case 32:\n            case 64:\n                return Ed25519PrivateKey.fromBytesRaw(data);\n            default:\n                throw new BadKeyError(\n                    `invalid private key length: ${data.length} bytes`\n                );\n        }\n    }\n\n    /**\n     * Construct a private key from bytes with DER header.\n     *\n     * @param {Uint8Array} data\n     * @returns {Ed25519PrivateKey}\n     */\n    static fromBytesDer(data) {\n        if (data.length != 48 || !arrayStartsWith(data, derPrefixBytes)) {\n            throw new BadKeyError(\n                `invalid private key length: ${data.length} bytes`\n            );\n        }\n\n        const keyPair = nacl.sign.keyPair.fromSeed(data.subarray(16));\n\n        return new Ed25519PrivateKey(keyPair);\n    }\n\n    /**\n     * Construct a private key from bytes without DER header.\n     *\n     * @param {Uint8Array} data\n     * @returns {Ed25519PrivateKey}\n     */\n    static fromBytesRaw(data) {\n        switch (data.length) {\n            case 32:\n                return new Ed25519PrivateKey(nacl.sign.keyPair.fromSeed(data));\n\n            case 64:\n                // priv + pub key\n                return new Ed25519PrivateKey(\n                    nacl.sign.keyPair.fromSecretKey(data)\n                );\n\n            default:\n        }\n\n        throw new BadKeyError(\n            `invalid private key length: ${data.length} bytes`\n        );\n    }\n\n    /**\n     * Construct a private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {Ed25519PrivateKey}\n     */\n    static fromString(text) {\n        return Ed25519PrivateKey.fromBytes(hex.decode(text));\n    }\n\n    /**\n     * Construct a private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {Ed25519PrivateKey}\n     */\n    static fromStringDer(text) {\n        return Ed25519PrivateKey.fromBytesDer(hex.decode(text));\n    }\n\n    /**\n     * Construct a private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {Ed25519PrivateKey}\n     */\n    static fromStringRaw(text) {\n        return Ed25519PrivateKey.fromBytesRaw(hex.decode(text));\n    }\n\n    /**\n     * Get the public key associated with this private key.\n     *\n     * The public key can be freely given and used by other parties to verify\n     * the signatures generated by this private key.\n     *\n     * @returns {Ed25519PublicKey}\n     */\n    get publicKey() {\n        return new Ed25519PublicKey(this._keyPair.publicKey);\n    }\n\n    /**\n     * Sign a message with this private key.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {Uint8Array} - The signature bytes without the message\n     */\n    sign(bytes) {\n        return nacl.sign.detached(bytes, this._keyPair.secretKey);\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        const bytes = new Uint8Array(derPrefixBytes.length + 32);\n\n        bytes.set(derPrefixBytes, 0);\n        bytes.set(\n            this._keyPair.secretKey.subarray(0, 32),\n            derPrefixBytes.length\n        );\n\n        return bytes;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        // copy the bytes so they can't be modified accidentally\n        return this._keyPair.secretKey.slice(0, 32);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}