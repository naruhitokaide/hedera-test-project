{"ast":null,"code":"import BigNumber from \"bignumber.js\";\nimport * as sha256 from \"../primitive/sha256.js\";\n/**\n * @param {string[]} words\n * @param {string[]} wordlist\n * @returns {[Uint8Array, number]}\n */\n\nexport function legacy1(words, wordlist) {\n  const indicies = words.map(word => wordlist.indexOf(word.toLowerCase()));\n  const data = convertRadix(indicies, wordlist.length, 256, 33);\n  const checksum = data[data.length - 1];\n  const result = new Uint8Array(data.length - 1);\n\n  for (let i = 0; i < data.length - 1; i += 1) {\n    result[i] = data[i] ^ checksum;\n  }\n\n  return [result, checksum];\n}\n/**\n * @param {string[]} words\n * @param {string[]} wordlist\n * @returns {Promise<Uint8Array>}\n */\n\nexport async function legacy2(words, wordlist) {\n  const concatBitsLen = words.length * 11;\n  /** @type {boolean[]} */\n\n  const concatBits = [];\n  concatBits.fill(false, 0, concatBitsLen);\n\n  for (const [wordIndex, word] of words.entries()) {\n    const index = wordlist.indexOf(word.toLowerCase());\n\n    if (index < 0) {\n      throw new Error(`Word not found in wordlist: ${word}`);\n    }\n\n    for (let i = 0; i < 11; i += 1) {\n      concatBits[wordIndex * 11 + i] = (index & 1 << 10 - i) !== 0;\n    }\n  }\n\n  const checksumBitsLen = concatBitsLen / 33;\n  const entropyBitsLen = concatBitsLen - checksumBitsLen;\n  const entropy = new Uint8Array(entropyBitsLen / 8);\n\n  for (let i = 0; i < entropy.length; i += 1) {\n    for (let j = 0; j < 8; j += 1) {\n      if (concatBits[i * 8 + j]) {\n        entropy[i] |= 1 << 7 - j;\n      }\n    }\n  } // Checksum validation\n\n\n  const hash = await sha256.digest(entropy);\n  const hashBits = bytesToBits(hash);\n\n  for (let i = 0; i < checksumBitsLen; i += 1) {\n    if (concatBits[entropyBitsLen + i] !== hashBits[i]) {\n      throw new Error(\"Checksum mismatch\");\n    }\n  }\n\n  return entropy;\n}\n/**\n * @param {Uint8Array} data\n * @returns {number}\n */\n\nexport function crc8(data) {\n  let crc = 0xff;\n\n  for (let i = 0; i < data.length - 1; i += 1) {\n    crc ^= data[i];\n\n    for (let j = 0; j < 8; j += 1) {\n      crc = crc >>> 1 ^ ((crc & 1) === 0 ? 0 : 0xb2);\n    }\n  }\n\n  return crc ^ 0xff;\n}\n/**\n * @param {number[]} nums\n * @param {number} fromRadix\n * @param {number} toRadix\n * @param {number} toLength\n * @returns {Uint8Array}\n */\n\nexport function convertRadix(nums, fromRadix, toRadix, toLength) {\n  let num = new BigNumber(0);\n\n  for (const element of nums) {\n    num = num.times(fromRadix);\n    num = num.plus(element);\n  }\n\n  const result = new Uint8Array(toLength);\n\n  for (let i = toLength - 1; i >= 0; i -= 1) {\n    const tem = num.dividedToIntegerBy(toRadix);\n    const rem = num.modulo(toRadix);\n    num = tem;\n    result[i] = rem.toNumber();\n  }\n\n  return result;\n}\n/**\n * @param {Uint8Array} data\n * @returns {boolean[]}\n */\n\nexport function bytesToBits(data) {\n  /** @type {boolean[]} */\n  const bits = [];\n  bits.fill(false, 0, data.length * 8);\n\n  for (let i = 0; i < data.length; i += 1) {\n    for (let j = 0; j < 8; j += 1) {\n      bits[i * 8 + j] = (data[i] & 1 << 7 - j) !== 0;\n    }\n  }\n\n  return bits;\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/util/entropy.js"],"names":["BigNumber","sha256","legacy1","words","wordlist","indicies","map","word","indexOf","toLowerCase","data","convertRadix","length","checksum","result","Uint8Array","i","legacy2","concatBitsLen","concatBits","fill","wordIndex","entries","index","Error","checksumBitsLen","entropyBitsLen","entropy","j","hash","digest","hashBits","bytesToBits","crc8","crc","nums","fromRadix","toRadix","toLength","num","element","times","plus","tem","dividedToIntegerBy","rem","modulo","toNumber","bits"],"mappings":"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","sourcesContent":["import BigNumber from \"bignumber.js\";\nimport * as sha256 from \"../primitive/sha256.js\";\n\n/**\n * @param {string[]} words\n * @param {string[]} wordlist\n * @returns {[Uint8Array, number]}\n */\nexport function legacy1(words, wordlist) {\n    const indicies = words.map((word) => wordlist.indexOf(word.toLowerCase()));\n\n    const data = convertRadix(indicies, wordlist.length, 256, 33);\n    const checksum = data[data.length - 1];\n    const result = new Uint8Array(data.length - 1);\n\n    for (let i = 0; i < data.length - 1; i += 1) {\n        result[i] = data[i] ^ checksum;\n    }\n\n    return [result, checksum];\n}\n\n/**\n * @param {string[]} words\n * @param {string[]} wordlist\n * @returns {Promise<Uint8Array>}\n */\nexport async function legacy2(words, wordlist) {\n    const concatBitsLen = words.length * 11;\n    /** @type {boolean[]} */\n    const concatBits = [];\n    concatBits.fill(false, 0, concatBitsLen);\n\n    for (const [wordIndex, word] of words.entries()) {\n        const index = wordlist.indexOf(word.toLowerCase());\n\n        if (index < 0) {\n            throw new Error(`Word not found in wordlist: ${word}`);\n        }\n\n        for (let i = 0; i < 11; i += 1) {\n            concatBits[wordIndex * 11 + i] = (index & (1 << (10 - i))) !== 0;\n        }\n    }\n\n    const checksumBitsLen = concatBitsLen / 33;\n    const entropyBitsLen = concatBitsLen - checksumBitsLen;\n    const entropy = new Uint8Array(entropyBitsLen / 8);\n\n    for (let i = 0; i < entropy.length; i += 1) {\n        for (let j = 0; j < 8; j += 1) {\n            if (concatBits[i * 8 + j]) {\n                entropy[i] |= 1 << (7 - j);\n            }\n        }\n    }\n\n    // Checksum validation\n    const hash = await sha256.digest(entropy);\n    const hashBits = bytesToBits(hash);\n\n    for (let i = 0; i < checksumBitsLen; i += 1) {\n        if (concatBits[entropyBitsLen + i] !== hashBits[i]) {\n            throw new Error(\"Checksum mismatch\");\n        }\n    }\n\n    return entropy;\n}\n\n/**\n * @param {Uint8Array} data\n * @returns {number}\n */\nexport function crc8(data) {\n    let crc = 0xff;\n\n    for (let i = 0; i < data.length - 1; i += 1) {\n        crc ^= data[i];\n        for (let j = 0; j < 8; j += 1) {\n            crc = (crc >>> 1) ^ ((crc & 1) === 0 ? 0 : 0xb2);\n        }\n    }\n\n    return crc ^ 0xff;\n}\n\n/**\n * @param {number[]} nums\n * @param {number} fromRadix\n * @param {number} toRadix\n * @param {number} toLength\n * @returns {Uint8Array}\n */\nexport function convertRadix(nums, fromRadix, toRadix, toLength) {\n    let num = new BigNumber(0);\n\n    for (const element of nums) {\n        num = num.times(fromRadix);\n        num = num.plus(element);\n    }\n\n    const result = new Uint8Array(toLength);\n\n    for (let i = toLength - 1; i >= 0; i -= 1) {\n        const tem = num.dividedToIntegerBy(toRadix);\n        const rem = num.modulo(toRadix);\n        num = tem;\n        result[i] = rem.toNumber();\n    }\n\n    return result;\n}\n\n/**\n * @param {Uint8Array} data\n * @returns {boolean[]}\n */\nexport function bytesToBits(data) {\n    /** @type {boolean[]} */\n    const bits = [];\n    bits.fill(false, 0, data.length * 8);\n\n    for (let i = 0; i < data.length; i += 1) {\n        for (let j = 0; j < 8; j += 1) {\n            bits[i * 8 + j] = (data[i] & (1 << (7 - j))) !== 0;\n        }\n    }\n\n    return bits;\n}\n"]},"metadata":{},"sourceType":"module"}