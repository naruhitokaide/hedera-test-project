{"ast":null,"code":"/**\n * @type {string[]}\n */\nconst byteToHex = [];\n\nfor (let n = 0; n <= 0xff; n += 1) {\n  byteToHex.push(n.toString(16).padStart(2, \"0\"));\n}\n/**\n * @param {Uint8Array} data\n * @returns {string}\n */\n\n\nexport function encode(data) {\n  let string = \"\";\n\n  for (const byte of data) {\n    string += byteToHex[byte];\n  }\n\n  return string;\n}\n/**\n * @param {string} text\n * @returns {Uint8Array}\n */\n\nexport function decode(text) {\n  const str = text.startsWith(\"0x\") ? text.substring(2) : text;\n  const result = str.match(/.{1,2}/gu);\n  return new Uint8Array((result == null ? [] : result).map(byte => parseInt(byte, 16)));\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/encoding/hex.browser.js"],"names":["byteToHex","n","push","toString","padStart","encode","data","string","byte","decode","text","str","startsWith","substring","result","match","Uint8Array","map","parseInt"],"mappings":"AAAA;AACA;AACA;AACA,MAAMA,SAAS,GAAG,EAAlB;;AAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,IAArB,EAA2BA,CAAC,IAAI,CAAhC,EAAmC;AAC/BD,EAAAA,SAAS,CAACE,IAAV,CAAeD,CAAC,CAACE,QAAF,CAAW,EAAX,EAAeC,QAAf,CAAwB,CAAxB,EAA2B,GAA3B,CAAf;AACH;AAED;AACA;AACA;AACA;;;AACA,OAAO,SAASC,MAAT,CAAgBC,IAAhB,EAAsB;AACzB,MAAIC,MAAM,GAAG,EAAb;;AAEA,OAAK,MAAMC,IAAX,IAAmBF,IAAnB,EAAyB;AACrBC,IAAAA,MAAM,IAAIP,SAAS,CAACQ,IAAD,CAAnB;AACH;;AAED,SAAOD,MAAP;AACH;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASE,MAAT,CAAgBC,IAAhB,EAAsB;AACzB,QAAMC,GAAG,GAAGD,IAAI,CAACE,UAAL,CAAgB,IAAhB,IAAwBF,IAAI,CAACG,SAAL,CAAe,CAAf,CAAxB,GAA4CH,IAAxD;AACA,QAAMI,MAAM,GAAGH,GAAG,CAACI,KAAJ,CAAU,UAAV,CAAf;AAEA,SAAO,IAAIC,UAAJ,CACH,CAACF,MAAM,IAAI,IAAV,GAAiB,EAAjB,GAAsBA,MAAvB,EAA+BG,GAA/B,CAAoCT,IAAD,IAAUU,QAAQ,CAACV,IAAD,EAAO,EAAP,CAArD,CADG,CAAP;AAGH","sourcesContent":["/**\n * @type {string[]}\n */\nconst byteToHex = [];\n\nfor (let n = 0; n <= 0xff; n += 1) {\n    byteToHex.push(n.toString(16).padStart(2, \"0\"));\n}\n\n/**\n * @param {Uint8Array} data\n * @returns {string}\n */\nexport function encode(data) {\n    let string = \"\";\n\n    for (const byte of data) {\n        string += byteToHex[byte];\n    }\n\n    return string;\n}\n\n/**\n * @param {string} text\n * @returns {Uint8Array}\n */\nexport function decode(text) {\n    const str = text.startsWith(\"0x\") ? text.substring(2) : text;\n    const result = str.match(/.{1,2}/gu);\n\n    return new Uint8Array(\n        (result == null ? [] : result).map((byte) => parseInt(byte, 16))\n    );\n}\n"]},"metadata":{},"sourceType":"module"}