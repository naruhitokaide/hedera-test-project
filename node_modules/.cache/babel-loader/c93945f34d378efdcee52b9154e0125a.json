{"ast":null,"code":"import Status from \"../Status.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport Hbar from \"../Hbar.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport { Query as ProtoQuery, TransactionBody as ProtoTransactionBody, SignedTransaction as ProtoSignedTransaction, ResponseType as ProtoResponseType, ResponseCodeEnum } from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport MaxQueryPaymentExceeded from \"../MaxQueryPaymentExceeded.js\";\nimport Long from \"long\";\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IQuery} proto.IQuery\n * @typedef {import(\"@hashgraph/proto\").IQueryHeader} proto.IQueryHeader\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").IResponse} proto.IResponse\n * @typedef {import(\"@hashgraph/proto\").IResponseHeader} proto.IResponseHeader\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ResponseCodeEnum} proto.ResponseCodeEnum\n */\n\n/**\n * @typedef {import(\"../client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\n/**\n * @type {Map<ProtoQuery[\"query\"], (query: proto.IQuery) => Query<*>>}\n */\n\nexport const QUERY_REGISTRY = new Map();\n/**\n * Base class for all queries that can be submitted to Hedera.\n *\n * @abstract\n * @template OutputT\n * @augments {Executable<proto.IQuery, proto.IResponse, OutputT>}\n */\n\nexport default class Query extends Executable {\n  constructor() {\n    super();\n    /** @type {?TransactionId} */\n\n    this._paymentTransactionId = null;\n    /** @type {proto.ITransaction[]} */\n\n    this._paymentTransactions = [];\n    /** @type {?Hbar} */\n\n    this._queryPayment = null;\n    /** @type {?Hbar} */\n\n    this._maxQueryPayment = null;\n  }\n  /**\n   * @template T\n   * @param {Uint8Array} bytes\n   * @returns {Query<T>}\n   */\n\n\n  static fromBytes(bytes) {\n    const query = ProtoQuery.decode(bytes);\n\n    if (query.query == null) {\n      throw new Error(\"(BUG) query.query was not set in the protobuf\");\n    }\n\n    const fromProtobuf =\n    /** @type {(query: proto.IQuery) => Query<T>} */\n    QUERY_REGISTRY.get(query.query);\n\n    if (fromProtobuf == null) {\n      throw new Error(`(BUG) Query.fromBytes() not implemented for type ${query.query}`);\n    }\n\n    return fromProtobuf(query);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return ProtoQuery.encode(this._makeRequest()).finish();\n  }\n  /**\n   * Set an explicit payment amount for this query.\n   *\n   * The client will submit exactly this amount for the payment of this query. Hedera\n   * will not return any remainder.\n   *\n   * @param {Hbar} queryPayment\n   * @returns {this}\n   */\n\n\n  setQueryPayment(queryPayment) {\n    this._queryPayment = queryPayment;\n    return this;\n  }\n  /**\n   * Set the maximum payment allowable for this query.\n   *\n   * @param {Hbar} maxQueryPayment\n   * @returns {this}\n   */\n\n\n  setMaxQueryPayment(maxQueryPayment) {\n    this._maxQueryPayment = maxQueryPayment;\n    return this;\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<Hbar>}\n   */\n\n\n  getCost(client) {\n    if (this._nodeIds.length == 0) {\n      this._nodeIds = client._network.getNodeAccountIdsForExecute();\n    }\n\n    if (COST_QUERY.length != 1) {\n      throw new Error(\"CostQuery has not been loaded yet\");\n    }\n\n    return COST_QUERY[0](this).execute(client);\n  }\n  /**\n   * @param {TransactionId} paymentTransactionId\n   * @returns {this}\n   */\n\n\n  setPaymentTransactionId(paymentTransactionId) {\n    this._paymentTransactionId = paymentTransactionId;\n    return this;\n  }\n  /**\n   * @returns {?TransactionId}\n   */\n\n\n  get paymentTransactionId() {\n    return this._paymentTransactionId;\n  }\n  /**\n   * @returns {TransactionId}\n   */\n\n\n  _getTransactionId() {\n    if (this._paymentTransactionId == null) {\n      throw new Error(\"Query.PaymentTransactionId was not set duration execution\");\n    }\n\n    return this._paymentTransactionId;\n  }\n  /**\n   * @protected\n   * @returns {boolean}\n   */\n\n\n  _isPaymentRequired() {\n    return true;\n  }\n  /**\n   * @param {Client} client\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n\n\n  _validateChecksums(client) {// Do nothing\n  }\n  /**\n   * @template MirrorChannelT\n   * @param {import(\"../client/Client.js\").default<Channel, MirrorChannelT>} client\n   * @returns {Promise<void>}\n   */\n\n\n  async _beforeExecute(client) {\n    if (this._paymentTransactions.length > 0) {\n      return;\n    }\n\n    if (client.isAutoValidateChecksumsEnabled()) {\n      this._validateChecksums(client);\n    }\n\n    if (this._nodeIds.length == 0) {\n      this._nodeIds = client._network.getNodeAccountIdsForExecute();\n    }\n\n    const operator = client._operator;\n\n    if (this._paymentTransactionId == null) {\n      if (this._isPaymentRequired()) {\n        if (operator != null) {\n          this._paymentTransactionId = TransactionId.generate(operator.accountId);\n        } else {\n          throw new Error(\"`client` must have an `operator` or an explicit payment transaction must be provided\");\n        }\n      } else {\n        this._paymentTransactionId = TransactionId.generate(new AccountId(0));\n      }\n    }\n\n    let cost = this._queryPayment != null ? this._queryPayment : client.maxQueryPayment;\n\n    if (this._paymentTransactions.length !== 0 || !this._isPaymentRequired()) {\n      cost = new Hbar(0);\n    } else {\n      if (this._queryPayment == null) {\n        const actualCost = await this.getCost(client);\n\n        if (cost.toTinybars().toInt() < actualCost.toTinybars().toInt()) {\n          throw new MaxQueryPaymentExceeded(cost, actualCost);\n        }\n\n        cost = actualCost;\n      }\n    }\n\n    for (const node of this._nodeIds) {\n      this._paymentTransactions.push(await _makePaymentTransaction(\n      /** @type {import(\"../transaction/TransactionId.js\").default} */\n      this._paymentTransactionId, node, this._isPaymentRequired() ? operator : null,\n      /** @type {Hbar} */\n      cost));\n    }\n  }\n  /**\n   * @abstract\n   * @internal\n   * @param {proto.IResponse} response\n   * @returns {proto.IResponseHeader}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapResponseHeader(response) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @protected\n   * @returns {proto.IQueryHeader}\n   */\n\n\n  _makeRequestHeader() {\n    /** @type {proto.IQueryHeader} */\n    let header = {};\n\n    if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {\n      header = {\n        responseType: ProtoResponseType.ANSWER_ONLY,\n        payment: this._paymentTransactions[this._nextNodeIndex]\n      };\n    }\n\n    return header;\n  }\n  /**\n   * @abstract\n   * @internal\n   * @param {proto.IQueryHeader} header\n   * @returns {proto.IQuery}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _onMakeRequest(header) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @internal\n   * @returns {proto.IQuery}\n   */\n\n\n  _makeRequest() {\n    /** @type {proto.IQueryHeader} */\n    let header = {};\n\n    if (this._isPaymentRequired() && this._paymentTransactions != null) {\n      header = {\n        payment: this._paymentTransactions[this._nextNodeIndex],\n        responseType: ProtoResponseType.ANSWER_ONLY\n      };\n    }\n\n    return this._onMakeRequest(header);\n  }\n  /**\n   * @override\n   * @internal\n   * @returns {Promise<proto.IQuery>}\n   */\n\n\n  _makeRequestAsync() {\n    return Promise.resolve(this._makeRequest());\n  }\n  /**\n   * @override\n   * @internal\n   * @param {proto.IQuery} request\n   * @param {proto.IResponse} response\n   * @returns {ExecutionState}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _shouldRetry(request, response) {\n    const {\n      nodeTransactionPrecheckCode\n    } = this._mapResponseHeader(response);\n\n    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : ResponseCodeEnum.OK);\n\n    switch (status) {\n      case Status.Busy:\n      case Status.Unknown:\n      case Status.PlatformTransactionNotCreated:\n        return ExecutionState.Retry;\n\n      case Status.Ok:\n        return ExecutionState.Finished;\n\n      default:\n        return ExecutionState.Error;\n    }\n  }\n  /**\n   * @override\n   * @internal\n   * @param {proto.IQuery} request\n   * @param {proto.IResponse} response\n   * @returns {Error}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapStatusError(request, response) {\n    const {\n      nodeTransactionPrecheckCode\n    } = this._mapResponseHeader(response);\n\n    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : ResponseCodeEnum.OK);\n\n    return new PrecheckStatusError({\n      status,\n      transactionId: this._getTransactionId()\n    });\n  }\n  /**\n   * @returns {AccountId}\n   */\n\n\n  _getNodeAccountId() {\n    if (this._nodeIds.length > 0) {\n      // if there are payment transactions,\n      // we need to use the node of the current payment transaction\n      return this._nodeIds[this._nextNodeIndex];\n    } else {\n      throw new Error(\"(BUG) nodeAccountIds were not set for query before executing\");\n    }\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {void}\n   */\n\n\n  _advanceRequest() {\n    if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {\n      // each time we move our cursor to the next transaction\n      // wrapping around to ensure we are cycling\n      super._nextNodeIndex = (this._nextNodeIndex + 1) % this._paymentTransactions.length;\n    } else {\n      super._advanceRequest();\n    }\n  }\n\n}\n/**\n * @param {TransactionId} paymentTransactionId\n * @param {AccountId} nodeId\n * @param {?ClientOperator} operator\n * @param {Hbar} paymentAmount\n * @returns {Promise<proto.ITransaction>}\n */\n\nexport async function _makePaymentTransaction(paymentTransactionId, nodeId, operator, paymentAmount) {\n  const accountAmounts = [];\n\n  if (operator != null) {\n    accountAmounts.push({\n      accountID: operator.accountId._toProtobuf(),\n      amount: paymentAmount.negated().toTinybars()\n    });\n    accountAmounts.push({\n      accountID: nodeId._toProtobuf(),\n      amount: paymentAmount.toTinybars()\n    });\n  } else {\n    accountAmounts.push({\n      accountID: new AccountId(0)._toProtobuf(),\n      amount: paymentAmount.negated().toTinybars()\n    });\n    accountAmounts.push({\n      accountID: nodeId._toProtobuf(),\n      amount: paymentAmount.toTinybars()\n    });\n  }\n  /**\n   * @type {proto.ITransactionBody}\n   */\n\n\n  const body = {\n    transactionID: paymentTransactionId._toProtobuf(),\n    nodeAccountID: nodeId._toProtobuf(),\n    transactionFee: new Hbar(1).toTinybars(),\n    transactionValidDuration: {\n      seconds: Long.fromNumber(120)\n    },\n    cryptoTransfer: {\n      transfers: {\n        accountAmounts\n      }\n    }\n  };\n  /** @type {proto.ISignedTransaction} */\n\n  const signedTransaction = {\n    bodyBytes: ProtoTransactionBody.encode(body).finish()\n  };\n\n  if (operator != null) {\n    const signature = await operator.transactionSigner(\n    /** @type {Uint8Array} */\n    signedTransaction.bodyBytes);\n    signedTransaction.sigMap = {\n      sigPair: [operator.publicKey._toProtobufSignature(signature)]\n    };\n  }\n\n  return {\n    signedTransactionBytes: ProtoSignedTransaction.encode(signedTransaction).finish()\n  };\n}\n/**\n * @type {((query: Query<*>) => import(\"./CostQuery.js\").default<*>)[]}\n */\n\nexport const COST_QUERY = [];","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/query/Query.js"],"names":["Status","AccountId","Hbar","Executable","ExecutionState","TransactionId","Query","ProtoQuery","TransactionBody","ProtoTransactionBody","SignedTransaction","ProtoSignedTransaction","ResponseType","ProtoResponseType","ResponseCodeEnum","PrecheckStatusError","MaxQueryPaymentExceeded","Long","QUERY_REGISTRY","Map","constructor","_paymentTransactionId","_paymentTransactions","_queryPayment","_maxQueryPayment","fromBytes","bytes","query","decode","Error","fromProtobuf","get","toBytes","encode","_makeRequest","finish","setQueryPayment","queryPayment","setMaxQueryPayment","maxQueryPayment","getCost","client","_nodeIds","length","_network","getNodeAccountIdsForExecute","COST_QUERY","execute","setPaymentTransactionId","paymentTransactionId","_getTransactionId","_isPaymentRequired","_validateChecksums","_beforeExecute","isAutoValidateChecksumsEnabled","operator","_operator","generate","accountId","cost","actualCost","toTinybars","toInt","node","push","_makePaymentTransaction","_mapResponseHeader","response","_makeRequestHeader","header","responseType","ANSWER_ONLY","payment","_nextNodeIndex","_onMakeRequest","_makeRequestAsync","Promise","resolve","_shouldRetry","request","nodeTransactionPrecheckCode","status","_fromCode","OK","Busy","Unknown","PlatformTransactionNotCreated","Retry","Ok","Finished","_mapStatusError","transactionId","_getNodeAccountId","_advanceRequest","nodeId","paymentAmount","accountAmounts","accountID","_toProtobuf","amount","negated","body","transactionID","nodeAccountID","transactionFee","transactionValidDuration","seconds","fromNumber","cryptoTransfer","transfers","signedTransaction","bodyBytes","signature","transactionSigner","sigMap","sigPair","publicKey","_toProtobufSignature","signedTransactionBytes"],"mappings":"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","sourcesContent":["import Status from \"../Status.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport Hbar from \"../Hbar.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport {\n    Query as ProtoQuery,\n    TransactionBody as ProtoTransactionBody,\n    SignedTransaction as ProtoSignedTransaction,\n    ResponseType as ProtoResponseType,\n    ResponseCodeEnum,\n} from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport MaxQueryPaymentExceeded from \"../MaxQueryPaymentExceeded.js\";\nimport Long from \"long\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IQuery} proto.IQuery\n * @typedef {import(\"@hashgraph/proto\").IQueryHeader} proto.IQueryHeader\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").IResponse} proto.IResponse\n * @typedef {import(\"@hashgraph/proto\").IResponseHeader} proto.IResponseHeader\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ResponseCodeEnum} proto.ResponseCodeEnum\n */\n\n/**\n * @typedef {import(\"../client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\n/**\n * @type {Map<ProtoQuery[\"query\"], (query: proto.IQuery) => Query<*>>}\n */\nexport const QUERY_REGISTRY = new Map();\n\n/**\n * Base class for all queries that can be submitted to Hedera.\n *\n * @abstract\n * @template OutputT\n * @augments {Executable<proto.IQuery, proto.IResponse, OutputT>}\n */\nexport default class Query extends Executable {\n    constructor() {\n        super();\n\n        /** @type {?TransactionId} */\n        this._paymentTransactionId = null;\n\n        /** @type {proto.ITransaction[]} */\n        this._paymentTransactions = [];\n\n        /** @type {?Hbar} */\n        this._queryPayment = null;\n\n        /** @type {?Hbar} */\n        this._maxQueryPayment = null;\n    }\n\n    /**\n     * @template T\n     * @param {Uint8Array} bytes\n     * @returns {Query<T>}\n     */\n    static fromBytes(bytes) {\n        const query = ProtoQuery.decode(bytes);\n\n        if (query.query == null) {\n            throw new Error(\"(BUG) query.query was not set in the protobuf\");\n        }\n\n        const fromProtobuf = /** @type {(query: proto.IQuery) => Query<T>} */ (\n            QUERY_REGISTRY.get(query.query)\n        );\n\n        if (fromProtobuf == null) {\n            throw new Error(\n                `(BUG) Query.fromBytes() not implemented for type ${query.query}`\n            );\n        }\n\n        return fromProtobuf(query);\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return ProtoQuery.encode(this._makeRequest()).finish();\n    }\n\n    /**\n     * Set an explicit payment amount for this query.\n     *\n     * The client will submit exactly this amount for the payment of this query. Hedera\n     * will not return any remainder.\n     *\n     * @param {Hbar} queryPayment\n     * @returns {this}\n     */\n    setQueryPayment(queryPayment) {\n        this._queryPayment = queryPayment;\n\n        return this;\n    }\n\n    /**\n     * Set the maximum payment allowable for this query.\n     *\n     * @param {Hbar} maxQueryPayment\n     * @returns {this}\n     */\n    setMaxQueryPayment(maxQueryPayment) {\n        this._maxQueryPayment = maxQueryPayment;\n\n        return this;\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<Hbar>}\n     */\n    getCost(client) {\n        if (this._nodeIds.length == 0) {\n            this._nodeIds = client._network.getNodeAccountIdsForExecute();\n        }\n\n        if (COST_QUERY.length != 1) {\n            throw new Error(\"CostQuery has not been loaded yet\");\n        }\n\n        return COST_QUERY[0](this).execute(client);\n    }\n\n    /**\n     * @param {TransactionId} paymentTransactionId\n     * @returns {this}\n     */\n    setPaymentTransactionId(paymentTransactionId) {\n        this._paymentTransactionId = paymentTransactionId;\n        return this;\n    }\n\n    /**\n     * @returns {?TransactionId}\n     */\n    get paymentTransactionId() {\n        return this._paymentTransactionId;\n    }\n\n    /**\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        if (this._paymentTransactionId == null) {\n            throw new Error(\n                \"Query.PaymentTransactionId was not set duration execution\"\n            );\n        }\n\n        return this._paymentTransactionId;\n    }\n\n    /**\n     * @protected\n     * @returns {boolean}\n     */\n    _isPaymentRequired() {\n        return true;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n    _validateChecksums(client) {\n        // Do nothing\n    }\n\n    /**\n     * @template MirrorChannelT\n     * @param {import(\"../client/Client.js\").default<Channel, MirrorChannelT>} client\n     * @returns {Promise<void>}\n     */\n    async _beforeExecute(client) {\n        if (this._paymentTransactions.length > 0) {\n            return;\n        }\n\n        if (client.isAutoValidateChecksumsEnabled()) {\n            this._validateChecksums(client);\n        }\n\n        if (this._nodeIds.length == 0) {\n            this._nodeIds = client._network.getNodeAccountIdsForExecute();\n        }\n\n        const operator = client._operator;\n\n        if (this._paymentTransactionId == null) {\n            if (this._isPaymentRequired()) {\n                if (operator != null) {\n                    this._paymentTransactionId = TransactionId.generate(\n                        operator.accountId\n                    );\n                } else {\n                    throw new Error(\n                        \"`client` must have an `operator` or an explicit payment transaction must be provided\"\n                    );\n                }\n            } else {\n                this._paymentTransactionId = TransactionId.generate(\n                    new AccountId(0)\n                );\n            }\n        }\n\n        let cost =\n            this._queryPayment != null\n                ? this._queryPayment\n                : client.maxQueryPayment;\n\n        if (\n            this._paymentTransactions.length !== 0 ||\n            !this._isPaymentRequired()\n        ) {\n            cost = new Hbar(0);\n        } else {\n            if (this._queryPayment == null) {\n                const actualCost = await this.getCost(client);\n\n                if (\n                    cost.toTinybars().toInt() < actualCost.toTinybars().toInt()\n                ) {\n                    throw new MaxQueryPaymentExceeded(cost, actualCost);\n                }\n\n                cost = actualCost;\n            }\n        }\n\n        for (const node of this._nodeIds) {\n            this._paymentTransactions.push(\n                await _makePaymentTransaction(\n                    /** @type {import(\"../transaction/TransactionId.js\").default} */ (\n                        this._paymentTransactionId\n                    ),\n                    node,\n                    this._isPaymentRequired() ? operator : null,\n                    /** @type {Hbar} */ (cost)\n                )\n            );\n        }\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {proto.IResponse} response\n     * @returns {proto.IResponseHeader}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapResponseHeader(response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @protected\n     * @returns {proto.IQueryHeader}\n     */\n    _makeRequestHeader() {\n        /** @type {proto.IQueryHeader} */\n        let header = {};\n\n        if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {\n            header = {\n                responseType: ProtoResponseType.ANSWER_ONLY,\n                payment: this._paymentTransactions[this._nextNodeIndex],\n            };\n        }\n\n        return header;\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {proto.IQueryHeader} header\n     * @returns {proto.IQuery}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _onMakeRequest(header) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @internal\n     * @returns {proto.IQuery}\n     */\n    _makeRequest() {\n        /** @type {proto.IQueryHeader} */\n        let header = {};\n\n        if (this._isPaymentRequired() && this._paymentTransactions != null) {\n            header = {\n                payment: this._paymentTransactions[this._nextNodeIndex],\n                responseType: ProtoResponseType.ANSWER_ONLY,\n            };\n        }\n\n        return this._onMakeRequest(header);\n    }\n\n    /**\n     * @override\n     * @internal\n     * @returns {Promise<proto.IQuery>}\n     */\n    _makeRequestAsync() {\n        return Promise.resolve(this._makeRequest());\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {proto.IQuery} request\n     * @param {proto.IResponse} response\n     * @returns {ExecutionState}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        const { nodeTransactionPrecheckCode } =\n            this._mapResponseHeader(response);\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : ResponseCodeEnum.OK\n        );\n\n        switch (status) {\n            case Status.Busy:\n            case Status.Unknown:\n            case Status.PlatformTransactionNotCreated:\n                return ExecutionState.Retry;\n            case Status.Ok:\n                return ExecutionState.Finished;\n            default:\n                return ExecutionState.Error;\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {proto.IQuery} request\n     * @param {proto.IResponse} response\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response) {\n        const { nodeTransactionPrecheckCode } =\n            this._mapResponseHeader(response);\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : ResponseCodeEnum.OK\n        );\n\n        return new PrecheckStatusError({\n            status,\n            transactionId: this._getTransactionId(),\n        });\n    }\n\n    /**\n     * @returns {AccountId}\n     */\n    _getNodeAccountId() {\n        if (this._nodeIds.length > 0) {\n            // if there are payment transactions,\n            // we need to use the node of the current payment transaction\n            return this._nodeIds[this._nextNodeIndex];\n        } else {\n            throw new Error(\n                \"(BUG) nodeAccountIds were not set for query before executing\"\n            );\n        }\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {void}\n     */\n    _advanceRequest() {\n        if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {\n            // each time we move our cursor to the next transaction\n            // wrapping around to ensure we are cycling\n            super._nextNodeIndex =\n                (this._nextNodeIndex + 1) % this._paymentTransactions.length;\n        } else {\n            super._advanceRequest();\n        }\n    }\n}\n\n/**\n * @param {TransactionId} paymentTransactionId\n * @param {AccountId} nodeId\n * @param {?ClientOperator} operator\n * @param {Hbar} paymentAmount\n * @returns {Promise<proto.ITransaction>}\n */\nexport async function _makePaymentTransaction(\n    paymentTransactionId,\n    nodeId,\n    operator,\n    paymentAmount\n) {\n    const accountAmounts = [];\n\n    if (operator != null) {\n        accountAmounts.push({\n            accountID: operator.accountId._toProtobuf(),\n            amount: paymentAmount.negated().toTinybars(),\n        });\n        accountAmounts.push({\n            accountID: nodeId._toProtobuf(),\n            amount: paymentAmount.toTinybars(),\n        });\n    } else {\n        accountAmounts.push({\n            accountID: new AccountId(0)._toProtobuf(),\n            amount: paymentAmount.negated().toTinybars(),\n        });\n        accountAmounts.push({\n            accountID: nodeId._toProtobuf(),\n            amount: paymentAmount.toTinybars(),\n        });\n    }\n    /**\n     * @type {proto.ITransactionBody}\n     */\n    const body = {\n        transactionID: paymentTransactionId._toProtobuf(),\n        nodeAccountID: nodeId._toProtobuf(),\n        transactionFee: new Hbar(1).toTinybars(),\n        transactionValidDuration: {\n            seconds: Long.fromNumber(120),\n        },\n        cryptoTransfer: {\n            transfers: {\n                accountAmounts,\n            },\n        },\n    };\n\n    /** @type {proto.ISignedTransaction} */\n    const signedTransaction = {\n        bodyBytes: ProtoTransactionBody.encode(body).finish(),\n    };\n\n    if (operator != null) {\n        const signature = await operator.transactionSigner(\n            /** @type {Uint8Array} */ (signedTransaction.bodyBytes)\n        );\n\n        signedTransaction.sigMap = {\n            sigPair: [operator.publicKey._toProtobufSignature(signature)],\n        };\n    }\n\n    return {\n        signedTransactionBytes:\n            ProtoSignedTransaction.encode(signedTransaction).finish(),\n    };\n}\n\n/**\n * @type {((query: Query<*>) => import(\"./CostQuery.js\").default<*>)[]}\n */\nexport const COST_QUERY = [];\n"]},"metadata":{},"sourceType":"module"}