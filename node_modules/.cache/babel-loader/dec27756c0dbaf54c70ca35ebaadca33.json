{"ast":null,"code":"import BadKeyError from \"../BadKeyError.js\";\nimport { EncryptedPrivateKeyInfo } from \"../primitive/pkcs.js\";\nimport * as der from \"./der.js\";\nimport * as base64 from \"./base64.js\";\nimport Ed25519PrivateKey from \"../Ed25519PrivateKey.js\";\nimport EcdsaPrivateKey from \"../EcdsaPrivateKey.js\";\nconst BEGIN_PRIVATEKEY = \"-----BEGIN PRIVATE KEY-----\\n\";\nconst END_PRIVATEKEY = \"-----END PRIVATE KEY-----\\n\";\nconst BEGIN_ENCRYPTED_PRIVATEKEY = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\\n\";\nconst END_ENCRYPTED_PRIVATEKEY = \"-----END ENCRYPTED PRIVATE KEY-----\\n\";\n/**\n * @param {string} pem\n * @param {string} [passphrase]\n * @returns {Promise<Ed25519PrivateKey | EcdsaPrivateKey | Uint8Array>}\n */\n\nexport async function read(pem, passphrase) {\n  const beginTag = passphrase ? BEGIN_ENCRYPTED_PRIVATEKEY : BEGIN_PRIVATEKEY;\n  const endTag = passphrase ? END_ENCRYPTED_PRIVATEKEY : END_PRIVATEKEY;\n  const beginIndex = pem.indexOf(beginTag);\n  const endIndex = pem.indexOf(endTag);\n\n  if (beginIndex === -1 || endIndex === -1) {\n    throw new BadKeyError(\"failed to find a private key in the PEM file\");\n  }\n\n  const keyEncoded = pem.slice(beginIndex + beginTag.length, endIndex);\n  const key = base64.decode(keyEncoded);\n\n  if (passphrase) {\n    let encrypted;\n\n    try {\n      encrypted = EncryptedPrivateKeyInfo.parse(key);\n    } catch (error) {\n      const message = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      error != null &&\n      /** @type {Error} */\n      error.message != null ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n      /** @type {Error} */\n      error.message : \"\";\n      throw new BadKeyError(`failed to parse encrypted private key: ${message}`);\n    }\n\n    const decrypted = await encrypted.decrypt(passphrase);\n    let privateKey = null;\n\n    if (decrypted.algId.algIdent === \"1.3.101.112\") {\n      privateKey = Ed25519PrivateKey;\n    } else if (decrypted.algId.algIdent === \"1.3.132.0.10\") {\n      privateKey = EcdsaPrivateKey;\n    } else {\n      throw new BadKeyError(`unknown private key algorithm ${decrypted.algId.toString()}`);\n    }\n\n    const keyData = der.decode(decrypted.privateKey);\n\n    if (!(\"bytes\" in keyData)) {\n      throw new BadKeyError(`expected ASN bytes, got ${JSON.stringify(keyData)}`);\n    }\n\n    return privateKey.fromBytes(keyData.bytes);\n  }\n\n  return key.subarray(16);\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/encoding/pem.js"],"names":["BadKeyError","EncryptedPrivateKeyInfo","der","base64","Ed25519PrivateKey","EcdsaPrivateKey","BEGIN_PRIVATEKEY","END_PRIVATEKEY","BEGIN_ENCRYPTED_PRIVATEKEY","END_ENCRYPTED_PRIVATEKEY","read","pem","passphrase","beginTag","endTag","beginIndex","indexOf","endIndex","keyEncoded","slice","length","key","decode","encrypted","parse","error","message","decrypted","decrypt","privateKey","algId","algIdent","toString","keyData","JSON","stringify","fromBytes","bytes","subarray"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,mBAAxB;AACA,SAASC,uBAAT,QAAwC,sBAAxC;AACA,OAAO,KAAKC,GAAZ,MAAqB,UAArB;AACA,OAAO,KAAKC,MAAZ,MAAwB,aAAxB;AACA,OAAOC,iBAAP,MAA8B,yBAA9B;AACA,OAAOC,eAAP,MAA4B,uBAA5B;AAEA,MAAMC,gBAAgB,GAAG,+BAAzB;AACA,MAAMC,cAAc,GAAG,6BAAvB;AAEA,MAAMC,0BAA0B,GAAG,yCAAnC;AACA,MAAMC,wBAAwB,GAAG,uCAAjC;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeC,IAAf,CAAoBC,GAApB,EAAyBC,UAAzB,EAAqC;AACxC,QAAMC,QAAQ,GAAGD,UAAU,GAAGJ,0BAAH,GAAgCF,gBAA3D;AAEA,QAAMQ,MAAM,GAAGF,UAAU,GAAGH,wBAAH,GAA8BF,cAAvD;AAEA,QAAMQ,UAAU,GAAGJ,GAAG,CAACK,OAAJ,CAAYH,QAAZ,CAAnB;AACA,QAAMI,QAAQ,GAAGN,GAAG,CAACK,OAAJ,CAAYF,MAAZ,CAAjB;;AAEA,MAAIC,UAAU,KAAK,CAAC,CAAhB,IAAqBE,QAAQ,KAAK,CAAC,CAAvC,EAA0C;AACtC,UAAM,IAAIjB,WAAJ,CAAgB,8CAAhB,CAAN;AACH;;AAED,QAAMkB,UAAU,GAAGP,GAAG,CAACQ,KAAJ,CAAUJ,UAAU,GAAGF,QAAQ,CAACO,MAAhC,EAAwCH,QAAxC,CAAnB;AAEA,QAAMI,GAAG,GAAGlB,MAAM,CAACmB,MAAP,CAAcJ,UAAd,CAAZ;;AAEA,MAAIN,UAAJ,EAAgB;AACZ,QAAIW,SAAJ;;AAEA,QAAI;AACAA,MAAAA,SAAS,GAAGtB,uBAAuB,CAACuB,KAAxB,CAA8BH,GAA9B,CAAZ;AACH,KAFD,CAEE,OAAOI,KAAP,EAAc;AACZ,YAAMC,OAAO,GACT;AACAD,MAAAA,KAAK,IAAI,IAAT;AAAiB;AAAsBA,MAAAA,KAAD,CAAQC,OAAR,IAAmB,IAAzD,GACM;;AACA;AAAsBD,MAAAA,KAAD,CAAQC,OAFnC,GAGM,EALV;AAOA,YAAM,IAAI1B,WAAJ,CACD,0CAAyC0B,OAAQ,EADhD,CAAN;AAGH;;AAED,UAAMC,SAAS,GAAG,MAAMJ,SAAS,CAACK,OAAV,CAAkBhB,UAAlB,CAAxB;AAEA,QAAIiB,UAAU,GAAG,IAAjB;;AAEA,QAAIF,SAAS,CAACG,KAAV,CAAgBC,QAAhB,KAA6B,aAAjC,EAAgD;AAC5CF,MAAAA,UAAU,GAAGzB,iBAAb;AACH,KAFD,MAEO,IAAIuB,SAAS,CAACG,KAAV,CAAgBC,QAAhB,KAA6B,cAAjC,EAAiD;AACpDF,MAAAA,UAAU,GAAGxB,eAAb;AACH,KAFM,MAEA;AACH,YAAM,IAAIL,WAAJ,CACD,iCAAgC2B,SAAS,CAACG,KAAV,CAAgBE,QAAhB,EAA2B,EAD1D,CAAN;AAGH;;AAED,UAAMC,OAAO,GAAG/B,GAAG,CAACoB,MAAJ,CAAWK,SAAS,CAACE,UAArB,CAAhB;;AAEA,QAAI,EAAE,WAAWI,OAAb,CAAJ,EAA2B;AACvB,YAAM,IAAIjC,WAAJ,CACD,2BAA0BkC,IAAI,CAACC,SAAL,CAAeF,OAAf,CAAwB,EADjD,CAAN;AAGH;;AAED,WAAOJ,UAAU,CAACO,SAAX,CAAqBH,OAAO,CAACI,KAA7B,CAAP;AACH;;AAED,SAAOhB,GAAG,CAACiB,QAAJ,CAAa,EAAb,CAAP;AACH","sourcesContent":["import BadKeyError from \"../BadKeyError.js\";\nimport { EncryptedPrivateKeyInfo } from \"../primitive/pkcs.js\";\nimport * as der from \"./der.js\";\nimport * as base64 from \"./base64.js\";\nimport Ed25519PrivateKey from \"../Ed25519PrivateKey.js\";\nimport EcdsaPrivateKey from \"../EcdsaPrivateKey.js\";\n\nconst BEGIN_PRIVATEKEY = \"-----BEGIN PRIVATE KEY-----\\n\";\nconst END_PRIVATEKEY = \"-----END PRIVATE KEY-----\\n\";\n\nconst BEGIN_ENCRYPTED_PRIVATEKEY = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\\n\";\nconst END_ENCRYPTED_PRIVATEKEY = \"-----END ENCRYPTED PRIVATE KEY-----\\n\";\n\n/**\n * @param {string} pem\n * @param {string} [passphrase]\n * @returns {Promise<Ed25519PrivateKey | EcdsaPrivateKey | Uint8Array>}\n */\nexport async function read(pem, passphrase) {\n    const beginTag = passphrase ? BEGIN_ENCRYPTED_PRIVATEKEY : BEGIN_PRIVATEKEY;\n\n    const endTag = passphrase ? END_ENCRYPTED_PRIVATEKEY : END_PRIVATEKEY;\n\n    const beginIndex = pem.indexOf(beginTag);\n    const endIndex = pem.indexOf(endTag);\n\n    if (beginIndex === -1 || endIndex === -1) {\n        throw new BadKeyError(\"failed to find a private key in the PEM file\");\n    }\n\n    const keyEncoded = pem.slice(beginIndex + beginTag.length, endIndex);\n\n    const key = base64.decode(keyEncoded);\n\n    if (passphrase) {\n        let encrypted;\n\n        try {\n            encrypted = EncryptedPrivateKeyInfo.parse(key);\n        } catch (error) {\n            const message =\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                error != null && /** @type {Error} */ (error).message != null\n                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                      /** @type {Error} */ (error).message\n                    : \"\";\n\n            throw new BadKeyError(\n                `failed to parse encrypted private key: ${message}`\n            );\n        }\n\n        const decrypted = await encrypted.decrypt(passphrase);\n\n        let privateKey = null;\n\n        if (decrypted.algId.algIdent === \"1.3.101.112\") {\n            privateKey = Ed25519PrivateKey;\n        } else if (decrypted.algId.algIdent === \"1.3.132.0.10\") {\n            privateKey = EcdsaPrivateKey;\n        } else {\n            throw new BadKeyError(\n                `unknown private key algorithm ${decrypted.algId.toString()}`\n            );\n        }\n\n        const keyData = der.decode(decrypted.privateKey);\n\n        if (!(\"bytes\" in keyData)) {\n            throw new BadKeyError(\n                `expected ASN bytes, got ${JSON.stringify(keyData)}`\n            );\n        }\n\n        return privateKey.fromBytes(keyData.bytes);\n    }\n\n    return key.subarray(16);\n}\n"]},"metadata":{},"sourceType":"module"}