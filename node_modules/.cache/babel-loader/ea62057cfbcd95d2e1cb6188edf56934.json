{"ast":null,"code":"\"use strict\";\n\nmodule.exports = asPromise;\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\n\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\n\nfunction asPromise(fn, ctx\n/*, varargs */\n) {\n  var params = new Array(arguments.length - 1),\n      offset = 0,\n      index = 2,\n      pending = true;\n\n  while (index < arguments.length) params[offset++] = arguments[index++];\n\n  return new Promise(function executor(resolve, reject) {\n    params[offset] = function callback(err\n    /*, varargs */\n    ) {\n      if (pending) {\n        pending = false;\n        if (err) reject(err);else {\n          var params = new Array(arguments.length - 1),\n              offset = 0;\n\n          while (offset < params.length) params[offset++] = arguments[offset];\n\n          resolve.apply(null, params);\n        }\n      }\n    };\n\n    try {\n      fn.apply(ctx || null, params);\n    } catch (err) {\n      if (pending) {\n        pending = false;\n        reject(err);\n      }\n    }\n  });\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@protobufjs/aspromise/index.js"],"names":["module","exports","asPromise","fn","ctx","params","Array","arguments","length","offset","index","pending","Promise","executor","resolve","reject","callback","err","apply"],"mappings":"AAAA;;AACAA,MAAM,CAACC,OAAP,GAAiBC,SAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,SAAT,CAAmBC,EAAnB,EAAuBC;AAAG;AAA1B,EAA0C;AACtC,MAAIC,MAAM,GAAI,IAAIC,KAAJ,CAAUC,SAAS,CAACC,MAAV,GAAmB,CAA7B,CAAd;AAAA,MACIC,MAAM,GAAI,CADd;AAAA,MAEIC,KAAK,GAAK,CAFd;AAAA,MAGIC,OAAO,GAAG,IAHd;;AAIA,SAAOD,KAAK,GAAGH,SAAS,CAACC,MAAzB,EACIH,MAAM,CAACI,MAAM,EAAP,CAAN,GAAmBF,SAAS,CAACG,KAAK,EAAN,CAA5B;;AACJ,SAAO,IAAIE,OAAJ,CAAY,SAASC,QAAT,CAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AAClDV,IAAAA,MAAM,CAACI,MAAD,CAAN,GAAiB,SAASO,QAAT,CAAkBC;AAAG;AAArB,MAAqC;AAClD,UAAIN,OAAJ,EAAa;AACTA,QAAAA,OAAO,GAAG,KAAV;AACA,YAAIM,GAAJ,EACIF,MAAM,CAACE,GAAD,CAAN,CADJ,KAEK;AACD,cAAIZ,MAAM,GAAG,IAAIC,KAAJ,CAAUC,SAAS,CAACC,MAAV,GAAmB,CAA7B,CAAb;AAAA,cACIC,MAAM,GAAG,CADb;;AAEA,iBAAOA,MAAM,GAAGJ,MAAM,CAACG,MAAvB,EACIH,MAAM,CAACI,MAAM,EAAP,CAAN,GAAmBF,SAAS,CAACE,MAAD,CAA5B;;AACJK,UAAAA,OAAO,CAACI,KAAR,CAAc,IAAd,EAAoBb,MAApB;AACH;AACJ;AACJ,KAbD;;AAcA,QAAI;AACAF,MAAAA,EAAE,CAACe,KAAH,CAASd,GAAG,IAAI,IAAhB,EAAsBC,MAAtB;AACH,KAFD,CAEE,OAAOY,GAAP,EAAY;AACV,UAAIN,OAAJ,EAAa;AACTA,QAAAA,OAAO,GAAG,KAAV;AACAI,QAAAA,MAAM,CAACE,GAAD,CAAN;AACH;AACJ;AACJ,GAvBM,CAAP;AAwBH","sourcesContent":["\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n"]},"metadata":{},"sourceType":"script"}