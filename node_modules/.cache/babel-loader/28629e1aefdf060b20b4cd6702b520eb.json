{"ast":null,"code":"import ManagedNodeAddress from \"./ManagedNodeAddress.js\";\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"./address_book/NodeAddress.js\").default} NodeAddress\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {object} NewNode\n * @property {string | ManagedNodeAddress} address\n * @property {(address: string, cert?: string) => ChannelT} channelInitFunction\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {object} CloneNode\n * @property {ManagedNode<ChannelT>} node\n * @property {ManagedNodeAddress} address\n */\n\n/**\n * @abstract\n * @template {Channel | MirrorChannel} ChannelT\n */\n\nexport default class ManagedNode {\n  /**\n   * @param {object} props\n   * @param {NewNode<ChannelT>=} [props.newNode]\n   * @param {CloneNode<ChannelT>=} [props.cloneNode]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (props.newNode != null) {\n      this._address = typeof props.newNode.address === \"string\" ? ManagedNodeAddress.fromString(props.newNode.address) : props.newNode.address;\n      /** @type {string=} */\n\n      this._cert = undefined;\n      /** @type {ChannelT | null} */\n\n      this._channel = null;\n      /** @type {(address: string, cert?: string) => ChannelT} */\n\n      this._channelInitFunction = props.newNode.channelInitFunction;\n      this._currentBackoff = 250;\n      this._lastUsed = Date.now();\n      this._backoffUntil = Date.now();\n      this._useCount = 0;\n      this._attempts = 0;\n      this._minBackoff = 250;\n      this._maxBackoff = 8000;\n    } else if (props.cloneNode != null) {\n      /** @type {ManagedNodeAddress} */\n      this._address = props.cloneNode.address;\n      /** @type {string=} */\n\n      this._cert = props.cloneNode.node._cert;\n      /** @type {ChannelT | null} */\n\n      this._channel = props.cloneNode.node._channel;\n      /** @type {(address: string, cert?: string) => ChannelT} */\n\n      this._channelInitFunction = props.cloneNode.node._channelInitFunction;\n      /** @type {number} */\n\n      this._currentBackoff = props.cloneNode.node._currentBackoff;\n      /** @type {number} */\n\n      this._lastUsed = props.cloneNode.node._lastUsed;\n      /** @type {number} */\n\n      this._backoffUntil = props.cloneNode.node._backoffUntil;\n      /** @type {number} */\n\n      this._useCount = props.cloneNode.node._useCount;\n      /** @type {number} */\n\n      this._attempts = props.cloneNode.node._attempts;\n      /** @type {number} */\n\n      this._minBackoff = props.cloneNode.node._minBackoff;\n      /** @type {number} */\n\n      this._maxBackoff = props.cloneNode.node._minBackoff;\n    } else {\n      throw new Error(`failed to create ManagedNode: ${JSON.stringify(props)}`);\n    }\n  }\n  /**\n   * @abstract\n   * @returns {string}\n   */\n  // eslint-disable-next-line jsdoc/require-returns-check\n\n\n  getKey() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @returns {ManagedNode<ChannelT>}\n   */\n  // eslint-disable-next-line jsdoc/require-returns-check\n\n\n  toInsecure() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @returns {ManagedNode<ChannelT>}\n   */\n  // eslint-disable-next-line jsdoc/require-returns-check\n\n\n  toSecure() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @param {string} ledgerId\n   * @returns {this}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  setCert(ledgerId) {\n    return this;\n  }\n  /**\n   * @returns {ManagedNodeAddress}\n   */\n\n\n  get address() {\n    return this._address;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get attempts() {\n    return this._attempts;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get minBackoff() {\n    return this._minBackoff;\n  }\n  /**\n   * @param {number} minBackoff\n   * @returns {this}\n   */\n\n\n  setMinBackoff(minBackoff) {\n    if (this._currentBackoff <= minBackoff) {\n      this._currentBackoff = minBackoff;\n    }\n\n    this._minBackoff = minBackoff;\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get maxBackoff() {\n    return this._maxBackoff;\n  }\n  /**\n   * @param {number} maxBackoff\n   * @returns {this}\n   */\n\n\n  setmaxBackoff(maxBackoff) {\n    if (this._currentBackoff <= maxBackoff) {\n      this._currentBackoff = maxBackoff;\n    }\n\n    this._maxBackoff = maxBackoff;\n    return this;\n  }\n\n  getChannel() {\n    this._useCount++;\n    this.__lastUsed = Date.now();\n\n    if (this._channel != null) {\n      return this._channel;\n    }\n\n    this._channel = this._channelInitFunction(this.address.toString(), this._cert);\n    return this._channel;\n  }\n  /**\n   * Determines if this node is healthy by checking if this node hasn't been\n   * in use for a the required `_currentBackoff` period. Since this looks at `this._lastUsed`\n   * and that value is only set in the `wait()` method, any node that has not\n   * returned a bad gRPC status will always be considered healthy.\n   *\n   * @returns {boolean}\n   */\n\n\n  isHealthy() {\n    return this._backoffUntil <= Date.now();\n  }\n\n  increaseDelay() {\n    this._currentBackoff = Math.min(this._currentBackoff * 2, this._maxBackoff);\n    this._backoffUntil = Date.now() + this._currentBackoff;\n  }\n\n  decreaseDelay() {\n    this._currentBackoff = Math.max(this._currentBackoff / 2, this._minBackoff);\n  }\n  /**\n   * This is only ever called if the node itself is down.\n   * A node returning a transaction with a bad status code does not indicate\n   * the node is down, and hence this method will not be called.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  wait() {\n    const _currentBackoff = this._backoffUntil - this._lastUsed;\n\n    return new Promise(resolve => setTimeout(resolve, _currentBackoff));\n  }\n  /**\n   * @param {ManagedNode<*>} node\n   * @returns {number}\n   */\n\n\n  compare(node) {\n    if (this.isHealthy() && node.isHealthy()) {\n      if (this._useCount < node._useCount) {\n        return -1;\n      } else if (this._useCount > node._useCount) {\n        return 1;\n      } else {\n        if (this._lastUsed < node._lastUsed) {\n          return -1;\n        } else if (this._lastUsed > node._lastUsed) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n    } else if (this.isHealthy() && !node.isHealthy()) {\n      return -1;\n    } else if (!this.isHealthy() && node.isHealthy()) {\n      return 1;\n    } else {\n      if (this._useCount < node._useCount) {\n        return -1;\n      } else if (this._useCount > node._useCount) {\n        return 1;\n      } else {\n        if (this._lastUsed < node._lastUsed) {\n          return -1;\n        } else if (this._lastUsed > node._lastUsed) {\n          return 1;\n        } else {\n          return 0;\n        }\n      }\n    }\n  }\n\n  close() {\n    if (this._channel != null) {\n      this._channel.close();\n    }\n\n    this._channel = null;\n  }\n\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/ManagedNode.js"],"names":["ManagedNodeAddress","ManagedNode","constructor","props","newNode","_address","address","fromString","_cert","undefined","_channel","_channelInitFunction","channelInitFunction","_currentBackoff","_lastUsed","Date","now","_backoffUntil","_useCount","_attempts","_minBackoff","_maxBackoff","cloneNode","node","Error","JSON","stringify","getKey","toInsecure","toSecure","setCert","ledgerId","attempts","minBackoff","setMinBackoff","maxBackoff","setmaxBackoff","getChannel","__lastUsed","toString","isHealthy","increaseDelay","Math","min","decreaseDelay","max","wait","Promise","resolve","setTimeout","compare","close"],"mappings":"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","sourcesContent":["import ManagedNodeAddress from \"./ManagedNodeAddress.js\";\n\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"./address_book/NodeAddress.js\").default} NodeAddress\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {object} NewNode\n * @property {string | ManagedNodeAddress} address\n * @property {(address: string, cert?: string) => ChannelT} channelInitFunction\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {object} CloneNode\n * @property {ManagedNode<ChannelT>} node\n * @property {ManagedNodeAddress} address\n */\n\n/**\n * @abstract\n * @template {Channel | MirrorChannel} ChannelT\n */\nexport default class ManagedNode {\n    /**\n     * @param {object} props\n     * @param {NewNode<ChannelT>=} [props.newNode]\n     * @param {CloneNode<ChannelT>=} [props.cloneNode]\n     */\n    constructor(props = {}) {\n        if (props.newNode != null) {\n            this._address =\n                typeof props.newNode.address === \"string\"\n                    ? ManagedNodeAddress.fromString(props.newNode.address)\n                    : props.newNode.address;\n\n            /** @type {string=} */\n            this._cert = undefined;\n\n            /** @type {ChannelT | null} */\n            this._channel = null;\n\n            /** @type {(address: string, cert?: string) => ChannelT} */\n            this._channelInitFunction = props.newNode.channelInitFunction;\n\n            this._currentBackoff = 250;\n            this._lastUsed = Date.now();\n            this._backoffUntil = Date.now();\n            this._useCount = 0;\n            this._attempts = 0;\n            this._minBackoff = 250;\n            this._maxBackoff = 8000;\n        } else if (props.cloneNode != null) {\n            /** @type {ManagedNodeAddress} */\n            this._address = props.cloneNode.address;\n\n            /** @type {string=} */\n            this._cert = props.cloneNode.node._cert;\n\n            /** @type {ChannelT | null} */\n            this._channel = props.cloneNode.node._channel;\n\n            /** @type {(address: string, cert?: string) => ChannelT} */\n            this._channelInitFunction =\n                props.cloneNode.node._channelInitFunction;\n\n            /** @type {number} */\n            this._currentBackoff = props.cloneNode.node._currentBackoff;\n\n            /** @type {number} */\n            this._lastUsed = props.cloneNode.node._lastUsed;\n\n            /** @type {number} */\n            this._backoffUntil = props.cloneNode.node._backoffUntil;\n\n            /** @type {number} */\n            this._useCount = props.cloneNode.node._useCount;\n\n            /** @type {number} */\n            this._attempts = props.cloneNode.node._attempts;\n\n            /** @type {number} */\n            this._minBackoff = props.cloneNode.node._minBackoff;\n\n            /** @type {number} */\n            this._maxBackoff = props.cloneNode.node._minBackoff;\n        } else {\n            throw new Error(\n                `failed to create ManagedNode: ${JSON.stringify(props)}`\n            );\n        }\n    }\n\n    /**\n     * @abstract\n     * @returns {string}\n     */\n    // eslint-disable-next-line jsdoc/require-returns-check\n    getKey() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @returns {ManagedNode<ChannelT>}\n     */\n    // eslint-disable-next-line jsdoc/require-returns-check\n    toInsecure() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @returns {ManagedNode<ChannelT>}\n     */\n    // eslint-disable-next-line jsdoc/require-returns-check\n    toSecure() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @param {string} ledgerId\n     * @returns {this}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setCert(ledgerId) {\n        return this;\n    }\n\n    /**\n     * @returns {ManagedNodeAddress}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get attempts() {\n        return this._attempts;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get minBackoff() {\n        return this._minBackoff;\n    }\n\n    /**\n     * @param {number} minBackoff\n     * @returns {this}\n     */\n    setMinBackoff(minBackoff) {\n        if (this._currentBackoff <= minBackoff) {\n            this._currentBackoff = minBackoff;\n        }\n\n        this._minBackoff = minBackoff;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxBackoff() {\n        return this._maxBackoff;\n    }\n\n    /**\n     * @param {number} maxBackoff\n     * @returns {this}\n     */\n    setmaxBackoff(maxBackoff) {\n        if (this._currentBackoff <= maxBackoff) {\n            this._currentBackoff = maxBackoff;\n        }\n\n        this._maxBackoff = maxBackoff;\n        return this;\n    }\n\n    getChannel() {\n        this._useCount++;\n        this.__lastUsed = Date.now();\n\n        if (this._channel != null) {\n            return this._channel;\n        }\n\n        this._channel = this._channelInitFunction(\n            this.address.toString(),\n            this._cert\n        );\n        return this._channel;\n    }\n\n    /**\n     * Determines if this node is healthy by checking if this node hasn't been\n     * in use for a the required `_currentBackoff` period. Since this looks at `this._lastUsed`\n     * and that value is only set in the `wait()` method, any node that has not\n     * returned a bad gRPC status will always be considered healthy.\n     *\n     * @returns {boolean}\n     */\n    isHealthy() {\n        return this._backoffUntil <= Date.now();\n    }\n\n    increaseDelay() {\n        this._currentBackoff = Math.min(\n            this._currentBackoff * 2,\n            this._maxBackoff\n        );\n        this._backoffUntil = Date.now() + this._currentBackoff;\n    }\n\n    decreaseDelay() {\n        this._currentBackoff = Math.max(\n            this._currentBackoff / 2,\n            this._minBackoff\n        );\n    }\n\n    /**\n     * This is only ever called if the node itself is down.\n     * A node returning a transaction with a bad status code does not indicate\n     * the node is down, and hence this method will not be called.\n     *\n     * @returns {Promise<void>}\n     */\n    wait() {\n        const _currentBackoff = this._backoffUntil - this._lastUsed;\n        return new Promise((resolve) => setTimeout(resolve, _currentBackoff));\n    }\n\n    /**\n     * @param {ManagedNode<*>} node\n     * @returns {number}\n     */\n    compare(node) {\n        if (this.isHealthy() && node.isHealthy()) {\n            if (this._useCount < node._useCount) {\n                return -1;\n            } else if (this._useCount > node._useCount) {\n                return 1;\n            } else {\n                if (this._lastUsed < node._lastUsed) {\n                    return -1;\n                } else if (this._lastUsed > node._lastUsed) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        } else if (this.isHealthy() && !node.isHealthy()) {\n            return -1;\n        } else if (!this.isHealthy() && node.isHealthy()) {\n            return 1;\n        } else {\n            if (this._useCount < node._useCount) {\n                return -1;\n            } else if (this._useCount > node._useCount) {\n                return 1;\n            } else {\n                if (this._lastUsed < node._lastUsed) {\n                    return -1;\n                } else if (this._lastUsed > node._lastUsed) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    }\n\n    close() {\n        if (this._channel != null) {\n            this._channel.close();\n        }\n\n        this._channel = null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}