{"ast":null,"code":"import Hbar from \"../Hbar.js\";\nimport TransactionResponse from \"./TransactionResponse.js\";\nimport TransactionId from \"./TransactionId.js\";\nimport TransactionHashMap from \"./TransactionHashMap.js\";\nimport SignatureMap from \"./SignatureMap.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport Status from \"../Status.js\";\nimport Long from \"long\";\nimport * as sha384 from \"../cryptography/sha384.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport { Transaction as ProtoTransaction, SignedTransaction as ProtoSignedTransaction, TransactionList as ProtoTransactionList, TransactionBody as ProtoTransactionBody, ResponseCodeEnum } from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport { arrayEqual } from \"../array.js\";\nimport PublicKey from \"../PublicKey.js\";\n/**\n * @typedef {import(\"bignumber.js\").default} BigNumber\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignaturePair} proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").ITransactionList} proto.ITransactionList\n * @typedef {import(\"@hashgraph/proto\").ITransactionID} proto.ITransactionID\n * @typedef {import(\"@hashgraph/proto\").IAccountID} proto.IAccountID\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionResponse} proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").ResponseCodeEnum} proto.ResponseCodeEnum\n * @typedef {import(\"@hashgraph/proto\").TransactionBody} proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").ISchedulableTransactionBody} proto.ISchedulableTransactionBody\n */\n\n/**\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n * @typedef {import(\"../PrivateKey.js\").default} PrivateKey\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n// 90 days (in seconds)\n\nexport const DEFAULT_AUTO_RENEW_PERIOD = Long.fromValue(7776000); // maximum value of i64 (so there is never a record generated)\n\nexport const DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(Long.fromString(\"9223372036854775807\")); // 120 seconds\n\nconst DEFAULT_TRANSACTION_VALID_DURATION = 120;\nexport const CHUNK_SIZE = 1024;\n/**\n * @type {Map<NonNullable<proto.TransactionBody[\"data\"]>, (transactions: proto.ITransaction[], signedTransactions: proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: proto.TransactionBody[]) => Transaction>}\n */\n\nexport const TRANSACTION_REGISTRY = new Map();\n/**\n * Base class for all transactions that may be submitted to Hedera.\n *\n * @abstract\n * @augments {Executable<proto.ITransaction, proto.ITransactionResponse, TransactionResponse>}\n */\n\nexport default class Transaction extends Executable {\n  // A SDK transaction is composed of multiple, raw protobuf transactions.\n  // These should be functionally identicasl, with the exception of pointing to\n  // different nodes.\n  // When retrying a transaction after a network error or retry-able\n  // status response, we try a different transaction and thus a different node.\n  constructor() {\n    super();\n    /**\n     * List of proto transactions that have been built from this SDK\n     * transaction. Each one should share the same transaction ID.\n     *\n     * @internal\n     * @type {(proto.ITransaction | null)[]}\n     */\n\n    this._transactions = [];\n    /**\n     * List of proto transactions that have been built from this SDK\n     * transaction. Each one should share the same transaction ID.\n     *\n     * @internal\n     * @type {proto.ISignedTransaction[]}\n     */\n\n    this._signedTransactions = [];\n    /**\n     * Set of public keys (as string) who have signed this transaction so\n     * we do not allow them to sign it again.\n     *\n     * @internal\n     * @type {Set<string>}\n     */\n\n    this._signerPublicKeys = new Set();\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this._nextTransactionIndex = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;\n    /**\n     * @private\n     * @type {Hbar}\n     */\n\n    this._maxTransactionFee = new Hbar(2);\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this._transactionMemo = \"\";\n    /**\n     * @protected\n     * @type {TransactionId[]}\n     */\n\n    this._transactionIds = [];\n    this._signOnDemand = false;\n    /**\n     * @private\n     * @type {PublicKey[]}\n     */\n\n    this._publicKeys = [];\n    /**\n     * @private\n     * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}\n     */\n\n    this._transactionSigners = [];\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {Transaction}\n   */\n\n\n  static fromBytes(bytes) {\n    const signedTransactions = [];\n    const transactionIds = [];\n    const nodeIds = [];\n    /** @type {string[]} */\n\n    const transactionIdStrings = [];\n    /** @type {string[]} */\n\n    const nodeIdStrings = [];\n    const bodies = [];\n    const list = ProtoTransactionList.decode(bytes).transactionList;\n\n    if (list.length == 0) {\n      const transaction = ProtoTransaction.decode(bytes);\n\n      if (transaction.signedTransactionBytes.length != 0) {\n        list.push(transaction);\n      } else {\n        list.push({\n          signedTransactionBytes: ProtoSignedTransaction.encode({\n            bodyBytes: transaction.bodyBytes,\n            sigMap: transaction.sigMap\n          }).finish()\n        });\n      }\n    }\n\n    for (const transaction of list) {\n      if (transaction.signedTransactionBytes == null) {\n        throw new Error(\"Transaction.signedTransactionBytes are null\");\n      }\n\n      const signedTransaction = ProtoSignedTransaction.decode(transaction.signedTransactionBytes);\n      signedTransactions.push(signedTransaction);\n      const body = ProtoTransactionBody.decode(signedTransaction.bodyBytes);\n\n      if (body.data == null) {\n        throw new Error(\"(BUG) body.data was not set in the protobuf\");\n      }\n\n      bodies.push(body);\n\n      if (body.transactionID != null) {\n        const transactionId = TransactionId._fromProtobuf(\n        /** @type {proto.ITransactionID} */\n        body.transactionID);\n\n        if (!transactionIdStrings.includes(transactionId.toString())) {\n          transactionIds.push(transactionId);\n          transactionIdStrings.push(transactionId.toString());\n        }\n      }\n\n      if (body.nodeAccountID != null) {\n        const nodeAccountId = AccountId._fromProtobuf(\n        /** @type {proto.IAccountID} */\n        body.nodeAccountID);\n\n        if (!nodeIdStrings.includes(nodeAccountId.toString())) {\n          nodeIds.push(nodeAccountId);\n          nodeIdStrings.push(nodeAccountId.toString());\n        }\n      }\n    }\n\n    const body = bodies[0];\n\n    if (body == null || body.data == null) {\n      throw new Error(\"No transaction found in bytes or failed to decode TransactionBody\");\n    }\n\n    const fromProtobuf = TRANSACTION_REGISTRY.get(body.data);\n\n    if (fromProtobuf == null) {\n      throw new Error(`(BUG) Transaction.fromBytes() not implemented for type ${body.data}`);\n    }\n\n    return fromProtobuf(list, signedTransactions, transactionIds, nodeIds, bodies);\n  }\n  /**\n   * @returns {ScheduleCreateTransaction}\n   */\n\n\n  schedule() {\n    this._requireNotFrozen();\n\n    if (SCHEDULE_CREATE_TRANSACTION.length != 1) {\n      throw new Error(\"ScheduleCreateTransaction has not been loaded yet\");\n    }\n\n    return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);\n  }\n  /**\n   * @template {Transaction} TransactionT\n   * @param {TransactionT} transaction\n   * @param {proto.ITransaction[]} transactions\n   * @param {proto.ISignedTransaction[]} signedTransactions\n   * @param {TransactionId[]} transactionIds\n   * @param {AccountId[]} nodeIds\n   * @param {proto.ITransactionBody[]} bodies\n   * @returns {TransactionT}\n   */\n\n\n  static _fromProtobufTransactions(transaction, transactions, signedTransactions, transactionIds, nodeIds, bodies) {\n    const body = bodies[0];\n    const zero = new AccountId(0);\n\n    for (let i = 0; i < nodeIds.length; i++) {\n      if (nodeIds[i].equals(zero)) {\n        nodeIds.splice(i--, 1);\n      }\n    }\n\n    transaction._transactions = transactions;\n    transaction._signedTransactions = signedTransactions;\n    transaction._transactionIds = transactionIds;\n    transaction._nodeIds = nodeIds;\n    transaction._nextNodeIndex = 0;\n    transaction._nextTransactionIndex = 0;\n    transaction._transactionValidDuration = body.transactionValidDuration != null && body.transactionValidDuration.seconds != null ? Long.fromValue(body.transactionValidDuration.seconds).toInt() : DEFAULT_TRANSACTION_VALID_DURATION;\n    transaction._maxTransactionFee = body.transactionFee != null ? Hbar.fromTinybars(body.transactionFee) : new Hbar(0);\n    transaction._transactionMemo = body.memo != null ? body.memo : \"\";\n\n    for (let i = 0; i < nodeIds.length; i++) {\n      const signedTransaction = signedTransactions[i];\n\n      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {\n        for (const sigPair of signedTransaction.sigMap.sigPair) {\n          transaction._signerPublicKeys.add(hex.encode(\n          /** @type {Uint8Array} */\n          sigPair.pubKeyPrefix));\n\n          transaction._publicKeys.push(PublicKey.fromBytes(\n          /** @type {Uint8Array} */\n          sigPair.pubKeyPrefix));\n\n          transaction._transactionSigners.push(null);\n        }\n      }\n    }\n\n    return transaction;\n  }\n  /**\n   * @override\n   * @param {AccountId[]} nodeIds\n   * @returns {this}\n   */\n\n\n  setNodeAccountIds(nodeIds) {\n    this._requireNotFrozen();\n\n    super.setNodeAccountIds(nodeIds);\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get transactionValidDuration() {\n    return this._transactionValidDuration;\n  }\n  /**\n   * Sets the duration (in seconds) that this transaction is valid for.\n   *\n   * This is defaulted to 120 seconds (from the time its executed).\n   *\n   * @param {number} validDuration\n   * @returns {this}\n   */\n\n\n  setTransactionValidDuration(validDuration) {\n    this._requireNotFrozen();\n\n    this._transactionValidDuration = validDuration;\n    return this;\n  }\n  /**\n   * @returns {?Hbar}\n   */\n\n\n  get maxTransactionFee() {\n    return this._maxTransactionFee;\n  }\n  /**\n   * Set the maximum transaction fee the operator (paying account)\n   * is willing to pay.\n   *\n   * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee\n   * @returns {this}\n   */\n\n\n  setMaxTransactionFee(maxTransactionFee) {\n    this._requireNotFrozen();\n\n    this._maxTransactionFee = maxTransactionFee instanceof Hbar ? maxTransactionFee : new Hbar(maxTransactionFee);\n    return this;\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  get transactionMemo() {\n    return this._transactionMemo;\n  }\n  /**\n   * Set a note or description to be recorded in the transaction\n   * record (maximum length of 100 bytes).\n   *\n   * @param {string} transactionMemo\n   * @returns {this}\n   */\n\n\n  setTransactionMemo(transactionMemo) {\n    this._requireNotFrozen();\n\n    this._transactionMemo = transactionMemo;\n    return this;\n  }\n  /**\n   * @returns {TransactionId}\n   */\n\n\n  get transactionId() {\n    if (this._transactionIds.length === 0) {\n      throw new Error(\"transaction must have been frozen before getting the transaction ID, try calling `freeze`\");\n    }\n\n    return this._transactionIds[this._nextTransactionIndex];\n  }\n  /**\n   * Set the ID for this transaction.\n   *\n   * The transaction ID includes the operator's account ( the account paying the transaction\n   * fee). If two transactions have the same transaction ID, they won't both have an effect. One\n   * will complete normally and the other will fail with a duplicate transaction status.\n   *\n   * Normally, you should not use this method. Just before a transaction is executed, a\n   * transaction ID will be generated from the operator on the client.\n   *\n   * @param {TransactionId} transactionId\n   * @returns {this}\n   */\n\n\n  setTransactionId(transactionId) {\n    this._requireNotFrozen();\n\n    this._transactionIds = [transactionId];\n    return this;\n  }\n  /**\n   * @param {PrivateKey} privateKey\n   * @returns {Promise<this>}\n   */\n\n\n  sign(privateKey) {\n    return this.signWith(privateKey.publicKey, message => Promise.resolve(privateKey.sign(message)));\n  }\n  /**\n   * @param {PublicKey} publicKey\n   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n   * @returns {Promise<this>}\n   */\n\n\n  async signWith(publicKey, transactionSigner) {\n    this._requireFrozen();\n\n    const publicKeyData = publicKey.toBytesRaw(); // note: this omits the DER prefix on purpose because Hedera doesn't\n    // support that in the protobuf. this means that we would fail\n    // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER\n    // prefixes here\n\n    const publicKeyHex = hex.encode(publicKeyData);\n\n    if (this._signerPublicKeys.has(publicKeyHex)) {\n      // this public key has already signed this transaction\n      return this;\n    }\n\n    this._transactions = [];\n\n    this._signerPublicKeys.add(publicKeyHex);\n\n    if (this._signOnDemand) {\n      this._publicKeys.push(publicKey);\n\n      this._transactionSigners.push(transactionSigner);\n\n      return this;\n    }\n\n    for (const signedTransaction of this._signedTransactions) {\n      const bodyBytes =\n      /** @type {Uint8Array} */\n      signedTransaction.bodyBytes;\n      const signature = await transactionSigner(bodyBytes);\n\n      if (signedTransaction.sigMap == null) {\n        signedTransaction.sigMap = {};\n      }\n\n      if (signedTransaction.sigMap.sigPair == null) {\n        signedTransaction.sigMap.sigPair = [];\n      }\n\n      signedTransaction.sigMap.sigPair.push(publicKey._toProtobufSignature(signature));\n    }\n\n    return this;\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<this>}\n   */\n\n\n  signWithOperator(client) {\n    const operator = client._operator;\n\n    if (operator == null) {\n      throw new Error(\"`client` must have an operator to sign with the operator\");\n    }\n\n    if (!this._isFrozen()) {\n      this.freezeWith(client);\n    }\n\n    return this.signWith(operator.publicKey, operator.transactionSigner);\n  }\n  /**\n   * @internal\n   * @protected\n   */\n\n\n  _requireOneNodeAccountId() {\n    if (this._nodeIds.length != 1) {\n      throw \"transaction did not have exactly one node ID set\";\n    }\n  }\n  /**\n   * @param {PublicKey} publicKey\n   * @param {Uint8Array} signature\n   * @returns {this}\n   */\n\n\n  addSignature(publicKey, signature) {\n    this._requireOneNodeAccountId();\n\n    if (!this.isFrozen()) {\n      this.freeze();\n    }\n\n    const publicKeyData = publicKey.toBytesRaw();\n    const publicKeyHex = hex.encode(publicKeyData);\n\n    if (this._signerPublicKeys.has(publicKeyHex)) {\n      // this public key has already signed this transaction\n      return this;\n    }\n\n    this._transactions = [];\n\n    for (const transaction of this._signedTransactions) {\n      if (transaction.sigMap == null) {\n        transaction.sigMap = {};\n      }\n\n      if (transaction.sigMap.sigPair == null) {\n        transaction.sigMap.sigPair = [];\n      }\n\n      transaction.sigMap.sigPair.push(publicKey._toProtobufSignature(signature));\n    }\n\n    this._signerPublicKeys.add(publicKeyHex);\n\n    this._publicKeys.push(publicKey);\n\n    this._transactionSigners.push(null);\n\n    return this;\n  }\n  /**\n   * @returns {SignatureMap}\n   */\n\n\n  getSignatures() {\n    if (this._signOnDemand) {\n      throw new Error(\"Please use `getSignaturesAsync()` if `signOnDemand` is enabled\");\n    }\n\n    this._buildAllTransactions();\n\n    return SignatureMap._fromTransaction(this);\n  }\n  /**\n   * @returns {Promise<SignatureMap>}\n   */\n\n\n  async getSignaturesAsync() {\n    await this._buildAllTransactionsAsync();\n    return SignatureMap._fromTransaction(this);\n  }\n  /**\n   * Freeze this transaction from future modification to prepare for\n   * signing or serialization.\n   *\n   * @returns {this}\n   */\n\n\n  freeze() {\n    return this.freezeWith(null);\n  }\n  /**\n   * Freeze this transaction from further modification to prepare for\n   * signing or serialization.\n   *\n   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n   * nodes to prepare this transaction for.\n   *\n   * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {this}\n   */\n\n\n  freezeWith(client) {\n    if (client != null) {\n      this._signOnDemand = client._signOnDemand;\n    }\n\n    if (client != null && this._maxTransactionFee == null) {\n      this._maxTransactionFee = client.maxTransactionFee;\n    }\n\n    if (client != null && this._transactionIds.length === 0) {\n      const operator = client._operator;\n\n      if (operator == null) {\n        throw new Error(\"`client` must have an `operator` or `transactionId` must be set\");\n      }\n\n      this.setTransactionId(TransactionId.generate(operator.accountId));\n    }\n\n    if (this._transactionIds.length === 0) {\n      throw new Error(\"`transactionId` must be set or `client` must be provided with `freezeWith`\");\n    }\n\n    if (client != null && this._transactionIds[0].accountId != null) {\n      this._transactionIds[0].accountId.validateChecksum(client);\n    }\n\n    if (this._nodeIds.length > 0) {// Do nothing\n    } else if (client != null) {\n      this._nodeIds = client._network.getNodeAccountIdsForExecute();\n    } else {\n      throw new Error(\"`nodeAccountId` must be set or `client` must be provided with `freezeWith`\");\n    }\n\n    this._signedTransactions = this._nodeIds.map(nodeId => this._makeSignedTransaction(nodeId));\n    return this;\n  }\n  /**\n   * Will error if sign-on-demand is enabled\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    this._requireFrozen();\n\n    if (this._signOnDemand) {\n      throw new Error(\"Please use `toBytesAsync()` if `signOnDemand` is enabled\");\n    }\n\n    this._buildAllTransactions();\n\n    return ProtoTransactionList.encode({\n      transactionList:\n      /** @type {proto.ITransaction[]} */\n      this._transactions\n    }).finish();\n  }\n  /**\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async toBytesAsync() {\n    this._requireFrozen();\n\n    await this._buildAllTransactionsAsync();\n    return ProtoTransactionList.encode({\n      transactionList:\n      /** @type {proto.ITransaction[]} */\n      this._transactions\n    }).finish();\n  }\n  /**\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async getTransactionHash() {\n    this._requireFrozen();\n\n    await this._buildAllTransactionsAsync();\n    return sha384.digest(\n    /** @type {Uint8Array} */\n\n    /** @type {proto.ITransaction} */\n    this._transactions[0].signedTransactionBytes);\n  }\n  /**\n   * @returns {Promise<TransactionHashMap>}\n   */\n\n\n  async getTransactionHashPerNode() {\n    this._requireFrozen();\n\n    await this._buildAllTransactionsAsync();\n    return await TransactionHashMap._fromTransaction(this);\n  }\n\n  isFrozen() {\n    return this._signedTransactions.length > 0;\n  }\n  /**\n   * @returns {TransactionId}\n   */\n\n\n  _getTransactionId() {\n    return this.transactionId;\n  }\n  /**\n   * @param {Client} client\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n\n\n  _validateChecksums(client) {// Do nothing\n  }\n  /**\n   * @override\n   * @protected\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<void>}\n   */\n\n\n  async _beforeExecute(client) {\n    if (!this._isFrozen()) {\n      this.freezeWith(client);\n    }\n\n    if (client.isAutoValidateChecksumsEnabled()) {\n      this._validateChecksums(client);\n    } // on execute, sign each transaction with the operator, if present\n    // and we are signing a transaction that used the default transaction ID\n\n\n    const transactionId = this.transactionId;\n    const operatorAccountId = client.operatorAccountId;\n\n    if (operatorAccountId != null && transactionId.accountId != null && operatorAccountId.equals(transactionId.accountId)) {\n      await this.signWithOperator(client);\n    }\n  }\n  /**\n   * @override\n   * @internal\n   * @returns {Promise<proto.ITransaction>}\n   */\n\n\n  async _makeRequestAsync() {\n    const index = this._nextTransactionIndex * this._nodeIds.length + this._nextNodeIndex;\n\n    if (this._signOnDemand) {\n      await this._buildTransactionAsync(index);\n    } else {\n      this._buildTransaction(index);\n    }\n\n    return (\n      /** @type {proto.ITransaction} */\n      this._transactions[index]\n    );\n  }\n  /**\n   * @param {number} index\n   * @internal\n   */\n\n\n  async _signTranscation(index) {\n    const signedTransaction = this._signedTransactions[index];\n    const bodyBytes =\n    /** @type {Uint8Array} */\n    signedTransaction.bodyBytes;\n\n    if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null && signedTransaction.sigMap.sigPair.length > 0) {\n      for (let i = 0; i < this._publicKeys.length; i++) {\n        const publicKey = this._publicKeys[i];\n        const signer = this._transactionSigners[i];\n\n        if (signedTransaction.sigMap.sigPair[0].pubKeyPrefix != null && signer != null && arrayEqual(signedTransaction.sigMap.sigPair[0].pubKeyPrefix, publicKey.toBytesRaw())) {\n          return;\n        }\n      }\n    }\n\n    for (let j = 0; j < this._publicKeys.length; j++) {\n      const publicKey = this._publicKeys[j];\n      const transactionSigner = this._transactionSigners[j];\n\n      if (transactionSigner == null) {\n        continue;\n      }\n\n      const signature = await transactionSigner(bodyBytes);\n\n      if (signedTransaction.sigMap == null) {\n        signedTransaction.sigMap = {};\n      }\n\n      if (signedTransaction.sigMap.sigPair == null) {\n        signedTransaction.sigMap.sigPair = [];\n      }\n\n      signedTransaction.sigMap.sigPair.push(publicKey._toProtobufSignature(signature));\n    }\n  }\n\n  _buildAllTransactions() {\n    for (let i = 0; i < this._signedTransactions.length; i++) {\n      this._buildTransaction(i);\n    }\n  }\n\n  async _buildAllTransactionsAsync() {\n    for (let i = 0; i < this._signedTransactions.length; i++) {\n      await this._buildTransactionAsync(i);\n    }\n  }\n  /**\n   * @param {number} index\n   * @internal\n   */\n\n\n  _buildTransaction(index) {\n    if (this._transactions.length < index) {\n      for (let i = this._transactions.length; i < index; i++) {\n        this._transactions.push(null);\n      }\n    } // console.log(JSON.stringify(this._signedTransactions[index]));\n\n\n    this._transactions[index] = {\n      signedTransactionBytes: ProtoSignedTransaction.encode(this._signedTransactions[index]).finish()\n    };\n  }\n  /**\n   * @param {number} index\n   * @internal\n   */\n\n\n  async _buildTransactionAsync(index) {\n    if (this._transactions.length < index) {\n      for (let i = this._transactions.length; i < index; i++) {\n        this._transactions.push(null);\n      }\n    } else if (this._transactions.length > index && this._transactions[index] != null &&\n    /** @type {proto.ITransaction} */\n    this._transactions[index].signedTransactionBytes != null) {\n      return;\n    }\n\n    await this._signTranscation(index);\n\n    this._transactions.push({\n      signedTransactionBytes: ProtoSignedTransaction.encode(this._signedTransactions[index]).finish()\n    });\n  }\n  /**\n   * @override\n   * @internal\n   * @param {proto.ITransaction} request\n   * @param {proto.ITransactionResponse} response\n   * @returns {ExecutionState}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _shouldRetry(request, response) {\n    const {\n      nodeTransactionPrecheckCode\n    } = response;\n\n    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : ResponseCodeEnum.OK);\n\n    switch (status) {\n      case Status.Busy:\n      case Status.Unknown:\n      case Status.PlatformTransactionNotCreated:\n        return ExecutionState.Retry;\n\n      case Status.Ok:\n        return ExecutionState.Finished;\n\n      default:\n        return ExecutionState.Error;\n    }\n  }\n  /**\n   * @override\n   * @internal\n   * @param {proto.ITransaction} request\n   * @param {proto.ITransactionResponse} response\n   * @returns {Error}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapStatusError(request, response) {\n    const {\n      nodeTransactionPrecheckCode\n    } = response;\n\n    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : ResponseCodeEnum.OK);\n\n    return new PrecheckStatusError({\n      status,\n      transactionId: this._getTransactionId()\n    });\n  }\n  /**\n   * @override\n   * @protected\n   * @param {proto.ITransactionResponse} response\n   * @param {AccountId} nodeId\n   * @param {proto.ITransaction} request\n   * @returns {Promise<TransactionResponse>}\n   */\n\n\n  async _mapResponse(response, nodeId, request) {\n    const transactionHash = await sha384.digest(\n    /** @type {Uint8Array} */\n    request.signedTransactionBytes);\n    const transactionId = this.transactionId;\n    this._nextTransactionIndex = (this._nextTransactionIndex + 1) % this._transactionIds.length;\n    return new TransactionResponse({\n      nodeId,\n      transactionHash,\n      transactionId\n    });\n  }\n  /**\n   * @override\n   * @returns {AccountId}\n   */\n\n\n  _getNodeAccountId() {\n    if (this._nodeIds.length === 0) {\n      throw new Error(\"(BUG) Transaction::_getNodeAccountId called before transaction has been frozen\");\n    }\n\n    return this._nodeIds[this._nextNodeIndex % this._nodeIds.length];\n  }\n  /**\n   * @internal\n   * @param {?AccountId} nodeId\n   * @returns {proto.ISignedTransaction}\n   */\n\n\n  _makeSignedTransaction(nodeId) {\n    const body = this._makeTransactionBody(nodeId);\n\n    const bodyBytes = ProtoTransactionBody.encode(body).finish();\n    return {\n      bodyBytes,\n      sigMap: {\n        sigPair: []\n      }\n    };\n  }\n  /**\n   * @private\n   * @param {?AccountId} nodeId\n   * @returns {proto.ITransactionBody}\n   */\n\n\n  _makeTransactionBody(nodeId) {\n    return {\n      [this._getTransactionDataCase()]: this._makeTransactionData(),\n      transactionFee: this._maxTransactionFee != null ? this._maxTransactionFee.toTinybars() : null,\n      memo: this._transactionMemo,\n      transactionID: this._transactionIds[this._nextTransactionIndex] != null ? this._transactionIds[this._nextTransactionIndex]._toProtobuf() : null,\n      nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,\n      transactionValidDuration: {\n        seconds: Long.fromNumber(this._transactionValidDuration)\n      }\n    };\n  }\n  /**\n   * @abstract\n   * @protected\n   * @returns {NonNullable<proto.TransactionBody[\"data\"]>}\n   */\n\n\n  _getTransactionDataCase() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @internal\n   * @returns {proto.ISchedulableTransactionBody}\n   */\n\n\n  _getScheduledTransactionBody() {\n    return {\n      memo: this.transactionMemo,\n      transactionFee: this.maxTransactionFee != null ? this.maxTransactionFee.toTinybars() : null,\n      [this._getTransactionDataCase()]: this._makeTransactionData()\n    };\n  }\n  /**\n   * @abstract\n   * @protected\n   * @returns {object}\n   */\n\n\n  _makeTransactionData() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @protected\n   * @returns {boolean}\n   */\n\n\n  _isFrozen() {\n    return this._signedTransactions.length > 0;\n  }\n  /**\n   * @internal\n   */\n\n\n  _requireNotFrozen() {\n    if (this._isFrozen()) {\n      throw new Error(\"transaction is immutable; it has at least one signature or has been explicitly frozen\");\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  _requireFrozen() {\n    if (!this._isFrozen()) {\n      throw new Error(\"transaction must have been frozen before calculating the hash will be stable, try calling `freeze`\");\n    }\n  }\n\n}\n/**\n * @type {(() => ScheduleCreateTransaction)[]}\n */\n\nexport const SCHEDULE_CREATE_TRANSACTION = [];","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/transaction/Transaction.js"],"names":["Hbar","TransactionResponse","TransactionId","TransactionHashMap","SignatureMap","Executable","ExecutionState","Status","Long","sha384","hex","Transaction","ProtoTransaction","SignedTransaction","ProtoSignedTransaction","TransactionList","ProtoTransactionList","TransactionBody","ProtoTransactionBody","ResponseCodeEnum","PrecheckStatusError","AccountId","arrayEqual","PublicKey","DEFAULT_AUTO_RENEW_PERIOD","fromValue","DEFAULT_RECORD_THRESHOLD","fromTinybars","fromString","DEFAULT_TRANSACTION_VALID_DURATION","CHUNK_SIZE","TRANSACTION_REGISTRY","Map","constructor","_transactions","_signedTransactions","_signerPublicKeys","Set","_nextTransactionIndex","_transactionValidDuration","_maxTransactionFee","_transactionMemo","_transactionIds","_signOnDemand","_publicKeys","_transactionSigners","fromBytes","bytes","signedTransactions","transactionIds","nodeIds","transactionIdStrings","nodeIdStrings","bodies","list","decode","transactionList","length","transaction","signedTransactionBytes","push","encode","bodyBytes","sigMap","finish","Error","signedTransaction","body","data","transactionID","transactionId","_fromProtobuf","includes","toString","nodeAccountID","nodeAccountId","fromProtobuf","get","schedule","_requireNotFrozen","SCHEDULE_CREATE_TRANSACTION","_setScheduledTransaction","_fromProtobufTransactions","transactions","zero","i","equals","splice","_nodeIds","_nextNodeIndex","transactionValidDuration","seconds","toInt","transactionFee","memo","sigPair","add","pubKeyPrefix","setNodeAccountIds","setTransactionValidDuration","validDuration","maxTransactionFee","setMaxTransactionFee","transactionMemo","setTransactionMemo","setTransactionId","sign","privateKey","signWith","publicKey","message","Promise","resolve","transactionSigner","_requireFrozen","publicKeyData","toBytesRaw","publicKeyHex","has","signature","_toProtobufSignature","signWithOperator","client","operator","_operator","_isFrozen","freezeWith","_requireOneNodeAccountId","addSignature","isFrozen","freeze","getSignatures","_buildAllTransactions","_fromTransaction","getSignaturesAsync","_buildAllTransactionsAsync","generate","accountId","validateChecksum","_network","getNodeAccountIdsForExecute","map","nodeId","_makeSignedTransaction","toBytes","toBytesAsync","getTransactionHash","digest","getTransactionHashPerNode","_getTransactionId","_validateChecksums","_beforeExecute","isAutoValidateChecksumsEnabled","operatorAccountId","_makeRequestAsync","index","_buildTransactionAsync","_buildTransaction","_signTranscation","signer","j","_shouldRetry","request","response","nodeTransactionPrecheckCode","status","_fromCode","OK","Busy","Unknown","PlatformTransactionNotCreated","Retry","Ok","Finished","_mapStatusError","_mapResponse","transactionHash","_getNodeAccountId","_makeTransactionBody","_getTransactionDataCase","_makeTransactionData","toTinybars","_toProtobuf","fromNumber","_getScheduledTransactionBody"],"mappings":"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","sourcesContent":["import Hbar from \"../Hbar.js\";\nimport TransactionResponse from \"./TransactionResponse.js\";\nimport TransactionId from \"./TransactionId.js\";\nimport TransactionHashMap from \"./TransactionHashMap.js\";\nimport SignatureMap from \"./SignatureMap.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport Status from \"../Status.js\";\nimport Long from \"long\";\nimport * as sha384 from \"../cryptography/sha384.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport {\n    Transaction as ProtoTransaction,\n    SignedTransaction as ProtoSignedTransaction,\n    TransactionList as ProtoTransactionList,\n    TransactionBody as ProtoTransactionBody,\n    ResponseCodeEnum,\n} from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport { arrayEqual } from \"../array.js\";\nimport PublicKey from \"../PublicKey.js\";\n\n/**\n * @typedef {import(\"bignumber.js\").default} BigNumber\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignaturePair} proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").ITransactionList} proto.ITransactionList\n * @typedef {import(\"@hashgraph/proto\").ITransactionID} proto.ITransactionID\n * @typedef {import(\"@hashgraph/proto\").IAccountID} proto.IAccountID\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionResponse} proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").ResponseCodeEnum} proto.ResponseCodeEnum\n * @typedef {import(\"@hashgraph/proto\").TransactionBody} proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").ISchedulableTransactionBody} proto.ISchedulableTransactionBody\n */\n\n/**\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n * @typedef {import(\"../PrivateKey.js\").default} PrivateKey\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\n// 90 days (in seconds)\nexport const DEFAULT_AUTO_RENEW_PERIOD = Long.fromValue(7776000);\n\n// maximum value of i64 (so there is never a record generated)\nexport const DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(\n    Long.fromString(\"9223372036854775807\")\n);\n\n// 120 seconds\nconst DEFAULT_TRANSACTION_VALID_DURATION = 120;\n\nexport const CHUNK_SIZE = 1024;\n\n/**\n * @type {Map<NonNullable<proto.TransactionBody[\"data\"]>, (transactions: proto.ITransaction[], signedTransactions: proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: proto.TransactionBody[]) => Transaction>}\n */\nexport const TRANSACTION_REGISTRY = new Map();\n\n/**\n * Base class for all transactions that may be submitted to Hedera.\n *\n * @abstract\n * @augments {Executable<proto.ITransaction, proto.ITransactionResponse, TransactionResponse>}\n */\nexport default class Transaction extends Executable {\n    // A SDK transaction is composed of multiple, raw protobuf transactions.\n    // These should be functionally identicasl, with the exception of pointing to\n    // different nodes.\n\n    // When retrying a transaction after a network error or retry-able\n    // status response, we try a different transaction and thus a different node.\n\n    constructor() {\n        super();\n\n        /**\n         * List of proto transactions that have been built from this SDK\n         * transaction. Each one should share the same transaction ID.\n         *\n         * @internal\n         * @type {(proto.ITransaction | null)[]}\n         */\n        this._transactions = [];\n\n        /**\n         * List of proto transactions that have been built from this SDK\n         * transaction. Each one should share the same transaction ID.\n         *\n         * @internal\n         * @type {proto.ISignedTransaction[]}\n         */\n        this._signedTransactions = [];\n\n        /**\n         * Set of public keys (as string) who have signed this transaction so\n         * we do not allow them to sign it again.\n         *\n         * @internal\n         * @type {Set<string>}\n         */\n        this._signerPublicKeys = new Set();\n\n        /**\n         * @protected\n         * @type {number}\n         */\n        this._nextTransactionIndex = 0;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;\n\n        /**\n         * @private\n         * @type {Hbar}\n         */\n        this._maxTransactionFee = new Hbar(2);\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._transactionMemo = \"\";\n\n        /**\n         * @protected\n         * @type {TransactionId[]}\n         */\n        this._transactionIds = [];\n\n        this._signOnDemand = false;\n\n        /**\n         * @private\n         * @type {PublicKey[]}\n         */\n        this._publicKeys = [];\n\n        /**\n         * @private\n         * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}\n         */\n        this._transactionSigners = [];\n    }\n\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {Transaction}\n     */\n    static fromBytes(bytes) {\n        const signedTransactions = [];\n        const transactionIds = [];\n        const nodeIds = [];\n\n        /** @type {string[]} */\n        const transactionIdStrings = [];\n\n        /** @type {string[]} */\n        const nodeIdStrings = [];\n\n        const bodies = [];\n\n        const list = ProtoTransactionList.decode(bytes).transactionList;\n\n        if (list.length == 0) {\n            const transaction = ProtoTransaction.decode(bytes);\n\n            if (transaction.signedTransactionBytes.length != 0) {\n                list.push(transaction);\n            } else {\n                list.push({\n                    signedTransactionBytes: ProtoSignedTransaction.encode({\n                        bodyBytes: transaction.bodyBytes,\n                        sigMap: transaction.sigMap,\n                    }).finish(),\n                });\n            }\n        }\n\n        for (const transaction of list) {\n            if (transaction.signedTransactionBytes == null) {\n                throw new Error(\"Transaction.signedTransactionBytes are null\");\n            }\n\n            const signedTransaction = ProtoSignedTransaction.decode(\n                transaction.signedTransactionBytes\n            );\n            signedTransactions.push(signedTransaction);\n\n            const body = ProtoTransactionBody.decode(\n                signedTransaction.bodyBytes\n            );\n\n            if (body.data == null) {\n                throw new Error(\"(BUG) body.data was not set in the protobuf\");\n            }\n\n            bodies.push(body);\n\n            if (body.transactionID != null) {\n                const transactionId = TransactionId._fromProtobuf(\n                    /** @type {proto.ITransactionID} */ (body.transactionID)\n                );\n\n                if (!transactionIdStrings.includes(transactionId.toString())) {\n                    transactionIds.push(transactionId);\n                    transactionIdStrings.push(transactionId.toString());\n                }\n            }\n\n            if (body.nodeAccountID != null) {\n                const nodeAccountId = AccountId._fromProtobuf(\n                    /** @type {proto.IAccountID} */ (body.nodeAccountID)\n                );\n\n                if (!nodeIdStrings.includes(nodeAccountId.toString())) {\n                    nodeIds.push(nodeAccountId);\n                    nodeIdStrings.push(nodeAccountId.toString());\n                }\n            }\n        }\n\n        const body = bodies[0];\n\n        if (body == null || body.data == null) {\n            throw new Error(\n                \"No transaction found in bytes or failed to decode TransactionBody\"\n            );\n        }\n\n        const fromProtobuf = TRANSACTION_REGISTRY.get(body.data);\n\n        if (fromProtobuf == null) {\n            throw new Error(\n                `(BUG) Transaction.fromBytes() not implemented for type ${body.data}`\n            );\n        }\n\n        return fromProtobuf(\n            list,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies\n        );\n    }\n\n    /**\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (SCHEDULE_CREATE_TRANSACTION.length != 1) {\n            throw new Error(\n                \"ScheduleCreateTransaction has not been loaded yet\"\n            );\n        }\n\n        return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);\n    }\n\n    /**\n     * @template {Transaction} TransactionT\n     * @param {TransactionT} transaction\n     * @param {proto.ITransaction[]} transactions\n     * @param {proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {proto.ITransactionBody[]} bodies\n     * @returns {TransactionT}\n     */\n    static _fromProtobufTransactions(\n        transaction,\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies\n    ) {\n        const body = bodies[0];\n\n        const zero = new AccountId(0);\n        for (let i = 0; i < nodeIds.length; i++) {\n            if (nodeIds[i].equals(zero)) {\n                nodeIds.splice(i--, 1);\n            }\n        }\n\n        transaction._transactions = transactions;\n        transaction._signedTransactions = signedTransactions;\n        transaction._transactionIds = transactionIds;\n        transaction._nodeIds = nodeIds;\n        transaction._nextNodeIndex = 0;\n        transaction._nextTransactionIndex = 0;\n        transaction._transactionValidDuration =\n            body.transactionValidDuration != null &&\n            body.transactionValidDuration.seconds != null\n                ? Long.fromValue(body.transactionValidDuration.seconds).toInt()\n                : DEFAULT_TRANSACTION_VALID_DURATION;\n        transaction._maxTransactionFee =\n            body.transactionFee != null\n                ? Hbar.fromTinybars(body.transactionFee)\n                : new Hbar(0);\n        transaction._transactionMemo = body.memo != null ? body.memo : \"\";\n\n        for (let i = 0; i < nodeIds.length; i++) {\n            const signedTransaction = signedTransactions[i];\n            if (\n                signedTransaction.sigMap != null &&\n                signedTransaction.sigMap.sigPair != null\n            ) {\n                for (const sigPair of signedTransaction.sigMap.sigPair) {\n                    transaction._signerPublicKeys.add(\n                        hex.encode(\n                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix)\n                        )\n                    );\n\n                    transaction._publicKeys.push(\n                        PublicKey.fromBytes(\n                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix)\n                        )\n                    );\n                    transaction._transactionSigners.push(null);\n                }\n            }\n        }\n\n        return transaction;\n    }\n\n    /**\n     * @override\n     * @param {AccountId[]} nodeIds\n     * @returns {this}\n     */\n    setNodeAccountIds(nodeIds) {\n        this._requireNotFrozen();\n        super.setNodeAccountIds(nodeIds);\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get transactionValidDuration() {\n        return this._transactionValidDuration;\n    }\n\n    /**\n     * Sets the duration (in seconds) that this transaction is valid for.\n     *\n     * This is defaulted to 120 seconds (from the time its executed).\n     *\n     * @param {number} validDuration\n     * @returns {this}\n     */\n    setTransactionValidDuration(validDuration) {\n        this._requireNotFrozen();\n        this._transactionValidDuration = validDuration;\n\n        return this;\n    }\n\n    /**\n     * @returns {?Hbar}\n     */\n    get maxTransactionFee() {\n        return this._maxTransactionFee;\n    }\n\n    /**\n     * Set the maximum transaction fee the operator (paying account)\n     * is willing to pay.\n     *\n     * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee\n     * @returns {this}\n     */\n    setMaxTransactionFee(maxTransactionFee) {\n        this._requireNotFrozen();\n        this._maxTransactionFee =\n            maxTransactionFee instanceof Hbar\n                ? maxTransactionFee\n                : new Hbar(maxTransactionFee);\n\n        return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n    get transactionMemo() {\n        return this._transactionMemo;\n    }\n\n    /**\n     * Set a note or description to be recorded in the transaction\n     * record (maximum length of 100 bytes).\n     *\n     * @param {string} transactionMemo\n     * @returns {this}\n     */\n    setTransactionMemo(transactionMemo) {\n        this._requireNotFrozen();\n        this._transactionMemo = transactionMemo;\n\n        return this;\n    }\n\n    /**\n     * @returns {TransactionId}\n     */\n    get transactionId() {\n        if (this._transactionIds.length === 0) {\n            throw new Error(\n                \"transaction must have been frozen before getting the transaction ID, try calling `freeze`\"\n            );\n        }\n\n        return this._transactionIds[this._nextTransactionIndex];\n    }\n\n    /**\n     * Set the ID for this transaction.\n     *\n     * The transaction ID includes the operator's account ( the account paying the transaction\n     * fee). If two transactions have the same transaction ID, they won't both have an effect. One\n     * will complete normally and the other will fail with a duplicate transaction status.\n     *\n     * Normally, you should not use this method. Just before a transaction is executed, a\n     * transaction ID will be generated from the operator on the client.\n     *\n     * @param {TransactionId} transactionId\n     * @returns {this}\n     */\n    setTransactionId(transactionId) {\n        this._requireNotFrozen();\n        this._transactionIds = [transactionId];\n\n        return this;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @returns {Promise<this>}\n     */\n    sign(privateKey) {\n        return this.signWith(privateKey.publicKey, (message) =>\n            Promise.resolve(privateKey.sign(message))\n        );\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n     * @returns {Promise<this>}\n     */\n    async signWith(publicKey, transactionSigner) {\n        this._requireFrozen();\n\n        const publicKeyData = publicKey.toBytesRaw();\n\n        // note: this omits the DER prefix on purpose because Hedera doesn't\n        // support that in the protobuf. this means that we would fail\n        // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER\n        // prefixes here\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        this._transactions = [];\n        this._signerPublicKeys.add(publicKeyHex);\n\n        if (this._signOnDemand) {\n            this._publicKeys.push(publicKey);\n            this._transactionSigners.push(transactionSigner);\n\n            return this;\n        }\n\n        for (const signedTransaction of this._signedTransactions) {\n            const bodyBytes = /** @type {Uint8Array} */ (\n                signedTransaction.bodyBytes\n            );\n            const signature = await transactionSigner(bodyBytes);\n\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            signedTransaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature)\n            );\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<this>}\n     */\n    signWithOperator(client) {\n        const operator = client._operator;\n\n        if (operator == null) {\n            throw new Error(\n                \"`client` must have an operator to sign with the operator\"\n            );\n        }\n\n        if (!this._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        return this.signWith(operator.publicKey, operator.transactionSigner);\n    }\n    /**\n     * @internal\n     * @protected\n     */\n    _requireOneNodeAccountId() {\n        if (this._nodeIds.length != 1) {\n            throw \"transaction did not have exactly one node ID set\";\n        }\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} signature\n     * @returns {this}\n     */\n    addSignature(publicKey, signature) {\n        this._requireOneNodeAccountId();\n\n        if (!this.isFrozen()) {\n            this.freeze();\n        }\n\n        const publicKeyData = publicKey.toBytesRaw();\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        this._transactions = [];\n\n        for (const transaction of this._signedTransactions) {\n            if (transaction.sigMap == null) {\n                transaction.sigMap = {};\n            }\n\n            if (transaction.sigMap.sigPair == null) {\n                transaction.sigMap.sigPair = [];\n            }\n\n            transaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature)\n            );\n        }\n\n        this._signerPublicKeys.add(publicKeyHex);\n        this._publicKeys.push(publicKey);\n        this._transactionSigners.push(null);\n\n        return this;\n    }\n\n    /**\n     * @returns {SignatureMap}\n     */\n    getSignatures() {\n        if (this._signOnDemand) {\n            throw new Error(\n                \"Please use `getSignaturesAsync()` if `signOnDemand` is enabled\"\n            );\n        }\n\n        this._buildAllTransactions();\n\n        return SignatureMap._fromTransaction(this);\n    }\n\n    /**\n     * @returns {Promise<SignatureMap>}\n     */\n    async getSignaturesAsync() {\n        await this._buildAllTransactionsAsync();\n\n        return SignatureMap._fromTransaction(this);\n    }\n\n    /**\n     * Freeze this transaction from future modification to prepare for\n     * signing or serialization.\n     *\n     * @returns {this}\n     */\n    freeze() {\n        return this.freezeWith(null);\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        if (client != null) {\n            this._signOnDemand = client._signOnDemand;\n        }\n\n        if (client != null && this._maxTransactionFee == null) {\n            this._maxTransactionFee = client.maxTransactionFee;\n        }\n\n        if (client != null && this._transactionIds.length === 0) {\n            const operator = client._operator;\n\n            if (operator == null) {\n                throw new Error(\n                    \"`client` must have an `operator` or `transactionId` must be set\"\n                );\n            }\n\n            this.setTransactionId(TransactionId.generate(operator.accountId));\n        }\n\n        if (this._transactionIds.length === 0) {\n            throw new Error(\n                \"`transactionId` must be set or `client` must be provided with `freezeWith`\"\n            );\n        }\n\n        if (client != null && this._transactionIds[0].accountId != null) {\n            this._transactionIds[0].accountId.validateChecksum(client);\n        }\n\n        if (this._nodeIds.length > 0) {\n            // Do nothing\n        } else if (client != null) {\n            this._nodeIds = client._network.getNodeAccountIdsForExecute();\n        } else {\n            throw new Error(\n                \"`nodeAccountId` must be set or `client` must be provided with `freezeWith`\"\n            );\n        }\n\n        this._signedTransactions = this._nodeIds.map((nodeId) =>\n            this._makeSignedTransaction(nodeId)\n        );\n\n        return this;\n    }\n\n    /**\n     * Will error if sign-on-demand is enabled\n     *\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        this._requireFrozen();\n\n        if (this._signOnDemand) {\n            throw new Error(\n                \"Please use `toBytesAsync()` if `signOnDemand` is enabled\"\n            );\n        }\n\n        this._buildAllTransactions();\n\n        return ProtoTransactionList.encode({\n            transactionList: /** @type {proto.ITransaction[]} */ (\n                this._transactions\n            ),\n        }).finish();\n    }\n\n    /**\n     * @returns {Promise<Uint8Array>}\n     */\n    async toBytesAsync() {\n        this._requireFrozen();\n\n        await this._buildAllTransactionsAsync();\n\n        return ProtoTransactionList.encode({\n            transactionList: /** @type {proto.ITransaction[]} */ (\n                this._transactions\n            ),\n        }).finish();\n    }\n\n    /**\n     * @returns {Promise<Uint8Array>}\n     */\n    async getTransactionHash() {\n        this._requireFrozen();\n\n        await this._buildAllTransactionsAsync();\n\n        return sha384.digest(\n            /** @type {Uint8Array} */ (\n                /** @type {proto.ITransaction} */ (this._transactions[0])\n                    .signedTransactionBytes\n            )\n        );\n    }\n\n    /**\n     * @returns {Promise<TransactionHashMap>}\n     */\n    async getTransactionHashPerNode() {\n        this._requireFrozen();\n        await this._buildAllTransactionsAsync();\n        return await TransactionHashMap._fromTransaction(this);\n    }\n\n    isFrozen() {\n        return this._signedTransactions.length > 0;\n    }\n\n    /**\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        return this.transactionId;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n    _validateChecksums(client) {\n        // Do nothing\n    }\n\n    /**\n     * @override\n     * @protected\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<void>}\n     */\n    async _beforeExecute(client) {\n        if (!this._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        if (client.isAutoValidateChecksumsEnabled()) {\n            this._validateChecksums(client);\n        }\n\n        // on execute, sign each transaction with the operator, if present\n        // and we are signing a transaction that used the default transaction ID\n\n        const transactionId = this.transactionId;\n        const operatorAccountId = client.operatorAccountId;\n\n        if (\n            operatorAccountId != null &&\n            transactionId.accountId != null &&\n            operatorAccountId.equals(transactionId.accountId)\n        ) {\n            await this.signWithOperator(client);\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @returns {Promise<proto.ITransaction>}\n     */\n    async _makeRequestAsync() {\n        const index =\n            this._nextTransactionIndex * this._nodeIds.length +\n            this._nextNodeIndex;\n\n        if (this._signOnDemand) {\n            await this._buildTransactionAsync(index);\n        } else {\n            this._buildTransaction(index);\n        }\n\n        return /** @type {proto.ITransaction} */ (this._transactions[index]);\n    }\n\n    /**\n     * @param {number} index\n     * @internal\n     */\n    async _signTranscation(index) {\n        const signedTransaction = this._signedTransactions[index];\n\n        const bodyBytes = /** @type {Uint8Array} */ (\n            signedTransaction.bodyBytes\n        );\n\n        if (\n            signedTransaction.sigMap != null &&\n            signedTransaction.sigMap.sigPair != null &&\n            signedTransaction.sigMap.sigPair.length > 0\n        ) {\n            for (let i = 0; i < this._publicKeys.length; i++) {\n                const publicKey = this._publicKeys[i];\n                const signer = this._transactionSigners[i];\n\n                if (\n                    signedTransaction.sigMap.sigPair[0].pubKeyPrefix != null &&\n                    signer != null &&\n                    arrayEqual(\n                        signedTransaction.sigMap.sigPair[0].pubKeyPrefix,\n                        publicKey.toBytesRaw()\n                    )\n                ) {\n                    return;\n                }\n            }\n        }\n\n        for (let j = 0; j < this._publicKeys.length; j++) {\n            const publicKey = this._publicKeys[j];\n            const transactionSigner = this._transactionSigners[j];\n\n            if (transactionSigner == null) {\n                continue;\n            }\n\n            const signature = await transactionSigner(bodyBytes);\n\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            signedTransaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature)\n            );\n        }\n    }\n\n    _buildAllTransactions() {\n        for (let i = 0; i < this._signedTransactions.length; i++) {\n            this._buildTransaction(i);\n        }\n    }\n\n    async _buildAllTransactionsAsync() {\n        for (let i = 0; i < this._signedTransactions.length; i++) {\n            await this._buildTransactionAsync(i);\n        }\n    }\n\n    /**\n     * @param {number} index\n     * @internal\n     */\n    _buildTransaction(index) {\n        if (this._transactions.length < index) {\n            for (let i = this._transactions.length; i < index; i++) {\n                this._transactions.push(null);\n            }\n        }\n\n        // console.log(JSON.stringify(this._signedTransactions[index]));\n\n        this._transactions[index] = {\n            signedTransactionBytes: ProtoSignedTransaction.encode(\n                this._signedTransactions[index]\n            ).finish(),\n        };\n    }\n\n    /**\n     * @param {number} index\n     * @internal\n     */\n    async _buildTransactionAsync(index) {\n        if (this._transactions.length < index) {\n            for (let i = this._transactions.length; i < index; i++) {\n                this._transactions.push(null);\n            }\n        } else if (\n            this._transactions.length > index &&\n            this._transactions[index] != null &&\n            /** @type {proto.ITransaction} */ (this._transactions[index])\n                .signedTransactionBytes != null\n        ) {\n            return;\n        }\n\n        await this._signTranscation(index);\n\n        this._transactions.push({\n            signedTransactionBytes: ProtoSignedTransaction.encode(\n                this._signedTransactions[index]\n            ).finish(),\n        });\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {proto.ITransaction} request\n     * @param {proto.ITransactionResponse} response\n     * @returns {ExecutionState}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        const { nodeTransactionPrecheckCode } = response;\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : ResponseCodeEnum.OK\n        );\n\n        switch (status) {\n            case Status.Busy:\n            case Status.Unknown:\n            case Status.PlatformTransactionNotCreated:\n                return ExecutionState.Retry;\n            case Status.Ok:\n                return ExecutionState.Finished;\n            default:\n                return ExecutionState.Error;\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {proto.ITransaction} request\n     * @param {proto.ITransactionResponse} response\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response) {\n        const { nodeTransactionPrecheckCode } = response;\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : ResponseCodeEnum.OK\n        );\n\n        return new PrecheckStatusError({\n            status,\n            transactionId: this._getTransactionId(),\n        });\n    }\n\n    /**\n     * @override\n     * @protected\n     * @param {proto.ITransactionResponse} response\n     * @param {AccountId} nodeId\n     * @param {proto.ITransaction} request\n     * @returns {Promise<TransactionResponse>}\n     */\n    async _mapResponse(response, nodeId, request) {\n        const transactionHash = await sha384.digest(\n            /** @type {Uint8Array} */ (request.signedTransactionBytes)\n        );\n        const transactionId = this.transactionId;\n\n        this._nextTransactionIndex =\n            (this._nextTransactionIndex + 1) % this._transactionIds.length;\n\n        return new TransactionResponse({\n            nodeId,\n            transactionHash,\n            transactionId,\n        });\n    }\n\n    /**\n     * @override\n     * @returns {AccountId}\n     */\n    _getNodeAccountId() {\n        if (this._nodeIds.length === 0) {\n            throw new Error(\n                \"(BUG) Transaction::_getNodeAccountId called before transaction has been frozen\"\n            );\n        }\n\n        return this._nodeIds[this._nextNodeIndex % this._nodeIds.length];\n    }\n\n    /**\n     * @internal\n     * @param {?AccountId} nodeId\n     * @returns {proto.ISignedTransaction}\n     */\n    _makeSignedTransaction(nodeId) {\n        const body = this._makeTransactionBody(nodeId);\n        const bodyBytes = ProtoTransactionBody.encode(body).finish();\n\n        return {\n            bodyBytes,\n            sigMap: {\n                sigPair: [],\n            },\n        };\n    }\n\n    /**\n     * @private\n     * @param {?AccountId} nodeId\n     * @returns {proto.ITransactionBody}\n     */\n    _makeTransactionBody(nodeId) {\n        return {\n            [this._getTransactionDataCase()]: this._makeTransactionData(),\n            transactionFee:\n                this._maxTransactionFee != null\n                    ? this._maxTransactionFee.toTinybars()\n                    : null,\n            memo: this._transactionMemo,\n            transactionID:\n                this._transactionIds[this._nextTransactionIndex] != null\n                    ? this._transactionIds[\n                          this._nextTransactionIndex\n                      ]._toProtobuf()\n                    : null,\n            nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,\n            transactionValidDuration: {\n                seconds: Long.fromNumber(this._transactionValidDuration),\n            },\n        };\n    }\n\n    /**\n     * @abstract\n     * @protected\n     * @returns {NonNullable<proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @internal\n     * @returns {proto.ISchedulableTransactionBody}\n     */\n    _getScheduledTransactionBody() {\n        return {\n            memo: this.transactionMemo,\n            transactionFee:\n                this.maxTransactionFee != null\n                    ? this.maxTransactionFee.toTinybars()\n                    : null,\n            [this._getTransactionDataCase()]: this._makeTransactionData(),\n        };\n    }\n\n    /**\n     * @abstract\n     * @protected\n     * @returns {object}\n     */\n    _makeTransactionData() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @protected\n     * @returns {boolean}\n     */\n    _isFrozen() {\n        return this._signedTransactions.length > 0;\n    }\n\n    /**\n     * @internal\n     */\n    _requireNotFrozen() {\n        if (this._isFrozen()) {\n            throw new Error(\n                \"transaction is immutable; it has at least one signature or has been explicitly frozen\"\n            );\n        }\n    }\n\n    /**\n     * @internal\n     */\n    _requireFrozen() {\n        if (!this._isFrozen()) {\n            throw new Error(\n                \"transaction must have been frozen before calculating the hash will be stable, try calling `freeze`\"\n            );\n        }\n    }\n}\n\n/**\n * @type {(() => ScheduleCreateTransaction)[]}\n */\nexport const SCHEDULE_CREATE_TRANSACTION = [];\n"]},"metadata":{},"sourceType":"module"}