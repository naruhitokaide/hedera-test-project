{"ast":null,"code":"import Transaction, { TRANSACTION_REGISTRY, CHUNK_SIZE } from \"../transaction/Transaction.js\";\nimport TopicId from \"./TopicId.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as util from \"../util.js\";\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IConsensusSubmitMessageTransactionBody} proto.IConsensusSubmitMessageTransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").TransactionBody} proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionResponse} proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").IConsensusMessageChunkInfo} proto.IConsensusMessageChunkInfo\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n */\n\nexport default class TopicMessageSubmitTransaction extends Transaction {\n  /**\n   * @param {object} props\n   * @param {TopicId | string} [props.topicId]\n   * @param {Uint8Array | string} [props.message]\n   * @param {number} [props.maxChunks]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    /**\n     * @private\n     * @type {?TopicId}\n     */\n\n    this._topicId = null;\n\n    if (props.topicId != null) {\n      this.setTopicId(props.topicId);\n    }\n    /**\n     * @private\n     * @type {?Uint8Array}\n     */\n\n\n    this._message = null;\n\n    if (props.message != null) {\n      this.setMessage(props.message);\n    }\n    /**\n     * @private\n     * @type {number}\n     */\n\n\n    this._maxChunks = 20;\n\n    if (props.maxChunks != null) {\n      this.setMaxChunks(props.maxChunks);\n    }\n    /** @type {proto.IConsensusMessageChunkInfo | null} */\n\n\n    this._chunkInfo = null;\n  }\n  /**\n   * @internal\n   * @param {proto.ITransaction[]} transactions\n   * @param {proto.ISignedTransaction[]} signedTransactions\n   * @param {TransactionId[]} transactionIds\n   * @param {AccountId[]} nodeIds\n   * @param {proto.ITransactionBody[]} bodies\n   * @returns {TopicMessageSubmitTransaction}\n   */\n\n\n  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {\n    const body = bodies[0];\n    const message =\n    /** @type {proto.IConsensusSubmitMessageTransactionBody} */\n    body.consensusSubmitMessage;\n    return Transaction._fromProtobufTransactions(new TopicMessageSubmitTransaction({\n      topicId: message.topicID != null ? TopicId._fromProtobuf(message.topicID) : undefined,\n      message: message.message != null ? message.message : undefined\n    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);\n  }\n  /**\n   * @param {TransactionId} transactionId\n   * @returns {this}\n   */\n\n\n  setTransactionId(transactionId) {\n    this._requireNotFrozen();\n\n    if (transactionId.accountId == null || transactionId.validStart == null) {\n      throw new Error(\"`TopicMessageSubmitTransaction` does not support `TransactionId` built from `nonce`\");\n    }\n\n    this._transactionIds = [transactionId];\n    return this;\n  }\n  /**\n   * @returns {?TopicId}\n   */\n\n\n  get topicId() {\n    return this._topicId;\n  }\n  /**\n   * @param {TopicId | string} topicId\n   * @returns {this}\n   */\n\n\n  setTopicId(topicId) {\n    this._requireNotFrozen();\n\n    this._topicId = typeof topicId === \"string\" ? TopicId.fromString(topicId) : topicId.clone();\n    return this;\n  }\n  /**\n   * @returns {?Uint8Array}\n   */\n\n\n  get message() {\n    return this._message;\n  }\n  /**\n   * @param {string | Uint8Array} message\n   * @returns {this}\n   */\n\n\n  setMessage(message) {\n    this._requireNotFrozen();\n\n    message = util.requireStringOrUint8Array(message);\n    this._message = typeof message === \"string\" ? utf8.encode(message) : message;\n    return this;\n  }\n  /**\n   * @returns {?number}\n   */\n\n\n  get maxChunks() {\n    return this._maxChunks;\n  }\n  /**\n   * @param {number} maxChunks\n   * @returns {this}\n   */\n\n\n  setMaxChunks(maxChunks) {\n    this._requireNotFrozen();\n\n    this._maxChunks = maxChunks;\n    return this;\n  }\n  /**\n   * Freeze this transaction from further modification to prepare for\n   * signing or serialization.\n   *\n   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n   * nodes to prepare this transaction for.\n   *\n   * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {this}\n   */\n\n\n  freezeWith(client) {\n    super.freezeWith(client);\n\n    if (this._message == null) {\n      return this;\n    }\n\n    const chunks = Math.floor((this._message.length + (CHUNK_SIZE - 1)) / CHUNK_SIZE);\n\n    if (chunks > this._maxChunks) {\n      throw new Error(`Message with size ${this._message.length} too long for ${this._maxChunks} chunks`);\n    }\n\n    const initialTransactionId = this.transactionId._toProtobuf();\n\n    let nextTransactionId = this.transactionId;\n    super._transactions = [];\n    super._transactionIds = [];\n    super._signedTransactions = [];\n    super._nextTransactionIndex = 0;\n\n    for (let chunk = 0; chunk < chunks; chunk++) {\n      this._chunkInfo = {\n        initialTransactionID: initialTransactionId,\n        total: chunks,\n        number: chunk + 1\n      };\n\n      this._transactionIds.push(nextTransactionId);\n\n      for (const nodeAccountId of this._nodeIds) {\n        this._signedTransactions.push(this._makeSignedTransaction(nodeAccountId));\n      }\n\n      nextTransactionId = new TransactionId(\n      /** @type {AccountId} */\n      nextTransactionId.accountId, new Timestamp(\n      /** @type {Timestamp} */\n      nextTransactionId.validStart.seconds,\n      /** @type {Timestamp} */\n      nextTransactionId.validStart.nanos.add(1)));\n      super._nextTransactionIndex = this._nextTransactionIndex + 1;\n    }\n\n    this._chunkInfo = null;\n    super._nextTransactionIndex = 0;\n    return this;\n  }\n  /**\n   * @returns {ScheduleCreateTransaction}\n   */\n\n\n  schedule() {\n    this._requireNotFrozen();\n\n    if (this._message != null && this._message.length > CHUNK_SIZE) {\n      throw new Error(`cannot scheduled \\`TopicMessageSubmitTransaction\\` with message over ${CHUNK_SIZE} bytes`);\n    }\n\n    return super.schedule();\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<TransactionResponse>}\n   */\n\n\n  async execute(client) {\n    return (await this.executeAll(client))[0];\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<TransactionResponse[]>}\n   */\n\n\n  async executeAll(client) {\n    if (!super._isFrozen()) {\n      this.freezeWith(client);\n    } // on execute, sign each transaction with the operator, if present\n    // and we are signing a transaction that used the default transaction ID\n\n\n    const transactionId = this.transactionId;\n    const operatorAccountId = client.operatorAccountId;\n\n    if (operatorAccountId != null && operatorAccountId.equals(\n    /** @type {AccountId} */\n    transactionId.accountId)) {\n      await super.signWithOperator(client);\n    }\n\n    const responses = [];\n\n    for (let i = 0; i < this._transactionIds.length; i++) {\n      responses.push(await super.execute(client));\n    }\n\n    return responses;\n  }\n  /**\n   * @override\n   * @internal\n   * @param {Channel} channel\n   * @param {proto.ITransaction} request\n   * @returns {Promise<proto.ITransactionResponse>}\n   */\n\n\n  _execute(channel, request) {\n    return channel.consensus.submitMessage(request);\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {NonNullable<proto.TransactionBody[\"data\"]>}\n   */\n\n\n  _getTransactionDataCase() {\n    return \"consensusSubmitMessage\";\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {proto.IConsensusSubmitMessageTransactionBody}\n   */\n\n\n  _makeTransactionData() {\n    if (this._chunkInfo != null && this._message != null) {\n      const num =\n      /** @type {number} */\n      this._chunkInfo.number;\n      const startIndex = (num - 1) * CHUNK_SIZE;\n      let endIndex = startIndex + CHUNK_SIZE;\n\n      if (endIndex > this._message.length) {\n        endIndex = this._message.length;\n      }\n\n      return {\n        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,\n        message: this._message.slice(startIndex, endIndex),\n        chunkInfo: this._chunkInfo\n      };\n    } else {\n      return {\n        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,\n        message: this._message\n      };\n    }\n  }\n\n}\nTRANSACTION_REGISTRY.set(\"consensusSubmitMessage\", // eslint-disable-next-line @typescript-eslint/unbound-method\nTopicMessageSubmitTransaction._fromProtobuf);","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/topic/TopicMessageSubmitTransaction.js"],"names":["Transaction","TRANSACTION_REGISTRY","CHUNK_SIZE","TopicId","utf8","TransactionId","Timestamp","util","TopicMessageSubmitTransaction","constructor","props","_topicId","topicId","setTopicId","_message","message","setMessage","_maxChunks","maxChunks","setMaxChunks","_chunkInfo","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","body","consensusSubmitMessage","_fromProtobufTransactions","topicID","undefined","setTransactionId","transactionId","_requireNotFrozen","accountId","validStart","Error","_transactionIds","fromString","clone","requireStringOrUint8Array","encode","freezeWith","client","chunks","Math","floor","length","initialTransactionId","_toProtobuf","nextTransactionId","_transactions","_signedTransactions","_nextTransactionIndex","chunk","initialTransactionID","total","number","push","nodeAccountId","_nodeIds","_makeSignedTransaction","seconds","nanos","add","schedule","execute","executeAll","_isFrozen","operatorAccountId","equals","signWithOperator","responses","i","_execute","channel","request","consensus","submitMessage","_getTransactionDataCase","_makeTransactionData","num","startIndex","endIndex","slice","chunkInfo","set"],"mappings":"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","sourcesContent":["import Transaction, {\n    TRANSACTION_REGISTRY,\n    CHUNK_SIZE,\n} from \"../transaction/Transaction.js\";\nimport TopicId from \"./TopicId.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as util from \"../util.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IConsensusSubmitMessageTransactionBody} proto.IConsensusSubmitMessageTransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").TransactionBody} proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionResponse} proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").IConsensusMessageChunkInfo} proto.IConsensusMessageChunkInfo\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n */\n\nexport default class TopicMessageSubmitTransaction extends Transaction {\n    /**\n     * @param {object} props\n     * @param {TopicId | string} [props.topicId]\n     * @param {Uint8Array | string} [props.message]\n     * @param {number} [props.maxChunks]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?TopicId}\n         */\n        this._topicId = null;\n\n        if (props.topicId != null) {\n            this.setTopicId(props.topicId);\n        }\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._message = null;\n\n        if (props.message != null) {\n            this.setMessage(props.message);\n        }\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._maxChunks = 20;\n\n        if (props.maxChunks != null) {\n            this.setMaxChunks(props.maxChunks);\n        }\n\n        /** @type {proto.IConsensusMessageChunkInfo | null} */\n        this._chunkInfo = null;\n    }\n\n    /**\n     * @internal\n     * @param {proto.ITransaction[]} transactions\n     * @param {proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {proto.ITransactionBody[]} bodies\n     * @returns {TopicMessageSubmitTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies\n    ) {\n        const body = bodies[0];\n        const message =\n            /** @type {proto.IConsensusSubmitMessageTransactionBody} */ (\n                body.consensusSubmitMessage\n            );\n\n        return Transaction._fromProtobufTransactions(\n            new TopicMessageSubmitTransaction({\n                topicId:\n                    message.topicID != null\n                        ? TopicId._fromProtobuf(message.topicID)\n                        : undefined,\n                message: message.message != null ? message.message : undefined,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies\n        );\n    }\n\n    /**\n     * @param {TransactionId} transactionId\n     * @returns {this}\n     */\n    setTransactionId(transactionId) {\n        this._requireNotFrozen();\n\n        if (\n            transactionId.accountId == null ||\n            transactionId.validStart == null\n        ) {\n            throw new Error(\n                \"`TopicMessageSubmitTransaction` does not support `TransactionId` built from `nonce`\"\n            );\n        }\n\n        this._transactionIds = [transactionId];\n\n        return this;\n    }\n\n    /**\n     * @returns {?TopicId}\n     */\n    get topicId() {\n        return this._topicId;\n    }\n\n    /**\n     * @param {TopicId | string} topicId\n     * @returns {this}\n     */\n    setTopicId(topicId) {\n        this._requireNotFrozen();\n\n        this._topicId =\n            typeof topicId === \"string\"\n                ? TopicId.fromString(topicId)\n                : topicId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get message() {\n        return this._message;\n    }\n\n    /**\n     * @param {string | Uint8Array} message\n     * @returns {this}\n     */\n    setMessage(message) {\n        this._requireNotFrozen();\n        message = util.requireStringOrUint8Array(message);\n        this._message =\n            typeof message === \"string\" ? utf8.encode(message) : message;\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get maxChunks() {\n        return this._maxChunks;\n    }\n\n    /**\n     * @param {number} maxChunks\n     * @returns {this}\n     */\n    setMaxChunks(maxChunks) {\n        this._requireNotFrozen();\n        this._maxChunks = maxChunks;\n        return this;\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        super.freezeWith(client);\n\n        if (this._message == null) {\n            return this;\n        }\n\n        const chunks = Math.floor(\n            (this._message.length + (CHUNK_SIZE - 1)) / CHUNK_SIZE\n        );\n\n        if (chunks > this._maxChunks) {\n            throw new Error(\n                `Message with size ${this._message.length} too long for ${this._maxChunks} chunks`\n            );\n        }\n\n        const initialTransactionId = this.transactionId._toProtobuf();\n        let nextTransactionId = this.transactionId;\n\n        super._transactions = [];\n        super._transactionIds = [];\n        super._signedTransactions = [];\n        super._nextTransactionIndex = 0;\n\n        for (let chunk = 0; chunk < chunks; chunk++) {\n            this._chunkInfo = {\n                initialTransactionID: initialTransactionId,\n                total: chunks,\n                number: chunk + 1,\n            };\n\n            this._transactionIds.push(nextTransactionId);\n\n            for (const nodeAccountId of this._nodeIds) {\n                this._signedTransactions.push(\n                    this._makeSignedTransaction(nodeAccountId)\n                );\n            }\n\n            nextTransactionId = new TransactionId(\n                /** @type {AccountId} */ (nextTransactionId.accountId),\n                new Timestamp(\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).seconds,\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).nanos.add(1)\n                )\n            );\n\n            super._nextTransactionIndex = this._nextTransactionIndex + 1;\n        }\n\n        this._chunkInfo = null;\n        super._nextTransactionIndex = 0;\n\n        return this;\n    }\n\n    /**\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (this._message != null && this._message.length > CHUNK_SIZE) {\n            throw new Error(\n                `cannot scheduled \\`TopicMessageSubmitTransaction\\` with message over ${CHUNK_SIZE} bytes`\n            );\n        }\n\n        return super.schedule();\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<TransactionResponse>}\n     */\n    async execute(client) {\n        return (await this.executeAll(client))[0];\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<TransactionResponse[]>}\n     */\n    async executeAll(client) {\n        if (!super._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        // on execute, sign each transaction with the operator, if present\n        // and we are signing a transaction that used the default transaction ID\n\n        const transactionId = this.transactionId;\n        const operatorAccountId = client.operatorAccountId;\n\n        if (\n            operatorAccountId != null &&\n            operatorAccountId.equals(\n                /** @type {AccountId} */ (transactionId.accountId)\n            )\n        ) {\n            await super.signWithOperator(client);\n        }\n\n        const responses = [];\n        for (let i = 0; i < this._transactionIds.length; i++) {\n            responses.push(await super.execute(client));\n        }\n\n        return responses;\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {proto.ITransaction} request\n     * @returns {Promise<proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.consensus.submitMessage(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"consensusSubmitMessage\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {proto.IConsensusSubmitMessageTransactionBody}\n     */\n    _makeTransactionData() {\n        if (this._chunkInfo != null && this._message != null) {\n            const num = /** @type {number} */ (this._chunkInfo.number);\n            const startIndex = (num - 1) * CHUNK_SIZE;\n            let endIndex = startIndex + CHUNK_SIZE;\n\n            if (endIndex > this._message.length) {\n                endIndex = this._message.length;\n            }\n\n            return {\n                topicID:\n                    this._topicId != null ? this._topicId._toProtobuf() : null,\n                message: this._message.slice(startIndex, endIndex),\n                chunkInfo: this._chunkInfo,\n            };\n        } else {\n            return {\n                topicID:\n                    this._topicId != null ? this._topicId._toProtobuf() : null,\n                message: this._message,\n            };\n        }\n    }\n}\n\nTRANSACTION_REGISTRY.set(\n    \"consensusSubmitMessage\",\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    TopicMessageSubmitTransaction._fromProtobuf\n);\n"]},"metadata":{},"sourceType":"module"}