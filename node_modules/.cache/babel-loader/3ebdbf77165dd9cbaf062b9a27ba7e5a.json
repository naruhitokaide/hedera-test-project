{"ast":null,"code":"import AccountId from \"./AccountId.js\";\nimport LiveHash from \"./LiveHash.js\";\nimport Hbar from \"../Hbar.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport Long from \"long\";\nimport TokenRelationshipMap from \"./TokenRelationshipMap.js\";\nimport * as proto from \"@hashgraph/proto\";\nimport Duration from \"../Duration.js\";\nimport Key from \"../Key.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport LedgerId from \"../LedgerId.js\";\n/**\n * Current information about an account, including the balance.\n */\n\nexport default class AccountInfo {\n  /**\n   * @private\n   * @param {object} props\n   * @param {AccountId} props.accountId\n   * @param {?string} props.contractAccountId\n   * @param {boolean} props.isDeleted\n   * @param {?AccountId} props.proxyAccountId\n   * @param {Hbar} props.proxyReceived\n   * @param {Key} props.key\n   * @param {Hbar} props.balance\n   * @param {Hbar} props.sendRecordThreshold\n   * @param {Hbar} props.receiveRecordThreshold\n   * @param {boolean} props.isReceiverSignatureRequired\n   * @param {Timestamp} props.expirationTime\n   * @param {Duration} props.autoRenewPeriod\n   * @param {LiveHash[]} props.liveHashes\n   * @param {TokenRelationshipMap} props.tokenRelationships\n   * @param {string} props.accountMemo\n   * @param {Long} props.ownedNfts\n   * @param {Long} props.maxAutomaticTokenAssociations\n   * @param {PublicKey | null} props.aliasKey\n   * @param {LedgerId|null} props.ledgerId\n   */\n  constructor(props) {\n    /**\n     * The account ID for which this information applies.\n     *\n     * @readonly\n     */\n    this.accountId = props.accountId;\n    /**\n     * The Contract Account ID comprising of both the contract instance and the cryptocurrency\n     * account owned by the contract instance, in the format used by Solidity.\n     *\n     * @readonly\n     */\n\n    this.contractAccountId = props.contractAccountId;\n    /**\n     * If true, then this account has been deleted, it will disappear when it expires, and\n     * all transactions for it will fail except the transaction to extend its expiration date.\n     *\n     * @readonly\n     */\n\n    this.isDeleted = props.isDeleted;\n    /**\n     * The Account ID of the account to which this is proxy staked. If proxyAccountID is null,\n     * or is an invalid account, or is an account that isn't a node, then this account is\n     * automatically proxy staked to a node chosen by the network, but without earning payments.\n     * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently\n     * running a node, then it will behave as if proxyAccountID was null.\n     *\n     * @readonly\n     */\n\n    this.proxyAccountId = props.proxyAccountId;\n    /**\n     * The total number of tinybars proxy staked to this account.\n     *\n     * @readonly\n     */\n\n    this.proxyReceived = props.proxyReceived;\n    /**\n     * The key for the account, which must sign in order to transfer out, or to modify the account\n     * in any way other than extending its expiration date.\n     *\n     * @readonly\n     */\n\n    this.key = props.key;\n    /**\n     * The current balance of account.\n     *\n     * @readonly\n     */\n\n    this.balance = props.balance;\n    /**\n     * The threshold amount (in tinybars) for which an account record is created (and this account\n     * charged for them) for any send/withdraw transaction.\n     *\n     * @readonly\n     */\n\n    this.sendRecordThreshold = props.sendRecordThreshold;\n    /**\n     * The threshold amount (in tinybars) for which an account record is created\n     * (and this account charged for them) for any transaction above this amount.\n     *\n     * @readonly\n     */\n\n    this.receiveRecordThreshold = props.receiveRecordThreshold;\n    /**\n     * If true, no transaction can transfer to this account unless signed by this account's key.\n     *\n     * @readonly\n     */\n\n    this.isReceiverSignatureRequired = props.isReceiverSignatureRequired;\n    /**\n     * The TimeStamp time at which this account is set to expire.\n     *\n     * @readonly\n     */\n\n    this.expirationTime = props.expirationTime;\n    /**\n     * The duration for expiration time will extend every this many seconds. If there are\n     * insufficient funds, then it extends as long as possible. If it is empty when it\n     * expires, then it is deleted.\n     *\n     * @readonly\n     */\n\n    this.autoRenewPeriod = props.autoRenewPeriod;\n    /** @readonly */\n\n    this.liveHashes = props.liveHashes;\n    /** @readonly */\n\n    this.tokenRelationships = props.tokenRelationships;\n    /** @readonly */\n\n    this.accountMemo = props.accountMemo;\n    /** @readonly */\n\n    this.ownedNfts = props.ownedNfts;\n    /** @readonly */\n\n    this.maxAutomaticTokenAssociations = props.maxAutomaticTokenAssociations;\n    this.aliasKey = props.aliasKey;\n    this.ledgerId = props.ledgerId;\n    Object.freeze(this);\n  }\n  /**\n   * @internal\n   * @param {proto.IAccountInfo} info\n   * @returns {AccountInfo}\n   */\n\n\n  static _fromProtobuf(info) {\n    let aliasKey = info.alias != null && info.alias.length > 0 ? Key._fromProtobufKey(proto.Key.decode(info.alias)) : null;\n\n    if (!(aliasKey instanceof PublicKey)) {\n      aliasKey = null;\n    }\n\n    return new AccountInfo({\n      accountId: AccountId._fromProtobuf(\n      /** @type {proto.IAccountID} */\n      info.accountID),\n      contractAccountId: info.contractAccountID != null ? info.contractAccountID : null,\n      isDeleted: info.deleted != null ? info.deleted : false,\n      key: Key._fromProtobufKey(\n      /** @type {proto.IKey} */\n      info.key),\n      balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),\n      sendRecordThreshold: Hbar.fromTinybars(info.generateSendRecordThreshold != null ? info.generateSendRecordThreshold : 0),\n      receiveRecordThreshold: Hbar.fromTinybars(info.generateReceiveRecordThreshold != null ? info.generateReceiveRecordThreshold : 0),\n      isReceiverSignatureRequired: info.receiverSigRequired != null ? info.receiverSigRequired : false,\n      expirationTime: Timestamp._fromProtobuf(\n      /** @type {proto.ITimestamp} */\n      info.expirationTime),\n      autoRenewPeriod: info.autoRenewPeriod != null ? new Duration(\n      /** @type {Long} */\n      info.autoRenewPeriod.seconds) : new Duration(0),\n      proxyAccountId: info.proxyAccountID != null && Long.fromValue(\n      /** @type {Long | number} */\n      info.proxyAccountID.shardNum).toInt() !== 0 && Long.fromValue(\n      /** @type {Long | number} */\n      info.proxyAccountID.realmNum).toInt() !== 0 && Long.fromValue(\n      /** @type {Long | number} */\n      info.proxyAccountID.accountNum).toInt() !== 0 ? AccountId._fromProtobuf(info.proxyAccountID) : null,\n      proxyReceived: Hbar.fromTinybars(info.proxyReceived != null ? info.proxyReceived : 0),\n      liveHashes: (info.liveHashes != null ? info.liveHashes : []).map(hash => LiveHash._fromProtobuf(hash)),\n      tokenRelationships: TokenRelationshipMap._fromProtobuf(info.tokenRelationships != null ? info.tokenRelationships : []),\n      accountMemo: info.memo != null ? info.memo : \"\",\n      ownedNfts: info.ownedNfts ? info.ownedNfts : Long.ZERO,\n      maxAutomaticTokenAssociations: info.maxAutomaticTokenAssociations ? Long.fromNumber(info.maxAutomaticTokenAssociations) : Long.ZERO,\n      aliasKey,\n      ledgerId: info.ledgerId != null ? LedgerId.fromBytes(info.ledgerId) : null\n    });\n  }\n  /**\n   * @returns {proto.IAccountInfo}\n   */\n\n\n  _toProtobuf() {\n    return {\n      accountID: this.accountId._toProtobuf(),\n      contractAccountID: this.contractAccountId,\n      deleted: this.isDeleted,\n      proxyAccountID: this.proxyAccountId != null ? this.proxyAccountId._toProtobuf() : null,\n      proxyReceived: this.proxyReceived.toTinybars(),\n      key: this.key._toProtobufKey(),\n      balance: this.balance.toTinybars(),\n      generateSendRecordThreshold: this.sendRecordThreshold.toTinybars(),\n      generateReceiveRecordThreshold: this.receiveRecordThreshold.toTinybars(),\n      receiverSigRequired: this.isReceiverSignatureRequired,\n      expirationTime: this.expirationTime._toProtobuf(),\n      autoRenewPeriod: this.autoRenewPeriod._toProtobuf(),\n      liveHashes: this.liveHashes.map(hash => hash._toProtobuf()),\n      tokenRelationships: this.tokenRelationships != null ? this.tokenRelationships._toProtobuf() : null,\n      memo: this.accountMemo,\n      ownedNfts: this.ownedNfts,\n      maxAutomaticTokenAssociations: this.maxAutomaticTokenAssociations.toInt(),\n      alias: this.aliasKey != null ? proto.Key.encode(this.aliasKey._toProtobufKey()).finish() : null,\n      ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null\n    };\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {AccountInfo}\n   */\n\n\n  static fromBytes(bytes) {\n    return AccountInfo._fromProtobuf(proto.CryptoGetInfoResponse.AccountInfo.decode(bytes));\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return proto.CryptoGetInfoResponse.AccountInfo.encode(this._toProtobuf()).finish();\n  }\n\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/account/AccountInfo.js"],"names":["AccountId","LiveHash","Hbar","Timestamp","Long","TokenRelationshipMap","proto","Duration","Key","PublicKey","LedgerId","AccountInfo","constructor","props","accountId","contractAccountId","isDeleted","proxyAccountId","proxyReceived","key","balance","sendRecordThreshold","receiveRecordThreshold","isReceiverSignatureRequired","expirationTime","autoRenewPeriod","liveHashes","tokenRelationships","accountMemo","ownedNfts","maxAutomaticTokenAssociations","aliasKey","ledgerId","Object","freeze","_fromProtobuf","info","alias","length","_fromProtobufKey","decode","accountID","contractAccountID","deleted","fromTinybars","generateSendRecordThreshold","generateReceiveRecordThreshold","receiverSigRequired","seconds","proxyAccountID","fromValue","shardNum","toInt","realmNum","accountNum","map","hash","memo","ZERO","fromNumber","fromBytes","_toProtobuf","toTinybars","_toProtobufKey","encode","finish","toBytes","bytes","CryptoGetInfoResponse"],"mappings":"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","sourcesContent":["import AccountId from \"./AccountId.js\";\nimport LiveHash from \"./LiveHash.js\";\nimport Hbar from \"../Hbar.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport Long from \"long\";\nimport TokenRelationshipMap from \"./TokenRelationshipMap.js\";\nimport * as proto from \"@hashgraph/proto\";\nimport Duration from \"../Duration.js\";\nimport Key from \"../Key.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport LedgerId from \"../LedgerId.js\";\n\n/**\n * Current information about an account, including the balance.\n */\nexport default class AccountInfo {\n    /**\n     * @private\n     * @param {object} props\n     * @param {AccountId} props.accountId\n     * @param {?string} props.contractAccountId\n     * @param {boolean} props.isDeleted\n     * @param {?AccountId} props.proxyAccountId\n     * @param {Hbar} props.proxyReceived\n     * @param {Key} props.key\n     * @param {Hbar} props.balance\n     * @param {Hbar} props.sendRecordThreshold\n     * @param {Hbar} props.receiveRecordThreshold\n     * @param {boolean} props.isReceiverSignatureRequired\n     * @param {Timestamp} props.expirationTime\n     * @param {Duration} props.autoRenewPeriod\n     * @param {LiveHash[]} props.liveHashes\n     * @param {TokenRelationshipMap} props.tokenRelationships\n     * @param {string} props.accountMemo\n     * @param {Long} props.ownedNfts\n     * @param {Long} props.maxAutomaticTokenAssociations\n     * @param {PublicKey | null} props.aliasKey\n     * @param {LedgerId|null} props.ledgerId\n     */\n    constructor(props) {\n        /**\n         * The account ID for which this information applies.\n         *\n         * @readonly\n         */\n        this.accountId = props.accountId;\n\n        /**\n         * The Contract Account ID comprising of both the contract instance and the cryptocurrency\n         * account owned by the contract instance, in the format used by Solidity.\n         *\n         * @readonly\n         */\n        this.contractAccountId = props.contractAccountId;\n\n        /**\n         * If true, then this account has been deleted, it will disappear when it expires, and\n         * all transactions for it will fail except the transaction to extend its expiration date.\n         *\n         * @readonly\n         */\n        this.isDeleted = props.isDeleted;\n\n        /**\n         * The Account ID of the account to which this is proxy staked. If proxyAccountID is null,\n         * or is an invalid account, or is an account that isn't a node, then this account is\n         * automatically proxy staked to a node chosen by the network, but without earning payments.\n         * If the proxyAccountID account refuses to accept proxy staking , or if it is not currently\n         * running a node, then it will behave as if proxyAccountID was null.\n         *\n         * @readonly\n         */\n        this.proxyAccountId = props.proxyAccountId;\n\n        /**\n         * The total number of tinybars proxy staked to this account.\n         *\n         * @readonly\n         */\n        this.proxyReceived = props.proxyReceived;\n\n        /**\n         * The key for the account, which must sign in order to transfer out, or to modify the account\n         * in any way other than extending its expiration date.\n         *\n         * @readonly\n         */\n        this.key = props.key;\n\n        /**\n         * The current balance of account.\n         *\n         * @readonly\n         */\n        this.balance = props.balance;\n\n        /**\n         * The threshold amount (in tinybars) for which an account record is created (and this account\n         * charged for them) for any send/withdraw transaction.\n         *\n         * @readonly\n         */\n        this.sendRecordThreshold = props.sendRecordThreshold;\n\n        /**\n         * The threshold amount (in tinybars) for which an account record is created\n         * (and this account charged for them) for any transaction above this amount.\n         *\n         * @readonly\n         */\n        this.receiveRecordThreshold = props.receiveRecordThreshold;\n\n        /**\n         * If true, no transaction can transfer to this account unless signed by this account's key.\n         *\n         * @readonly\n         */\n        this.isReceiverSignatureRequired = props.isReceiverSignatureRequired;\n\n        /**\n         * The TimeStamp time at which this account is set to expire.\n         *\n         * @readonly\n         */\n        this.expirationTime = props.expirationTime;\n\n        /**\n         * The duration for expiration time will extend every this many seconds. If there are\n         * insufficient funds, then it extends as long as possible. If it is empty when it\n         * expires, then it is deleted.\n         *\n         * @readonly\n         */\n        this.autoRenewPeriod = props.autoRenewPeriod;\n\n        /** @readonly */\n        this.liveHashes = props.liveHashes;\n\n        /** @readonly */\n        this.tokenRelationships = props.tokenRelationships;\n\n        /** @readonly */\n        this.accountMemo = props.accountMemo;\n\n        /** @readonly */\n        this.ownedNfts = props.ownedNfts;\n\n        /** @readonly */\n        this.maxAutomaticTokenAssociations =\n            props.maxAutomaticTokenAssociations;\n\n        this.aliasKey = props.aliasKey;\n\n        this.ledgerId = props.ledgerId;\n\n        Object.freeze(this);\n    }\n\n    /**\n     * @internal\n     * @param {proto.IAccountInfo} info\n     * @returns {AccountInfo}\n     */\n    static _fromProtobuf(info) {\n        let aliasKey =\n            info.alias != null && info.alias.length > 0\n                ? Key._fromProtobufKey(proto.Key.decode(info.alias))\n                : null;\n\n        if (!(aliasKey instanceof PublicKey)) {\n            aliasKey = null;\n        }\n\n        return new AccountInfo({\n            accountId: AccountId._fromProtobuf(\n                /** @type {proto.IAccountID} */ (info.accountID)\n            ),\n            contractAccountId:\n                info.contractAccountID != null ? info.contractAccountID : null,\n            isDeleted: info.deleted != null ? info.deleted : false,\n            key: Key._fromProtobufKey(/** @type {proto.IKey} */ (info.key)),\n            balance: Hbar.fromTinybars(info.balance != null ? info.balance : 0),\n            sendRecordThreshold: Hbar.fromTinybars(\n                info.generateSendRecordThreshold != null\n                    ? info.generateSendRecordThreshold\n                    : 0\n            ),\n            receiveRecordThreshold: Hbar.fromTinybars(\n                info.generateReceiveRecordThreshold != null\n                    ? info.generateReceiveRecordThreshold\n                    : 0\n            ),\n            isReceiverSignatureRequired:\n                info.receiverSigRequired != null\n                    ? info.receiverSigRequired\n                    : false,\n            expirationTime: Timestamp._fromProtobuf(\n                /** @type {proto.ITimestamp} */ (info.expirationTime)\n            ),\n            autoRenewPeriod:\n                info.autoRenewPeriod != null\n                    ? new Duration(\n                          /** @type {Long} */ (info.autoRenewPeriod.seconds)\n                      )\n                    : new Duration(0),\n            proxyAccountId:\n                info.proxyAccountID != null &&\n                Long.fromValue(\n                    /** @type {Long | number} */ (info.proxyAccountID.shardNum)\n                ).toInt() !== 0 &&\n                Long.fromValue(\n                    /** @type {Long | number} */ (info.proxyAccountID.realmNum)\n                ).toInt() !== 0 &&\n                Long.fromValue(\n                    /** @type {Long | number} */ (\n                        info.proxyAccountID.accountNum\n                    )\n                ).toInt() !== 0\n                    ? AccountId._fromProtobuf(info.proxyAccountID)\n                    : null,\n            proxyReceived: Hbar.fromTinybars(\n                info.proxyReceived != null ? info.proxyReceived : 0\n            ),\n            liveHashes: (info.liveHashes != null ? info.liveHashes : []).map(\n                (hash) => LiveHash._fromProtobuf(hash)\n            ),\n            tokenRelationships: TokenRelationshipMap._fromProtobuf(\n                info.tokenRelationships != null ? info.tokenRelationships : []\n            ),\n            accountMemo: info.memo != null ? info.memo : \"\",\n            ownedNfts: info.ownedNfts ? info.ownedNfts : Long.ZERO,\n            maxAutomaticTokenAssociations: info.maxAutomaticTokenAssociations\n                ? Long.fromNumber(info.maxAutomaticTokenAssociations)\n                : Long.ZERO,\n            aliasKey,\n            ledgerId:\n                info.ledgerId != null\n                    ? LedgerId.fromBytes(info.ledgerId)\n                    : null,\n        });\n    }\n\n    /**\n     * @returns {proto.IAccountInfo}\n     */\n    _toProtobuf() {\n        return {\n            accountID: this.accountId._toProtobuf(),\n            contractAccountID: this.contractAccountId,\n            deleted: this.isDeleted,\n            proxyAccountID:\n                this.proxyAccountId != null\n                    ? this.proxyAccountId._toProtobuf()\n                    : null,\n            proxyReceived: this.proxyReceived.toTinybars(),\n            key: this.key._toProtobufKey(),\n            balance: this.balance.toTinybars(),\n            generateSendRecordThreshold: this.sendRecordThreshold.toTinybars(),\n            generateReceiveRecordThreshold:\n                this.receiveRecordThreshold.toTinybars(),\n            receiverSigRequired: this.isReceiverSignatureRequired,\n            expirationTime: this.expirationTime._toProtobuf(),\n            autoRenewPeriod: this.autoRenewPeriod._toProtobuf(),\n            liveHashes: this.liveHashes.map((hash) => hash._toProtobuf()),\n            tokenRelationships:\n                this.tokenRelationships != null\n                    ? this.tokenRelationships._toProtobuf()\n                    : null,\n            memo: this.accountMemo,\n            ownedNfts: this.ownedNfts,\n            maxAutomaticTokenAssociations:\n                this.maxAutomaticTokenAssociations.toInt(),\n            alias:\n                this.aliasKey != null\n                    ? proto.Key.encode(this.aliasKey._toProtobufKey()).finish()\n                    : null,\n            ledgerId: this.ledgerId != null ? this.ledgerId.toBytes() : null,\n        };\n    }\n\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountInfo}\n     */\n    static fromBytes(bytes) {\n        return AccountInfo._fromProtobuf(\n            proto.CryptoGetInfoResponse.AccountInfo.decode(bytes)\n        );\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return proto.CryptoGetInfoResponse.AccountInfo.encode(\n            this._toProtobuf()\n        ).finish();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}