{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Writer;\n\nvar util = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits = util.LongBits,\n    base64 = util.base64,\n    utf8 = util.utf8;\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\n\nfunction Op(fn, len, val) {\n  /**\n   * Function to call.\n   * @type {function(Uint8Array, number, *)}\n   */\n  this.fn = fn;\n  /**\n   * Value byte length.\n   * @type {number}\n   */\n\n  this.len = len;\n  /**\n   * Next operation.\n   * @type {Writer.Op|undefined}\n   */\n\n  this.next = undefined;\n  /**\n   * Value to write.\n   * @type {*}\n   */\n\n  this.val = val; // type varies\n}\n/* istanbul ignore next */\n\n\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\n\n\nfunction State(writer) {\n  /**\n   * Current head.\n   * @type {Writer.Op}\n   */\n  this.head = writer.head;\n  /**\n   * Current tail.\n   * @type {Writer.Op}\n   */\n\n  this.tail = writer.tail;\n  /**\n   * Current buffer length.\n   * @type {number}\n   */\n\n  this.len = writer.len;\n  /**\n   * Next state.\n   * @type {State|null}\n   */\n\n  this.next = writer.states;\n}\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\n\n\nfunction Writer() {\n  /**\n   * Current length.\n   * @type {number}\n   */\n  this.len = 0;\n  /**\n   * Operations head.\n   * @type {Object}\n   */\n\n  this.head = new Op(noop, 0, 0);\n  /**\n   * Operations tail\n   * @type {Object}\n   */\n\n  this.tail = this.head;\n  /**\n   * Linked forked states.\n   * @type {Object|null}\n   */\n\n  this.states = null; // When a value is written, the writer calculates its byte length and puts it into a linked\n  // list of operations to perform when finish() is called. This both allows us to allocate\n  // buffers of the exact required size and reduces the amount of work we have to do compared\n  // to first calculating over objects and then encoding over objects. In our case, the encoding\n  // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n  return util.Buffer ? function create_buffer_setup() {\n    return (Writer.create = function create_buffer() {\n      return new BufferWriter();\n    })();\n  }\n  /* istanbul ignore next */\n  : function create_array() {\n    return new Writer();\n  };\n};\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\n\n\nWriter.create = create();\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\n\nWriter.alloc = function alloc(size) {\n  return new util.Array(size);\n}; // Use Uint8Array buffer pool in the browser, just like node does with buffers\n\n/* istanbul ignore else */\n\n\nif (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\n\nWriter.prototype._push = function push(fn, len, val) {\n  this.tail = this.tail.next = new Op(fn, len, val);\n  this.len += len;\n  return this;\n};\n\nfunction writeByte(val, buf, pos) {\n  buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128;\n    val >>>= 7;\n  }\n\n  buf[pos] = val;\n}\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\n\n\nfunction VarintOp(len, val) {\n  this.len = len;\n  this.next = undefined;\n  this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\n\nWriter.prototype.uint32 = function write_uint32(value) {\n  // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n  // uint32 is by far the most frequently used operation and benefits significantly from this.\n  this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n  return this;\n};\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.int32 = function write_int32(value) {\n  return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n  : this.uint32(value);\n};\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.sint32 = function write_sint32(value) {\n  return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n  while (val.hi) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n    val.hi >>>= 7;\n  }\n\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128;\n    val.lo = val.lo >>> 7;\n  }\n\n  buf[pos++] = val.lo;\n}\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\n\n\nWriter.prototype.uint64 = function write_uint64(value) {\n  var bits = LongBits.from(value);\n  return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\n\n\nWriter.prototype.int64 = Writer.prototype.uint64;\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\n\nWriter.prototype.sint64 = function write_sint64(value) {\n  var bits = LongBits.from(value).zzEncode();\n  return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.bool = function write_bool(value) {\n  return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n  buf[pos] = val & 255;\n  buf[pos + 1] = val >>> 8 & 255;\n  buf[pos + 2] = val >>> 16 & 255;\n  buf[pos + 3] = val >>> 24;\n}\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.fixed32 = function write_fixed32(value) {\n  return this._push(writeFixed32, 4, value >>> 0);\n};\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\n\nWriter.prototype.fixed64 = function write_fixed64(value) {\n  var bits = LongBits.from(value);\n  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\n\n\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\n\nWriter.prototype.float = function write_float(value) {\n  return this._push(util.float.writeFloatLE, 4, value);\n};\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.double = function write_double(value) {\n  return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n  buf.set(val, pos); // also works for plain array values\n}\n/* istanbul ignore next */\n: function writeBytes_for(val, buf, pos) {\n  for (var i = 0; i < val.length; ++i) buf[pos + i] = val[i];\n};\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\n\nWriter.prototype.bytes = function write_bytes(value) {\n  var len = value.length >>> 0;\n  if (!len) return this._push(writeByte, 1, 0);\n\n  if (util.isString(value)) {\n    var buf = Writer.alloc(len = base64.length(value));\n    base64.decode(value, buf, 0);\n    value = buf;\n  }\n\n  return this.uint32(len)._push(writeBytes, len, value);\n};\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.string = function write_string(value) {\n  var len = utf8.length(value);\n  return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n};\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.fork = function fork() {\n  this.states = new State(this);\n  this.head = this.tail = new Op(noop, 0, 0);\n  this.len = 0;\n  return this;\n};\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.reset = function reset() {\n  if (this.states) {\n    this.head = this.states.head;\n    this.tail = this.states.tail;\n    this.len = this.states.len;\n    this.states = this.states.next;\n  } else {\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n  }\n\n  return this;\n};\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\n\n\nWriter.prototype.ldelim = function ldelim() {\n  var head = this.head,\n      tail = this.tail,\n      len = this.len;\n  this.reset().uint32(len);\n\n  if (len) {\n    this.tail.next = head.next; // skip noop\n\n    this.tail = tail;\n    this.len += len;\n  }\n\n  return this;\n};\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\n\n\nWriter.prototype.finish = function finish() {\n  var head = this.head.next,\n      // skip noop\n  buf = this.constructor.alloc(this.len),\n      pos = 0;\n\n  while (head) {\n    head.fn(head.val, buf, pos);\n    pos += head.len;\n    head = head.next;\n  } // this.head = this.tail = null;\n\n\n  return buf;\n};\n\nWriter._configure = function (BufferWriter_) {\n  BufferWriter = BufferWriter_;\n  Writer.create = create();\n\n  BufferWriter._configure();\n};","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/protobufjs/src/writer.js"],"names":["module","exports","Writer","util","require","BufferWriter","LongBits","base64","utf8","Op","fn","len","val","next","undefined","noop","State","writer","head","tail","states","create","Buffer","create_buffer_setup","create_buffer","create_array","alloc","size","Array","pool","prototype","subarray","_push","push","writeByte","buf","pos","writeVarint32","VarintOp","Object","uint32","write_uint32","value","int32","write_int32","writeVarint64","fromNumber","sint32","write_sint32","hi","lo","uint64","write_uint64","bits","from","length","int64","sint64","write_sint64","zzEncode","bool","write_bool","writeFixed32","fixed32","write_fixed32","sfixed32","fixed64","write_fixed64","sfixed64","float","write_float","writeFloatLE","double","write_double","writeDoubleLE","writeBytes","set","writeBytes_set","writeBytes_for","i","bytes","write_bytes","isString","decode","string","write_string","write","fork","reset","ldelim","finish","constructor","_configure","BufferWriter_"],"mappings":"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","sourcesContent":["\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n"]},"metadata":{},"sourceType":"script"}