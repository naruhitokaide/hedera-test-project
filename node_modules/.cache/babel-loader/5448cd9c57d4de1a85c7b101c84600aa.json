{"ast":null,"code":"import * as cryptography from \"@hashgraph/cryptography\";\nimport { arrayEqual } from \"./array.js\";\nimport Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\n/**\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IKey} proto.IKey\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignaturePair} proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n */\n\nexport default class PublicKey extends Key {\n  /**\n   * @internal\n   * @hideconstructor\n   * @param {cryptography.PublicKey} key\n   */\n  constructor(key) {\n    super();\n    this._key = key;\n  }\n  /**\n   * @param {Uint8Array} data\n   * @returns {PublicKey}\n   */\n\n\n  static fromBytes(data) {\n    return new PublicKey(cryptography.PublicKey.fromBytes(data));\n  }\n  /**\n   * @param {Uint8Array} data\n   * @returns {PublicKey}\n   */\n\n\n  static fromBytesED25519(data) {\n    return new PublicKey(cryptography.PublicKey.fromBytesED25519(data));\n  }\n  /**\n   * @param {Uint8Array} data\n   * @returns {PublicKey}\n   */\n\n\n  static fromBytesECDSA(data) {\n    return new PublicKey(cryptography.PublicKey.fromBytesECDSA(data));\n  }\n  /**\n   * Parse a public key from a string of hexadecimal digits.\n   *\n   * The public key may optionally be prefixed with\n   * the DER header.\n   *\n   * @param {string} text\n   * @returns {PublicKey}\n   */\n\n\n  static fromString(text) {\n    return new PublicKey(cryptography.PublicKey.fromString(text));\n  }\n  /**\n   * Verify a signature on a message with this public key.\n   *\n   * @param {Uint8Array} message\n   * @param {Uint8Array} signature\n   * @returns {boolean}\n   */\n\n\n  verify(message, signature) {\n    return this._key.verify(message, signature);\n  }\n  /**\n   * @param {Transaction} transaction\n   * @returns {boolean}\n   */\n\n\n  verifyTransaction(transaction) {\n    transaction._requireFrozen();\n\n    if (!transaction.isFrozen()) {\n      transaction.freeze();\n    }\n\n    for (const signedTransaction of transaction._signedTransactions) {\n      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {\n        let found = false;\n\n        for (const sigPair of signedTransaction.sigMap.sigPair) {\n          const pubKeyPrefix =\n          /** @type {Uint8Array} */\n          sigPair.pubKeyPrefix;\n\n          if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {\n            found = true;\n            const bodyBytes =\n            /** @type {Uint8Array} */\n            signedTransaction.bodyBytes;\n            let signature = null;\n\n            if (sigPair.ed25519 != null) {\n              signature = sigPair.ed25519;\n            } else if (sigPair.ECDSASecp256k1 != null) {\n              signature = sigPair.ECDSASecp256k1;\n            }\n\n            if (signature == null) {\n              continue;\n            }\n\n            if (!this.verify(bodyBytes, signature)) {\n              return false;\n            }\n          }\n        }\n\n        if (!found) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return this._key.toBytes();\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesDer() {\n    return this._key.toBytesDer();\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesRaw() {\n    return this._key.toBytesRaw();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    return this._key.toString();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toStringDer() {\n    return this._key.toStringDer();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toStringRaw() {\n    return this._key.toStringRaw();\n  }\n  /**\n   * @param {PublicKey} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    return this._key.equals(other._key);\n  }\n  /**\n   * @returns {proto.IKey}\n   */\n\n\n  _toProtobufKey() {\n    switch (this._key._type) {\n      case \"ED25519\":\n        return {\n          ed25519: this._key.toBytesRaw()\n        };\n\n      case \"secp256k1\":\n        return {\n          ECDSASecp256k1: this._key.toBytesRaw()\n        };\n\n      default:\n        throw new Error(`unrecognized key type ${this._key._type}`);\n    }\n  }\n  /**\n   * @param {Uint8Array} signature\n   * @returns {proto.ISignaturePair}\n   */\n\n\n  _toProtobufSignature(signature) {\n    switch (this._key._type) {\n      case \"ED25519\":\n        return {\n          pubKeyPrefix: this._key.toBytesRaw(),\n          ed25519: signature\n        };\n\n      case \"secp256k1\":\n        return {\n          pubKeyPrefix: this._key.toBytesRaw(),\n          ECDSASecp256k1: signature\n        };\n\n      default:\n        throw new Error(`unrecognized key type ${this._key._type}`);\n    }\n  }\n  /**\n   * @param {Long | number} shard\n   * @param {Long | number} realm\n   * @returns {AccountId}\n   */\n\n\n  toAccountId(shard, realm) {\n    if (CACHE.accountIdConstructor == null) {\n      throw new Error(\"`AccountId` not loaded\");\n    }\n\n    return CACHE.accountIdConstructor(shard, realm, this);\n  }\n\n}\n\nCACHE.publicKeyED25519 = key => PublicKey.fromBytesED25519(key);\n\nCACHE.publicKeyECDSA = key => PublicKey.fromBytesECDSA(key);","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/PublicKey.js"],"names":["cryptography","arrayEqual","Key","CACHE","PublicKey","constructor","key","_key","fromBytes","data","fromBytesED25519","fromBytesECDSA","fromString","text","verify","message","signature","verifyTransaction","transaction","_requireFrozen","isFrozen","freeze","signedTransaction","_signedTransactions","sigMap","sigPair","found","pubKeyPrefix","toBytesRaw","bodyBytes","ed25519","ECDSASecp256k1","toBytes","toBytesDer","toString","toStringDer","toStringRaw","equals","other","_toProtobufKey","_type","Error","_toProtobufSignature","toAccountId","shard","realm","accountIdConstructor","publicKeyED25519","publicKeyECDSA"],"mappings":"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","sourcesContent":["import * as cryptography from \"@hashgraph/cryptography\";\nimport { arrayEqual } from \"./array.js\";\nimport Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\n\n/**\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IKey} proto.IKey\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignaturePair} proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n */\n\nexport default class PublicKey extends Key {\n    /**\n     * @internal\n     * @hideconstructor\n     * @param {cryptography.PublicKey} key\n     */\n    constructor(key) {\n        super();\n\n        this._key = key;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {PublicKey}\n     */\n    static fromBytes(data) {\n        return new PublicKey(cryptography.PublicKey.fromBytes(data));\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {PublicKey}\n     */\n    static fromBytesED25519(data) {\n        return new PublicKey(cryptography.PublicKey.fromBytesED25519(data));\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {PublicKey}\n     */\n    static fromBytesECDSA(data) {\n        return new PublicKey(cryptography.PublicKey.fromBytesECDSA(data));\n    }\n\n    /**\n     * Parse a public key from a string of hexadecimal digits.\n     *\n     * The public key may optionally be prefixed with\n     * the DER header.\n     *\n     * @param {string} text\n     * @returns {PublicKey}\n     */\n    static fromString(text) {\n        return new PublicKey(cryptography.PublicKey.fromString(text));\n    }\n\n    /**\n     * Verify a signature on a message with this public key.\n     *\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    verify(message, signature) {\n        return this._key.verify(message, signature);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    verifyTransaction(transaction) {\n        transaction._requireFrozen();\n\n        if (!transaction.isFrozen()) {\n            transaction.freeze();\n        }\n\n        for (const signedTransaction of transaction._signedTransactions) {\n            if (\n                signedTransaction.sigMap != null &&\n                signedTransaction.sigMap.sigPair != null\n            ) {\n                let found = false;\n                for (const sigPair of signedTransaction.sigMap.sigPair) {\n                    const pubKeyPrefix = /** @type {Uint8Array} */ (\n                        sigPair.pubKeyPrefix\n                    );\n                    if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {\n                        found = true;\n\n                        const bodyBytes = /** @type {Uint8Array} */ (\n                            signedTransaction.bodyBytes\n                        );\n\n                        let signature = null;\n                        if (sigPair.ed25519 != null) {\n                            signature = sigPair.ed25519;\n                        } else if (sigPair.ECDSASecp256k1 != null) {\n                            signature = sigPair.ECDSASecp256k1;\n                        }\n\n                        if (signature == null) {\n                            continue;\n                        }\n\n                        if (!this.verify(bodyBytes, signature)) {\n                            return false;\n                        }\n                    }\n                }\n\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return this._key.toBytes();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        return this._key.toBytesDer();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        return this._key.toBytesRaw();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this._key.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringDer() {\n        return this._key.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringRaw() {\n        return this._key.toStringRaw();\n    }\n\n    /**\n     * @param {PublicKey} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        return this._key.equals(other._key);\n    }\n\n    /**\n     * @returns {proto.IKey}\n     */\n    _toProtobufKey() {\n        switch (this._key._type) {\n            case \"ED25519\":\n                return {\n                    ed25519: this._key.toBytesRaw(),\n                };\n            case \"secp256k1\":\n                return {\n                    ECDSASecp256k1: this._key.toBytesRaw(),\n                };\n            default:\n                throw new Error(`unrecognized key type ${this._key._type}`);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} signature\n     * @returns {proto.ISignaturePair}\n     */\n    _toProtobufSignature(signature) {\n        switch (this._key._type) {\n            case \"ED25519\":\n                return {\n                    pubKeyPrefix: this._key.toBytesRaw(),\n                    ed25519: signature,\n                };\n            case \"secp256k1\":\n                return {\n                    pubKeyPrefix: this._key.toBytesRaw(),\n                    ECDSASecp256k1: signature,\n                };\n            default:\n                throw new Error(`unrecognized key type ${this._key._type}`);\n        }\n    }\n\n    /**\n     * @param {Long | number} shard\n     * @param {Long | number} realm\n     * @returns {AccountId}\n     */\n    toAccountId(shard, realm) {\n        if (CACHE.accountIdConstructor == null) {\n            throw new Error(\"`AccountId` not loaded\");\n        }\n\n        return CACHE.accountIdConstructor(shard, realm, this);\n    }\n}\n\nCACHE.publicKeyED25519 = (key) => PublicKey.fromBytesED25519(key);\nCACHE.publicKeyECDSA = (key) => PublicKey.fromBytesECDSA(key);\n"]},"metadata":{},"sourceType":"module"}