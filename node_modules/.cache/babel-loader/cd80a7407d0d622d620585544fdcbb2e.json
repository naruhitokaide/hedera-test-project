{"ast":null,"code":"import BadKeyError from \"../BadKeyError.js\";\nimport * as crypto from \"./aes.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport * as hmac from \"./hmac.js\";\nimport * as pbkdf2 from \"./pbkdf2.js\";\nimport * as random from \"./random.js\";\nconst HMAC_SHA256 = \"hmac-sha256\";\n/**\n * @typedef {Object} KeystoreKdfParams\n * @property {number} dkLen\n * @property {string} salt\n * @property {number} c\n * @property {string} prf\n */\n\n/**\n * @typedef {Object} KeystoreCipherParams\n * @property {string} iv\n */\n\n/**\n * @typedef {Object} KeystoreCrypto\n * @property {string} ciphertext\n * @property {KeystoreCipherParams} cipherparams\n * @property {string} cipher\n * @property {string} kdf\n * @property {KeystoreKdfParams} kdfparams\n * @property {string} mac\n */\n\n/**\n * @typedef {Object} Keystore\n * @property {number} version\n * @property {KeystoreCrypto} crypto\n */\n\n/**\n * @param {Uint8Array} privateKey\n * @param {string} passphrase\n * @returns {Promise<Uint8Array>}\n */\n\nexport async function createKeystore(privateKey, passphrase) {\n  // all values taken from https://github.com/ethereumjs/ethereumjs-wallet/blob/de3a92e752673ada1d78f95cf80bc56ae1f59775/src/index.ts#L25\n  const dkLen = 32;\n  const c = 262144;\n  const saltLen = 32;\n  const salt = await random.bytesAsync(saltLen);\n  const key = await pbkdf2.deriveKey(hmac.HashAlgorithm.Sha256, passphrase, salt, c, dkLen);\n  const iv = await random.bytesAsync(16); // AES-128-CTR with the first half of the derived key and a random IV\n\n  const cipherText = await crypto.createCipheriv(crypto.CipherAlgorithm.Aes128Ctr, key.slice(0, 16), iv, privateKey);\n  const mac = await hmac.hash(hmac.HashAlgorithm.Sha384, key.slice(16), cipherText);\n  /**\n   * @type {Keystore}\n   */\n\n  const keystore = {\n    version: 1,\n    crypto: {\n      ciphertext: hex.encode(cipherText),\n      cipherparams: {\n        iv: hex.encode(iv)\n      },\n      cipher: crypto.CipherAlgorithm.Aes128Ctr,\n      kdf: \"pbkdf2\",\n      kdfparams: {\n        dkLen,\n        salt: hex.encode(salt),\n        c,\n        prf: HMAC_SHA256\n      },\n      mac: hex.encode(mac)\n    }\n  };\n  return utf8.encode(JSON.stringify(keystore));\n}\n/**\n * @param {Uint8Array} keystoreBytes\n * @param {string} passphrase\n * @returns {Promise<Uint8Array>}\n */\n\nexport async function loadKeystore(keystoreBytes, passphrase) {\n  /**\n   * @type {Keystore}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const keystore = JSON.parse(utf8.decode(keystoreBytes));\n\n  if (keystore.version !== 1) {\n    throw new BadKeyError(`unsupported keystore version: ${keystore.version}`);\n  }\n\n  const {\n    ciphertext,\n    cipherparams: {\n      iv\n    },\n    cipher,\n    kdf,\n    kdfparams: {\n      dkLen,\n      salt,\n      c,\n      prf\n    },\n    mac\n  } = keystore.crypto;\n\n  if (kdf !== \"pbkdf2\") {\n    throw new BadKeyError(`unsupported key derivation function:\" + ${kdf}`);\n  }\n\n  if (prf !== HMAC_SHA256) {\n    throw new BadKeyError(`unsupported key derivation hash function: ${prf}`);\n  }\n\n  const saltBytes = hex.decode(salt);\n  const ivBytes = hex.decode(iv);\n  const cipherBytes = hex.decode(ciphertext);\n  const key = await pbkdf2.deriveKey(hmac.HashAlgorithm.Sha256, passphrase, saltBytes, c, dkLen);\n  const macHex = hex.decode(mac);\n  const verifyHmac = await hmac.hash(hmac.HashAlgorithm.Sha384, key.slice(16), cipherBytes); // compare that these two Uint8Arrays are equivalent\n\n  if (!macHex.every((b, i) => b === verifyHmac[i])) {\n    throw new BadKeyError(\"HMAC mismatch; passphrase is incorrect\");\n  }\n\n  return crypto.createDecipheriv(cipher, key.slice(0, 16), ivBytes, cipherBytes);\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/primitive/keystore.js"],"names":["BadKeyError","crypto","hex","utf8","hmac","pbkdf2","random","HMAC_SHA256","createKeystore","privateKey","passphrase","dkLen","c","saltLen","salt","bytesAsync","key","deriveKey","HashAlgorithm","Sha256","iv","cipherText","createCipheriv","CipherAlgorithm","Aes128Ctr","slice","mac","hash","Sha384","keystore","version","ciphertext","encode","cipherparams","cipher","kdf","kdfparams","prf","JSON","stringify","loadKeystore","keystoreBytes","parse","decode","saltBytes","ivBytes","cipherBytes","macHex","verifyHmac","every","b","i","createDecipheriv"],"mappings":"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","sourcesContent":["import BadKeyError from \"../BadKeyError.js\";\nimport * as crypto from \"./aes.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport * as hmac from \"./hmac.js\";\nimport * as pbkdf2 from \"./pbkdf2.js\";\nimport * as random from \"./random.js\";\n\nconst HMAC_SHA256 = \"hmac-sha256\";\n\n/**\n * @typedef {Object} KeystoreKdfParams\n * @property {number} dkLen\n * @property {string} salt\n * @property {number} c\n * @property {string} prf\n */\n\n/**\n * @typedef {Object} KeystoreCipherParams\n * @property {string} iv\n */\n\n/**\n * @typedef {Object} KeystoreCrypto\n * @property {string} ciphertext\n * @property {KeystoreCipherParams} cipherparams\n * @property {string} cipher\n * @property {string} kdf\n * @property {KeystoreKdfParams} kdfparams\n * @property {string} mac\n */\n\n/**\n * @typedef {Object} Keystore\n * @property {number} version\n * @property {KeystoreCrypto} crypto\n */\n\n/**\n * @param {Uint8Array} privateKey\n * @param {string} passphrase\n * @returns {Promise<Uint8Array>}\n */\nexport async function createKeystore(privateKey, passphrase) {\n    // all values taken from https://github.com/ethereumjs/ethereumjs-wallet/blob/de3a92e752673ada1d78f95cf80bc56ae1f59775/src/index.ts#L25\n    const dkLen = 32;\n    const c = 262144;\n    const saltLen = 32;\n    const salt = await random.bytesAsync(saltLen);\n\n    const key = await pbkdf2.deriveKey(\n        hmac.HashAlgorithm.Sha256,\n        passphrase,\n        salt,\n        c,\n        dkLen\n    );\n\n    const iv = await random.bytesAsync(16);\n\n    // AES-128-CTR with the first half of the derived key and a random IV\n    const cipherText = await crypto.createCipheriv(\n        crypto.CipherAlgorithm.Aes128Ctr,\n        key.slice(0, 16),\n        iv,\n        privateKey\n    );\n\n    const mac = await hmac.hash(\n        hmac.HashAlgorithm.Sha384,\n        key.slice(16),\n        cipherText\n    );\n\n    /**\n     * @type {Keystore}\n     */\n    const keystore = {\n        version: 1,\n        crypto: {\n            ciphertext: hex.encode(cipherText),\n            cipherparams: { iv: hex.encode(iv) },\n            cipher: crypto.CipherAlgorithm.Aes128Ctr,\n            kdf: \"pbkdf2\",\n            kdfparams: {\n                dkLen,\n                salt: hex.encode(salt),\n                c,\n                prf: HMAC_SHA256,\n            },\n            mac: hex.encode(mac),\n        },\n    };\n\n    return utf8.encode(JSON.stringify(keystore));\n}\n\n/**\n * @param {Uint8Array} keystoreBytes\n * @param {string} passphrase\n * @returns {Promise<Uint8Array>}\n */\nexport async function loadKeystore(keystoreBytes, passphrase) {\n    /**\n     * @type {Keystore}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const keystore = JSON.parse(utf8.decode(keystoreBytes));\n\n    if (keystore.version !== 1) {\n        throw new BadKeyError(\n            `unsupported keystore version: ${keystore.version}`\n        );\n    }\n\n    const {\n        ciphertext,\n        cipherparams: { iv },\n        cipher,\n        kdf,\n        kdfparams: { dkLen, salt, c, prf },\n        mac,\n    } = keystore.crypto;\n\n    if (kdf !== \"pbkdf2\") {\n        throw new BadKeyError(`unsupported key derivation function:\" + ${kdf}`);\n    }\n\n    if (prf !== HMAC_SHA256) {\n        throw new BadKeyError(\n            `unsupported key derivation hash function: ${prf}`\n        );\n    }\n\n    const saltBytes = hex.decode(salt);\n    const ivBytes = hex.decode(iv);\n    const cipherBytes = hex.decode(ciphertext);\n\n    const key = await pbkdf2.deriveKey(\n        hmac.HashAlgorithm.Sha256,\n        passphrase,\n        saltBytes,\n        c,\n        dkLen\n    );\n\n    const macHex = hex.decode(mac);\n    const verifyHmac = await hmac.hash(\n        hmac.HashAlgorithm.Sha384,\n        key.slice(16),\n        cipherBytes\n    );\n\n    // compare that these two Uint8Arrays are equivalent\n    if (!macHex.every((b, i) => b === verifyHmac[i])) {\n        throw new BadKeyError(\"HMAC mismatch; passphrase is incorrect\");\n    }\n\n    return crypto.createDecipheriv(\n        cipher,\n        key.slice(0, 16),\n        ivBytes,\n        cipherBytes\n    );\n}\n"]},"metadata":{},"sourceType":"module"}