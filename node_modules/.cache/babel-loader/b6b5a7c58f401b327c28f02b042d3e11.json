{"ast":null,"code":"import Transaction, { TRANSACTION_REGISTRY } from \"../transaction/Transaction.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport FileId from \"./FileId.js\";\nimport Key from \"../Key.js\";\nimport KeyList from \"../KeyList.js\";\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").TransactionBody} proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionResponse} proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").IFileUpdateTransactionBody} proto.IFileUpdateTransactionBody\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * Update a new Hederaâ„¢ crypto-currency file.\n */\n\nexport default class FileUpdateTransaction extends Transaction {\n  /**\n   * @param {object} props\n   * @param {FileId | string} [props.fileId]\n   * @param {Key[] | KeyList} [props.keys]\n   * @param {Timestamp | Date} [props.expirationTime]\n   * @param {Uint8Array | string} [props.contents]\n   * @param {string} [props.fileMemo]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    /**\n     * @private\n     * @type {?FileId}\n     */\n\n    this._fileId = null;\n    /**\n     * @private\n     * @type {?Key[]}\n     */\n\n    this._keys = null;\n    /**\n     * @private\n     * @type {?Timestamp}\n     */\n\n    this._expirationTime = null;\n    /**\n     * @private\n     * @type {?Uint8Array}\n     */\n\n    this._contents = null;\n    /**\n     * @private\n     * @type {?string}\n     */\n\n    this._fileMemo = null;\n\n    if (props.fileId != null) {\n      this.setFileId(props.fileId);\n    }\n\n    if (props.keys != null) {\n      this.setKeys(props.keys);\n    }\n\n    if (props.expirationTime != null) {\n      this.setExpirationTime(props.expirationTime);\n    }\n\n    if (props.contents != null) {\n      this.setContents(props.contents);\n    }\n\n    if (props.fileMemo != null) {\n      this.setFileMemo(props.fileMemo);\n    }\n  }\n  /**\n   * @internal\n   * @param {proto.ITransaction[]} transactions\n   * @param {proto.ISignedTransaction[]} signedTransactions\n   * @param {TransactionId[]} transactionIds\n   * @param {AccountId[]} nodeIds\n   * @param {proto.ITransactionBody[]} bodies\n   * @returns {FileUpdateTransaction}\n   */\n\n\n  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {\n    const body = bodies[0];\n    const update =\n    /** @type {proto.IFileUpdateTransactionBody} */\n    body.fileUpdate;\n    return Transaction._fromProtobufTransactions(new FileUpdateTransaction({\n      fileId: update.fileID != null ? FileId._fromProtobuf(update.fileID) : undefined,\n      keys: update.keys != null ? update.keys.keys != null ? update.keys.keys.map(key => Key._fromProtobufKey(key)) : undefined : undefined,\n      expirationTime: update.expirationTime != null ? Timestamp._fromProtobuf(update.expirationTime) : undefined,\n      contents: update.contents != null ? update.contents : undefined,\n      fileMemo: update.memo != null ? update.memo.value != null ? update.memo.value : undefined : undefined\n    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);\n  }\n  /**\n   * @returns {?FileId}\n   */\n\n\n  get fileId() {\n    return this._fileId;\n  }\n  /**\n   * Set the keys which must sign any transactions modifying this file. Required.\n   *\n   * All keys must sign to modify the file's contents or keys. No key is required\n   * to sign for extending the expiration time (except the one for the operator account\n   * paying for the transaction). Only one key must sign to delete the file, however.\n   *\n   * To require more than one key to sign to delete a file, add them to a\n   * KeyList and pass that here.\n   *\n   * The network currently requires a file to have at least one key (or key list or threshold key)\n   * but this requirement may be lifted in the future.\n   *\n   * @param {FileId | string} fileId\n   * @returns {this}\n   */\n\n\n  setFileId(fileId) {\n    this._requireNotFrozen();\n\n    this._fileId = typeof fileId === \"string\" ? FileId.fromString(fileId) : fileId.clone();\n    return this;\n  }\n  /**\n   * @returns {?Key[]}\n   */\n\n\n  get keys() {\n    return this._keys;\n  }\n  /**\n   * Set the keys which must sign any transactions modifying this file. Required.\n   *\n   * All keys must sign to modify the file's contents or keys. No key is required\n   * to sign for extending the expiration time (except the one for the operator account\n   * paying for the transaction). Only one key must sign to delete the file, however.\n   *\n   * To require more than one key to sign to delete a file, add them to a\n   * KeyList and pass that here.\n   *\n   * The network currently requires a file to have at least one key (or key list or threshold key)\n   * but this requirement may be lifted in the future.\n   *\n   * @param {Key[] | KeyList} keys\n   * @returns {this}\n   */\n\n\n  setKeys(keys) {\n    this._requireNotFrozen();\n\n    if (keys instanceof KeyList && keys.threshold != null) {\n      throw new Error(\"Cannot set threshold key as file key\");\n    }\n\n    this._keys = keys instanceof KeyList ? keys.toArray() : keys;\n    return this;\n  }\n  /**\n   * @returns {?Timestamp}\n   */\n\n\n  get expirationTime() {\n    return this._expirationTime;\n  }\n  /**\n   * Set the instant at which this file will expire, after which its contents will no longer be\n   * available.\n   *\n   * Defaults to 1/4 of a Julian year from the instant FileUpdateTransaction\n   * was invoked.\n   *\n   * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).\n   *\n   * @param {Timestamp | Date} expirationTime\n   * @returns {this}\n   */\n\n\n  setExpirationTime(expirationTime) {\n    this._requireNotFrozen();\n\n    this._expirationTime = expirationTime instanceof Timestamp ? expirationTime : Timestamp.fromDate(expirationTime);\n    return this;\n  }\n  /**\n   * @returns {?Uint8Array}\n   */\n\n\n  get contents() {\n    return this._contents;\n  }\n  /**\n   * Set the given byte array as the file's contents.\n   *\n   * This may be omitted to update an empty file.\n   *\n   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n   * network; if you exceed this you may receive a HederaPreCheckStatusException\n   * with Status#TransactionOversize.\n   *\n   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n   * transaction with the first chunk and then use FileAppendTransaction with\n   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n   *\n   * @param {Uint8Array | string} contents\n   * @returns {this}\n   */\n\n\n  setContents(contents) {\n    this._requireNotFrozen();\n\n    this._contents = contents instanceof Uint8Array ? contents : utf8.encode(contents);\n    return this;\n  }\n  /**\n   * @returns {?string}\n   */\n\n\n  get fileMemo() {\n    return this._fileMemo;\n  }\n  /**\n   * @param {string} memo\n   * @returns {this}\n   */\n\n\n  setFileMemo(memo) {\n    this._requireNotFrozen();\n\n    this._fileMemo = memo;\n    return this;\n  }\n  /**\n   * @returns {this}\n   */\n\n\n  clearFileMemo() {\n    this._requireNotFrozen();\n\n    this._fileMemo = null;\n    return this;\n  }\n  /**\n   * @param {Client} client\n   */\n\n\n  _validateChecksums(client) {\n    if (this._fileId != null) {\n      this._fileId.validateChecksum(client);\n    }\n  }\n  /**\n   * @override\n   * @internal\n   * @param {Channel} channel\n   * @param {proto.ITransaction} request\n   * @returns {Promise<proto.ITransactionResponse>}\n   */\n\n\n  _execute(channel, request) {\n    return channel.file.updateFile(request);\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {NonNullable<proto.TransactionBody[\"data\"]>}\n   */\n\n\n  _getTransactionDataCase() {\n    return \"fileUpdate\";\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {proto.IFileUpdateTransactionBody}\n   */\n\n\n  _makeTransactionData() {\n    return {\n      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,\n      keys: this._keys != null ? {\n        keys: this._keys.map(key => key._toProtobufKey())\n      } : null,\n      expirationTime: this._expirationTime != null ? this._expirationTime._toProtobuf() : null,\n      contents: this._contents,\n      memo: this._fileMemo != null ? {\n        value: this._fileMemo\n      } : null\n    };\n  }\n\n} // eslint-disable-next-line @typescript-eslint/unbound-method\n\nTRANSACTION_REGISTRY.set(\"fileUpdate\", FileUpdateTransaction._fromProtobuf);","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/file/FileUpdateTransaction.js"],"names":["Transaction","TRANSACTION_REGISTRY","Timestamp","utf8","FileId","Key","KeyList","FileUpdateTransaction","constructor","props","_fileId","_keys","_expirationTime","_contents","_fileMemo","fileId","setFileId","keys","setKeys","expirationTime","setExpirationTime","contents","setContents","fileMemo","setFileMemo","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","body","update","fileUpdate","_fromProtobufTransactions","fileID","undefined","map","key","_fromProtobufKey","memo","value","_requireNotFrozen","fromString","clone","threshold","Error","toArray","fromDate","Uint8Array","encode","clearFileMemo","_validateChecksums","client","validateChecksum","_execute","channel","request","file","updateFile","_getTransactionDataCase","_makeTransactionData","_toProtobuf","_toProtobufKey","set"],"mappings":"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","sourcesContent":["import Transaction, {\n    TRANSACTION_REGISTRY,\n} from \"../transaction/Transaction.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport FileId from \"./FileId.js\";\nimport Key from \"../Key.js\";\nimport KeyList from \"../KeyList.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").TransactionBody} proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionResponse} proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").IFileUpdateTransactionBody} proto.IFileUpdateTransactionBody\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * Update a new Hederaâ„¢ crypto-currency file.\n */\nexport default class FileUpdateTransaction extends Transaction {\n    /**\n     * @param {object} props\n     * @param {FileId | string} [props.fileId]\n     * @param {Key[] | KeyList} [props.keys]\n     * @param {Timestamp | Date} [props.expirationTime]\n     * @param {Uint8Array | string} [props.contents]\n     * @param {string} [props.fileMemo]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._fileId = null;\n\n        /**\n         * @private\n         * @type {?Key[]}\n         */\n        this._keys = null;\n\n        /**\n         * @private\n         * @type {?Timestamp}\n         */\n        this._expirationTime = null;\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._contents = null;\n\n        /**\n         * @private\n         * @type {?string}\n         */\n        this._fileMemo = null;\n\n        if (props.fileId != null) {\n            this.setFileId(props.fileId);\n        }\n\n        if (props.keys != null) {\n            this.setKeys(props.keys);\n        }\n\n        if (props.expirationTime != null) {\n            this.setExpirationTime(props.expirationTime);\n        }\n\n        if (props.contents != null) {\n            this.setContents(props.contents);\n        }\n\n        if (props.fileMemo != null) {\n            this.setFileMemo(props.fileMemo);\n        }\n    }\n\n    /**\n     * @internal\n     * @param {proto.ITransaction[]} transactions\n     * @param {proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {proto.ITransactionBody[]} bodies\n     * @returns {FileUpdateTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies\n    ) {\n        const body = bodies[0];\n        const update = /** @type {proto.IFileUpdateTransactionBody} */ (\n            body.fileUpdate\n        );\n\n        return Transaction._fromProtobufTransactions(\n            new FileUpdateTransaction({\n                fileId:\n                    update.fileID != null\n                        ? FileId._fromProtobuf(update.fileID)\n                        : undefined,\n                keys:\n                    update.keys != null\n                        ? update.keys.keys != null\n                            ? update.keys.keys.map((key) =>\n                                  Key._fromProtobufKey(key)\n                              )\n                            : undefined\n                        : undefined,\n                expirationTime:\n                    update.expirationTime != null\n                        ? Timestamp._fromProtobuf(update.expirationTime)\n                        : undefined,\n                contents: update.contents != null ? update.contents : undefined,\n                fileMemo:\n                    update.memo != null\n                        ? update.memo.value != null\n                            ? update.memo.value\n                            : undefined\n                        : undefined,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies\n        );\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get fileId() {\n        return this._fileId;\n    }\n\n    /**\n     * Set the keys which must sign any transactions modifying this file. Required.\n     *\n     * All keys must sign to modify the file's contents or keys. No key is required\n     * to sign for extending the expiration time (except the one for the operator account\n     * paying for the transaction). Only one key must sign to delete the file, however.\n     *\n     * To require more than one key to sign to delete a file, add them to a\n     * KeyList and pass that here.\n     *\n     * The network currently requires a file to have at least one key (or key list or threshold key)\n     * but this requirement may be lifted in the future.\n     *\n     * @param {FileId | string} fileId\n     * @returns {this}\n     */\n    setFileId(fileId) {\n        this._requireNotFrozen();\n        this._fileId =\n            typeof fileId === \"string\"\n                ? FileId.fromString(fileId)\n                : fileId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?Key[]}\n     */\n    get keys() {\n        return this._keys;\n    }\n\n    /**\n     * Set the keys which must sign any transactions modifying this file. Required.\n     *\n     * All keys must sign to modify the file's contents or keys. No key is required\n     * to sign for extending the expiration time (except the one for the operator account\n     * paying for the transaction). Only one key must sign to delete the file, however.\n     *\n     * To require more than one key to sign to delete a file, add them to a\n     * KeyList and pass that here.\n     *\n     * The network currently requires a file to have at least one key (or key list or threshold key)\n     * but this requirement may be lifted in the future.\n     *\n     * @param {Key[] | KeyList} keys\n     * @returns {this}\n     */\n    setKeys(keys) {\n        this._requireNotFrozen();\n        if (keys instanceof KeyList && keys.threshold != null) {\n            throw new Error(\"Cannot set threshold key as file key\");\n        }\n\n        this._keys = keys instanceof KeyList ? keys.toArray() : keys;\n\n        return this;\n    }\n\n    /**\n     * @returns {?Timestamp}\n     */\n    get expirationTime() {\n        return this._expirationTime;\n    }\n\n    /**\n     * Set the instant at which this file will expire, after which its contents will no longer be\n     * available.\n     *\n     * Defaults to 1/4 of a Julian year from the instant FileUpdateTransaction\n     * was invoked.\n     *\n     * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).\n     *\n     * @param {Timestamp | Date} expirationTime\n     * @returns {this}\n     */\n    setExpirationTime(expirationTime) {\n        this._requireNotFrozen();\n        this._expirationTime =\n            expirationTime instanceof Timestamp\n                ? expirationTime\n                : Timestamp.fromDate(expirationTime);\n\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get contents() {\n        return this._contents;\n    }\n\n    /**\n     * Set the given byte array as the file's contents.\n     *\n     * This may be omitted to update an empty file.\n     *\n     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n     * network; if you exceed this you may receive a HederaPreCheckStatusException\n     * with Status#TransactionOversize.\n     *\n     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n     * transaction with the first chunk and then use FileAppendTransaction with\n     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n     *\n     * @param {Uint8Array | string} contents\n     * @returns {this}\n     */\n    setContents(contents) {\n        this._requireNotFrozen();\n        this._contents =\n            contents instanceof Uint8Array ? contents : utf8.encode(contents);\n\n        return this;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    get fileMemo() {\n        return this._fileMemo;\n    }\n\n    /**\n     * @param {string} memo\n     * @returns {this}\n     */\n    setFileMemo(memo) {\n        this._requireNotFrozen();\n        this._fileMemo = memo;\n\n        return this;\n    }\n\n    /**\n     * @returns {this}\n     */\n    clearFileMemo() {\n        this._requireNotFrozen();\n        this._fileMemo = null;\n\n        return this;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    _validateChecksums(client) {\n        if (this._fileId != null) {\n            this._fileId.validateChecksum(client);\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {proto.ITransaction} request\n     * @returns {Promise<proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.file.updateFile(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"fileUpdate\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {proto.IFileUpdateTransactionBody}\n     */\n    _makeTransactionData() {\n        return {\n            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,\n            keys:\n                this._keys != null\n                    ? {\n                          keys: this._keys.map((key) => key._toProtobufKey()),\n                      }\n                    : null,\n            expirationTime:\n                this._expirationTime != null\n                    ? this._expirationTime._toProtobuf()\n                    : null,\n            contents: this._contents,\n            memo:\n                this._fileMemo != null\n                    ? {\n                          value: this._fileMemo,\n                      }\n                    : null,\n        };\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nTRANSACTION_REGISTRY.set(\"fileUpdate\", FileUpdateTransaction._fromProtobuf);\n"]},"metadata":{},"sourceType":"module"}