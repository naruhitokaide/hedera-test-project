{"ast":null,"code":"import * as cryptography from \"@hashgraph/cryptography\";\nimport Mnemonic from \"./Mnemonic.js\";\nimport PublicKey from \"./PublicKey.js\";\nimport Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\n/**\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IKey} proto.IKey\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignaturePair} proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n */\n\nexport default class PrivateKey extends Key {\n  /**\n   * @internal\n   * @hideconstructor\n   * @param {cryptography.PrivateKey} key\n   */\n  constructor(key) {\n    super();\n    this._key = key;\n  }\n  /**\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {PrivateKey}\n   */\n\n\n  static generateED25519() {\n    return new PrivateKey(cryptography.PrivateKey.generateED25519());\n  }\n  /**\n   * Generate a random EDSA private key.\n   *\n   * @returns {PrivateKey}\n   */\n\n\n  static generateECDSA() {\n    return new PrivateKey(cryptography.PrivateKey.generateECDSA());\n  }\n  /**\n   * Depredated - Use `generateEd25519()` instead\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {PrivateKey}\n   */\n\n\n  static generate() {\n    return PrivateKey.generateED25519();\n  }\n  /**\n   * Depredated - Use `generateEd25519Async()` instead\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async generateAsync() {\n    return new PrivateKey(await cryptography.PrivateKey.generateAsync());\n  }\n  /**\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async generateED25519Async() {\n    return new PrivateKey(await cryptography.PrivateKey.generateED25519Async());\n  }\n  /**\n   * Generate a random ECDSA private key.\n   *\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async generateECDSAAsync() {\n    return new PrivateKey(await cryptography.PrivateKey.generateECDSAAsync());\n  }\n  /**\n   * Construct a private key from bytes. Requires DER header.\n   *\n   * @param {Uint8Array} data\n   * @returns {PrivateKey}\n   */\n\n\n  static fromBytes(data) {\n    return new PrivateKey(cryptography.PrivateKey.fromBytes(data));\n  }\n  /**\n   * Construct a ECDSA private key from bytes.\n   *\n   * @param {Uint8Array} data\n   * @returns {PrivateKey}\n   */\n\n\n  static fromBytesECDSA(data) {\n    return new PrivateKey(cryptography.PrivateKey.fromBytesECDSA(data));\n  }\n  /**\n   * Construct a ED25519 private key from bytes.\n   *\n   * @param {Uint8Array} data\n   * @returns {PrivateKey}\n   */\n\n\n  static fromBytesED25519(data) {\n    return new PrivateKey(cryptography.PrivateKey.fromBytesED25519(data));\n  }\n  /**\n   * Construct a private key from a hex-encoded string. Requires DER header.\n   *\n   * @param {string} text\n   * @returns {PrivateKey}\n   */\n\n\n  static fromString(text) {\n    return new PrivateKey(cryptography.PrivateKey.fromString(text));\n  }\n  /**\n   * Construct a ECDSA private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {PrivateKey}\n   */\n\n\n  static fromStringECDSA(text) {\n    return new PrivateKey(cryptography.PrivateKey.fromStringECDSA(text));\n  }\n  /**\n   * Construct a Ed25519 private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {PrivateKey}\n   */\n\n\n  static fromStringED25519(text) {\n    return new PrivateKey(cryptography.PrivateKey.fromStringED25519(text));\n  }\n  /**\n   * Recover a private key from a mnemonic phrase (and optionally a password).\n   *\n   * @param {Mnemonic | cryptography.Mnemonic | string} mnemonic\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async fromMnemonic(mnemonic) {\n    let passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n\n    if (mnemonic instanceof Mnemonic) {\n      return new PrivateKey(await cryptography.PrivateKey.fromMnemonic(mnemonic._mnemonic, passphrase));\n    }\n\n    return new PrivateKey(await cryptography.PrivateKey.fromMnemonic(mnemonic, passphrase));\n  }\n  /**\n   * Recover a private key from a keystore, previously created by `.toKeystore()`.\n   *\n   * This key will _not_ support child key derivation.\n   *\n   * @param {Uint8Array} data\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.\n   */\n\n\n  static async fromKeystore(data) {\n    let passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return new PrivateKey(await cryptography.PrivateKey.fromKeystore(data, passphrase));\n  }\n  /**\n   * Recover a private key from a pem string; the private key may be encrypted.\n   *\n   * This method assumes the .pem file has been converted to a string already.\n   *\n   * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`\n   * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`\n   * section and decodes that as a DER-encoded  private key.\n   *\n   * @param {string} data\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async fromPem(data) {\n    let passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return new PrivateKey(await cryptography.PrivateKey.fromPem(data, passphrase));\n  }\n  /**\n   * Derive a new private key at the given wallet index.\n   *\n   * Only currently supported for keys created with `fromMnemonic()`; other keys will throw\n   * an error.\n   *\n   * You can check if a key supports derivation with `.supportsDerivation()`\n   *\n   * @param {number} index\n   * @returns {Promise<PrivateKey>}\n   * @throws If this key does not support derivation.\n   */\n\n\n  async derive(index) {\n    return new PrivateKey(await this._key.derive(index));\n  }\n  /**\n   * @param {number} index\n   * @returns {Promise<PrivateKey>}\n   * @throws If this key does not support derivation.\n   */\n\n\n  async legacyDerive(index) {\n    return new PrivateKey(await this._key.legacyDerive(index));\n  }\n  /**\n   * Get the public key associated with this private key.\n   *\n   * The public key can be freely given and used by other parties to verify\n   * the signatures generated by this private key.\n   *\n   * @returns {PublicKey}\n   */\n\n\n  get publicKey() {\n    return new PublicKey(this._key.publicKey);\n  }\n  /**\n   * Sign a message with this private key.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {Uint8Array} - The signature bytes without the message\n   */\n\n\n  sign(bytes) {\n    return this._key.sign(bytes);\n  }\n  /**\n   * @param {Transaction} transaction\n   * @returns {Uint8Array}\n   */\n\n\n  signTransaction(transaction) {\n    const tx = transaction._signedTransactions[0];\n    const signature = tx.bodyBytes != null ? this.sign(tx.bodyBytes) : new Uint8Array();\n    transaction.addSignature(this.publicKey, signature);\n    return signature;\n  }\n  /**\n   * Check if `derive` can be called on this private key.\n   *\n   * This is only the case if the key was created from a mnemonic.\n   *\n   * @returns {boolean}\n   */\n\n\n  isDerivable() {\n    return this._key.isDerivable();\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return this._key.toBytes();\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesDer() {\n    return this._key.toBytesDer();\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesRaw() {\n    return this._key.toBytesRaw();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    return this._key.toStringDer();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toStringDer() {\n    return this._key.toStringDer();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toStringRaw() {\n    return this._key.toStringRaw();\n  }\n  /**\n   * Create a keystore with a given passphrase.\n   *\n   * The key can be recovered later with `fromKeystore()`.\n   *\n   * Note that this will not retain the ancillary data used for\n   * deriving child keys, thus `.derive()` on the restored key will\n   * throw even if this instance supports derivation.\n   *\n   * @param {string} [passphrase]\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  toKeystore() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return this._key.toKeystore(passphrase);\n  }\n  /**\n   * @returns {proto.IKey}\n   */\n\n\n  _toProtobufKey() {\n    return this.publicKey._toProtobufKey();\n  }\n  /**\n   * @param {Long | number} shard\n   * @param {Long | number} realm\n   * @returns {AccountId}\n   */\n\n\n  toAccountId(shard, realm) {\n    return this.publicKey.toAccountId(shard, realm);\n  }\n\n}\n\nCACHE.privateKeyConstructor = key => new PrivateKey(key);","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/PrivateKey.js"],"names":["cryptography","Mnemonic","PublicKey","Key","CACHE","PrivateKey","constructor","key","_key","generateED25519","generateECDSA","generate","generateAsync","generateED25519Async","generateECDSAAsync","fromBytes","data","fromBytesECDSA","fromBytesED25519","fromString","text","fromStringECDSA","fromStringED25519","fromMnemonic","mnemonic","passphrase","_mnemonic","fromKeystore","fromPem","derive","index","legacyDerive","publicKey","sign","bytes","signTransaction","transaction","tx","_signedTransactions","signature","bodyBytes","Uint8Array","addSignature","isDerivable","toBytes","toBytesDer","toBytesRaw","toString","toStringDer","toStringRaw","toKeystore","_toProtobufKey","toAccountId","shard","realm","privateKeyConstructor"],"mappings":"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","sourcesContent":["import * as cryptography from \"@hashgraph/cryptography\";\nimport Mnemonic from \"./Mnemonic.js\";\nimport PublicKey from \"./PublicKey.js\";\nimport Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\n\n/**\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IKey} proto.IKey\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignaturePair} proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n */\n\nexport default class PrivateKey extends Key {\n    /**\n     * @internal\n     * @hideconstructor\n     * @param {cryptography.PrivateKey} key\n     */\n    constructor(key) {\n        super();\n\n        this._key = key;\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generateED25519() {\n        return new PrivateKey(cryptography.PrivateKey.generateED25519());\n    }\n\n    /**\n     * Generate a random EDSA private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generateECDSA() {\n        return new PrivateKey(cryptography.PrivateKey.generateECDSA());\n    }\n\n    /**\n     * Depredated - Use `generateEd25519()` instead\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generate() {\n        return PrivateKey.generateED25519();\n    }\n\n    /**\n     * Depredated - Use `generateEd25519Async()` instead\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateAsync() {\n        return new PrivateKey(await cryptography.PrivateKey.generateAsync());\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateED25519Async() {\n        return new PrivateKey(\n            await cryptography.PrivateKey.generateED25519Async()\n        );\n    }\n\n    /**\n     * Generate a random ECDSA private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateECDSAAsync() {\n        return new PrivateKey(\n            await cryptography.PrivateKey.generateECDSAAsync()\n        );\n    }\n\n    /**\n     * Construct a private key from bytes. Requires DER header.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytes(data) {\n        return new PrivateKey(cryptography.PrivateKey.fromBytes(data));\n    }\n\n    /**\n     * Construct a ECDSA private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytesECDSA(data) {\n        return new PrivateKey(cryptography.PrivateKey.fromBytesECDSA(data));\n    }\n\n    /**\n     * Construct a ED25519 private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytesED25519(data) {\n        return new PrivateKey(cryptography.PrivateKey.fromBytesED25519(data));\n    }\n\n    /**\n     * Construct a private key from a hex-encoded string. Requires DER header.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromString(text) {\n        return new PrivateKey(cryptography.PrivateKey.fromString(text));\n    }\n\n    /**\n     * Construct a ECDSA private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringECDSA(text) {\n        return new PrivateKey(cryptography.PrivateKey.fromStringECDSA(text));\n    }\n\n    /**\n     * Construct a Ed25519 private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringED25519(text) {\n        return new PrivateKey(cryptography.PrivateKey.fromStringED25519(text));\n    }\n\n    /**\n     * Recover a private key from a mnemonic phrase (and optionally a password).\n     *\n     * @param {Mnemonic | cryptography.Mnemonic | string} mnemonic\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromMnemonic(mnemonic, passphrase = \"\") {\n        if (mnemonic instanceof Mnemonic) {\n            return new PrivateKey(\n                await cryptography.PrivateKey.fromMnemonic(\n                    mnemonic._mnemonic,\n                    passphrase\n                )\n            );\n        }\n\n        return new PrivateKey(\n            await cryptography.PrivateKey.fromMnemonic(mnemonic, passphrase)\n        );\n    }\n\n    /**\n     * Recover a private key from a keystore, previously created by `.toKeystore()`.\n     *\n     * This key will _not_ support child key derivation.\n     *\n     * @param {Uint8Array} data\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.\n     */\n    static async fromKeystore(data, passphrase = \"\") {\n        return new PrivateKey(\n            await cryptography.PrivateKey.fromKeystore(data, passphrase)\n        );\n    }\n\n    /**\n     * Recover a private key from a pem string; the private key may be encrypted.\n     *\n     * This method assumes the .pem file has been converted to a string already.\n     *\n     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`\n     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`\n     * section and decodes that as a DER-encoded  private key.\n     *\n     * @param {string} data\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromPem(data, passphrase = \"\") {\n        return new PrivateKey(\n            await cryptography.PrivateKey.fromPem(data, passphrase)\n        );\n    }\n\n    /**\n     * Derive a new private key at the given wallet index.\n     *\n     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw\n     * an error.\n     *\n     * You can check if a key supports derivation with `.supportsDerivation()`\n     *\n     * @param {number} index\n     * @returns {Promise<PrivateKey>}\n     * @throws If this key does not support derivation.\n     */\n    async derive(index) {\n        return new PrivateKey(await this._key.derive(index));\n    }\n\n    /**\n     * @param {number} index\n     * @returns {Promise<PrivateKey>}\n     * @throws If this key does not support derivation.\n     */\n    async legacyDerive(index) {\n        return new PrivateKey(await this._key.legacyDerive(index));\n    }\n\n    /**\n     * Get the public key associated with this private key.\n     *\n     * The public key can be freely given and used by other parties to verify\n     * the signatures generated by this private key.\n     *\n     * @returns {PublicKey}\n     */\n    get publicKey() {\n        return new PublicKey(this._key.publicKey);\n    }\n\n    /**\n     * Sign a message with this private key.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {Uint8Array} - The signature bytes without the message\n     */\n    sign(bytes) {\n        return this._key.sign(bytes);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {Uint8Array}\n     */\n    signTransaction(transaction) {\n        const tx = transaction._signedTransactions[0];\n        const signature =\n            tx.bodyBytes != null ? this.sign(tx.bodyBytes) : new Uint8Array();\n\n        transaction.addSignature(this.publicKey, signature);\n\n        return signature;\n    }\n\n    /**\n     * Check if `derive` can be called on this private key.\n     *\n     * This is only the case if the key was created from a mnemonic.\n     *\n     * @returns {boolean}\n     */\n    isDerivable() {\n        return this._key.isDerivable();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return this._key.toBytes();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        return this._key.toBytesDer();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        return this._key.toBytesRaw();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this._key.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringDer() {\n        return this._key.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringRaw() {\n        return this._key.toStringRaw();\n    }\n\n    /**\n     * Create a keystore with a given passphrase.\n     *\n     * The key can be recovered later with `fromKeystore()`.\n     *\n     * Note that this will not retain the ancillary data used for\n     * deriving child keys, thus `.derive()` on the restored key will\n     * throw even if this instance supports derivation.\n     *\n     * @param {string} [passphrase]\n     * @returns {Promise<Uint8Array>}\n     */\n    toKeystore(passphrase = \"\") {\n        return this._key.toKeystore(passphrase);\n    }\n\n    /**\n     * @returns {proto.IKey}\n     */\n    _toProtobufKey() {\n        return this.publicKey._toProtobufKey();\n    }\n\n    /**\n     * @param {Long | number} shard\n     * @param {Long | number} realm\n     * @returns {AccountId}\n     */\n    toAccountId(shard, realm) {\n        return this.publicKey.toAccountId(shard, realm);\n    }\n}\n\nCACHE.privateKeyConstructor = (key) => new PrivateKey(key);\n"]},"metadata":{},"sourceType":"module"}