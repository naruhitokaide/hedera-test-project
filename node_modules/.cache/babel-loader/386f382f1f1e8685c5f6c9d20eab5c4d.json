{"ast":null,"code":"/**\n * @typedef {Object} AsnSeq\n * @property {AsnType[]} seq\n */\n\n/**\n * @typedef {Object} AsnInt\n * @property {number} int\n */\n\n/**\n * @typedef {Object} AsnBytes\n * @property {Uint8Array} bytes\n */\n\n/**\n * @typedef {Object} AsnIdent\n * @property {string} ident\n */\n\n/**\n * @typedef {{}} AsnNull\n */\n\n/**\n * @typedef {AsnSeq | AsnInt | AsnBytes | AsnIdent | AsnNull} AsnType\n */\n\n/**\n * Note: may throw weird errors on malformed input. Catch and rethrow with, e.g. `BadKeyError`.\n *\n *@param {Uint8Array} data\n *@returns {AsnType}\n */\nexport function decode(data) {\n  return decodeIncremental(data)[0];\n}\n/**\n * @param {Uint8Array} bytes\n * @returns {[AsnType, Uint8Array]}\n */\n\nfunction decodeIncremental(bytes) {\n  // slice off the initial tag byte, `decodeLength` returns a slice of the remaining data\n  const [len, rem] = decodeLength(bytes.subarray(1));\n  const data = rem.subarray(0, len);\n  const tail = rem.subarray(len);\n\n  switch (bytes[0]) {\n    case 2:\n      return [{\n        int: decodeInt(data)\n      }, tail];\n\n    case 4:\n      // must always be primitive form in DER; for OCTET STRING this is literal bytes\n      return [{\n        bytes: data\n      }, tail];\n\n    case 5:\n      // empty\n      return [{}, tail];\n\n    case 6:\n      return [{\n        ident: decodeObjectIdent(data)\n      }, tail];\n\n    case 48:\n      return [{\n        seq: decodeSeq(data)\n      }, tail];\n\n    default:\n      throw new Error(`unsupported DER type tag: ${bytes[0]}`);\n  }\n}\n/**\n * @param {Uint8Array} seqBytes\n * @returns {AsnType[]}\n */\n\n\nfunction decodeSeq(seqBytes) {\n  let data = seqBytes;\n  const seq = [];\n\n  while (data.length !== 0) {\n    const [decoded, remaining] = decodeIncremental(data);\n    seq.push(decoded);\n    data = remaining;\n  }\n\n  return seq;\n}\n/**\n * @param {Uint8Array} idBytes\n * @returns {string}\n */\n\n\nfunction decodeObjectIdent(idBytes) {\n  const id = [// first octet is 40 * value1 + value2\n  Math.floor(idBytes[0] / 40), idBytes[0] % 40]; // each following ID component is big-endian base128 where the MSB is set if another byte\n  // follows for the same value\n\n  let val = 0;\n\n  for (const byte of idBytes.subarray(1)) {\n    // shift the entire value left by 7 bits\n    val *= 128;\n\n    if (byte < 128) {\n      // no more octets follow for this value, finish it off\n      val += byte;\n      id.push(val);\n      val = 0;\n    } else {\n      // zero the MSB\n      val += byte & 127;\n    }\n  }\n\n  return id.join(\".\");\n}\n/**\n * @param {Uint8Array} lenBytes\n * @returns {[number, Uint8Array]}\n */\n\n\nfunction decodeLength(lenBytes) {\n  if (lenBytes[0] < 128) {\n    // definite, short form\n    return [lenBytes[0], lenBytes.subarray(1)];\n  }\n\n  const numBytes = lenBytes[0] - 128;\n  const intBytes = lenBytes.subarray(1, numBytes + 1);\n  const rem = lenBytes.subarray(numBytes + 1);\n  return [decodeInt(intBytes), rem];\n}\n/**\n * @param {Uint8Array} intBytes\n * @returns {number}\n */\n\n\nfunction decodeInt(intBytes) {\n  const len = intBytes.length;\n\n  if (len === 1) {\n    return intBytes[0];\n  }\n\n  let view = new DataView(intBytes.buffer, intBytes.byteOffset, intBytes.byteLength);\n  if (len === 2) return view.getUint16(0, false);\n\n  if (len === 3) {\n    // prefix a zero byte and we'll treat it as a 32-bit int\n    const data = Uint8Array.of(0, ...intBytes);\n    view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  }\n\n  if (len > 4) {\n    // this probably means a bug in the decoding as this would mean a >4GB structure\n    throw new Error(`unsupported DER integer length of ${len} bytes`);\n  }\n\n  return view.getUint32(0, false);\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/encoding/der.js"],"names":["decode","data","decodeIncremental","bytes","len","rem","decodeLength","subarray","tail","int","decodeInt","ident","decodeObjectIdent","seq","decodeSeq","Error","seqBytes","length","decoded","remaining","push","idBytes","id","Math","floor","val","byte","join","lenBytes","numBytes","intBytes","view","DataView","buffer","byteOffset","byteLength","getUint16","Uint8Array","of","getUint32"],"mappings":"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","sourcesContent":["/**\n * @typedef {Object} AsnSeq\n * @property {AsnType[]} seq\n */\n\n/**\n * @typedef {Object} AsnInt\n * @property {number} int\n */\n\n/**\n * @typedef {Object} AsnBytes\n * @property {Uint8Array} bytes\n */\n\n/**\n * @typedef {Object} AsnIdent\n * @property {string} ident\n */\n\n/**\n * @typedef {{}} AsnNull\n */\n\n/**\n * @typedef {AsnSeq | AsnInt | AsnBytes | AsnIdent | AsnNull} AsnType\n */\n\n/**\n * Note: may throw weird errors on malformed input. Catch and rethrow with, e.g. `BadKeyError`.\n *\n *@param {Uint8Array} data\n *@returns {AsnType}\n */\nexport function decode(data) {\n    return decodeIncremental(data)[0];\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {[AsnType, Uint8Array]}\n */\nfunction decodeIncremental(bytes) {\n    // slice off the initial tag byte, `decodeLength` returns a slice of the remaining data\n    const [len, rem] = decodeLength(bytes.subarray(1));\n    const data = rem.subarray(0, len);\n    const tail = rem.subarray(len);\n\n    switch (bytes[0]) {\n        case 2:\n            return [{ int: decodeInt(data) }, tail];\n        case 4: // must always be primitive form in DER; for OCTET STRING this is literal bytes\n            return [{ bytes: data }, tail];\n        case 5: // empty\n            return [{}, tail];\n        case 6:\n            return [{ ident: decodeObjectIdent(data) }, tail];\n        case 48:\n            return [{ seq: decodeSeq(data) }, tail];\n        default:\n            throw new Error(`unsupported DER type tag: ${bytes[0]}`);\n    }\n}\n\n/**\n * @param {Uint8Array} seqBytes\n * @returns {AsnType[]}\n */\nfunction decodeSeq(seqBytes) {\n    let data = seqBytes;\n\n    const seq = [];\n\n    while (data.length !== 0) {\n        const [decoded, remaining] = decodeIncremental(data);\n        seq.push(decoded);\n        data = remaining;\n    }\n\n    return seq;\n}\n\n/**\n * @param {Uint8Array} idBytes\n * @returns {string}\n */\nfunction decodeObjectIdent(idBytes) {\n    const id = [\n        // first octet is 40 * value1 + value2\n        Math.floor(idBytes[0] / 40),\n        idBytes[0] % 40,\n    ];\n\n    // each following ID component is big-endian base128 where the MSB is set if another byte\n    // follows for the same value\n    let val = 0;\n\n    for (const byte of idBytes.subarray(1)) {\n        // shift the entire value left by 7 bits\n        val *= 128;\n\n        if (byte < 128) {\n            // no more octets follow for this value, finish it off\n            val += byte;\n            id.push(val);\n            val = 0;\n        } else {\n            // zero the MSB\n            val += byte & 127;\n        }\n    }\n\n    return id.join(\".\");\n}\n\n/**\n * @param {Uint8Array} lenBytes\n * @returns {[number, Uint8Array]}\n */\nfunction decodeLength(lenBytes) {\n    if (lenBytes[0] < 128) {\n        // definite, short form\n        return [lenBytes[0], lenBytes.subarray(1)];\n    }\n\n    const numBytes = lenBytes[0] - 128;\n\n    const intBytes = lenBytes.subarray(1, numBytes + 1);\n    const rem = lenBytes.subarray(numBytes + 1);\n\n    return [decodeInt(intBytes), rem];\n}\n\n/**\n * @param {Uint8Array} intBytes\n * @returns {number}\n */\nfunction decodeInt(intBytes) {\n    const len = intBytes.length;\n    if (len === 1) {\n        return intBytes[0];\n    }\n\n    let view = new DataView(\n        intBytes.buffer,\n        intBytes.byteOffset,\n        intBytes.byteLength\n    );\n\n    if (len === 2) return view.getUint16(0, false);\n\n    if (len === 3) {\n        // prefix a zero byte and we'll treat it as a 32-bit int\n        const data = Uint8Array.of(0, ...intBytes);\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    }\n\n    if (len > 4) {\n        // this probably means a bug in the decoding as this would mean a >4GB structure\n        throw new Error(`unsupported DER integer length of ${len} bytes`);\n    }\n\n    return view.getUint32(0, false);\n}\n"]},"metadata":{},"sourceType":"module"}