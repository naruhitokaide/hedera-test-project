{"ast":null,"code":"import AccountId from \"../account/AccountId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as proto from \"@hashgraph/proto\";\nimport Long from \"long\";\n/**\n * The client-generated ID for a transaction.\n *\n * This is used for retrieving receipts and records for a transaction, for appending to a file\n * right after creating it, for instantiating a smart contract with bytecode in a file just created,\n * and internally by the network for detecting when duplicate transactions are submitted.\n */\n\nexport default class TransactionId {\n  /**\n   * Don't use this method directly.\n   * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.\n   *\n   * @param {?AccountId} accountId\n   * @param {?Timestamp} validStart\n   * @param {?boolean} scheduled\n   * @param {?Long | number} nonce\n   */\n  constructor(accountId, validStart) {\n    let scheduled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let nonce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    /**\n     * The Account ID that paid for this transaction.\n     *\n     * @readonly\n     */\n    this.accountId = accountId;\n    /**\n     * The time from when this transaction is valid.\n     *\n     * When a transaction is submitted there is additionally a validDuration (defaults to 120s)\n     * and together they define a time window that a transaction may be processed in.\n     *\n     * @readonly\n     */\n\n    this.validStart = validStart;\n    this.scheduled = scheduled;\n    this.nonce = null;\n\n    if (nonce != null) {\n      this.setNonce(nonce);\n    }\n\n    Object.freeze(this);\n  }\n  /**\n   * @param {Long | number} nonce\n   * @returns {TransactionId}\n   */\n\n\n  setNonce(nonce) {\n    this.nonce = typeof nonce === \"number\" ? Long.fromNumber(nonce) : nonce;\n    return this;\n  }\n  /**\n   * @param {AccountId} accountId\n   * @param {Timestamp} validStart\n   * @returns {TransactionId}\n   */\n\n\n  static withValidStart(accountId, validStart) {\n    return new TransactionId(accountId, validStart, null);\n  }\n  /**\n   * Generates a new transaction ID for the given account ID.\n   *\n   * Note that transaction IDs are made of the valid start of the transaction and the account\n   * that will be charged the transaction fees for the transaction.\n   *\n   * @param {AccountId | string} id\n   * @returns {TransactionId}\n   */\n\n\n  static generate(id) {\n    return new TransactionId(typeof id === \"string\" ? AccountId.fromString(id) : new AccountId(id), Timestamp.generate());\n  }\n  /**\n   * @param {string} wholeId\n   * @returns {TransactionId}\n   */\n\n\n  static fromString(wholeId) {\n    let account, seconds, nanos, isScheduled, nonce;\n    let rest; // 1.1.1@5.4?scheduled/117\n\n    [account, rest] = wholeId.split(\"@\");\n    [seconds, rest] = rest.split(\".\");\n\n    if (rest.includes(\"?\")) {\n      [nanos, rest] = rest.split(\"?scheduled\");\n      isScheduled = true;\n\n      if (rest.includes(\"/\")) {\n        nonce = rest.replace(\"/\", \"\");\n      } else {\n        nonce = null;\n      }\n    } else if (rest.includes(\"/\")) {\n      [nanos, nonce] = rest.split(\"/\");\n      isScheduled = false;\n    } else {\n      nanos = rest;\n    }\n\n    return new TransactionId(AccountId.fromString(account), new Timestamp(Long.fromValue(seconds), Long.fromValue(nanos)), isScheduled, nonce != null ? Long.fromString(nonce) : null);\n  }\n  /**\n   * @param {boolean} scheduled\n   * @returns {this}\n   */\n\n\n  setScheduled(scheduled) {\n    this.scheduled = scheduled;\n    return this;\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    if (this.accountId != null && this.validStart != null) {\n      const nonce = this.nonce != null ? \"/\".concat(this.nonce.toString()) : \"\";\n      const scheduled = this.scheduled ? \"?scheduled\" : \"\";\n      return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${this.validStart.nanos.toString()}${scheduled}${nonce}`;\n    } else {\n      throw new Error(\"neither `accountId` nor `validStart` are set\");\n    }\n  }\n  /**\n   * @internal\n   * @param {proto.ITransactionID} id\n   * @returns {TransactionId}\n   */\n\n\n  static _fromProtobuf(id) {\n    if (id.accountID != null && id.transactionValidStart != null) {\n      return new TransactionId(AccountId._fromProtobuf(id.accountID), Timestamp._fromProtobuf(id.transactionValidStart), id.scheduled, id.nonce);\n    } else {\n      throw new Error(\"Neither `nonce` or `accountID` and `transactionValidStart` are set\");\n    }\n  }\n  /**\n   * @internal\n   * @returns {proto.ITransactionID}\n   */\n\n\n  _toProtobuf() {\n    return {\n      accountID: this.accountId != null ? this.accountId._toProtobuf() : null,\n      transactionValidStart: this.validStart != null ? this.validStart._toProtobuf() : null,\n      scheduled: this.scheduled,\n      nonce: this.nonce != null ? this.nonce.toInt() : null\n    };\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {TransactionId}\n   */\n\n\n  static fromBytes(bytes) {\n    return TransactionId._fromProtobuf(proto.TransactionID.decode(bytes));\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return proto.TransactionID.encode(this._toProtobuf()).finish();\n  }\n  /**\n   * @returns {TransactionId}\n   */\n\n\n  clone() {\n    return new TransactionId(this.accountId, this.validStart, this.scheduled, this.nonce);\n  }\n  /**\n   * @param {TransactionId} other\n   * @returns {number}\n   */\n\n\n  compare(other) {\n    const comparison =\n    /** @type {AccountId} */\n    this.accountId.compare(\n    /** @type {AccountId} */\n    other.accountId);\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    return (\n      /** @type {Timestamp} */\n      this.validStart.compare(\n      /** @type {Timestamp} */\n      other.validStart)\n    );\n  }\n\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/transaction/TransactionId.js"],"names":["AccountId","Timestamp","proto","Long","TransactionId","constructor","accountId","validStart","scheduled","nonce","setNonce","Object","freeze","fromNumber","withValidStart","generate","id","fromString","wholeId","account","seconds","nanos","isScheduled","rest","split","includes","replace","fromValue","setScheduled","toString","concat","Error","_fromProtobuf","accountID","transactionValidStart","_toProtobuf","toInt","fromBytes","bytes","TransactionID","decode","toBytes","encode","finish","clone","compare","other","comparison"],"mappings":"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","sourcesContent":["import AccountId from \"../account/AccountId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as proto from \"@hashgraph/proto\";\nimport Long from \"long\";\n\n/**\n * The client-generated ID for a transaction.\n *\n * This is used for retrieving receipts and records for a transaction, for appending to a file\n * right after creating it, for instantiating a smart contract with bytecode in a file just created,\n * and internally by the network for detecting when duplicate transactions are submitted.\n */\nexport default class TransactionId {\n    /**\n     * Don't use this method directly.\n     * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.\n     *\n     * @param {?AccountId} accountId\n     * @param {?Timestamp} validStart\n     * @param {?boolean} scheduled\n     * @param {?Long | number} nonce\n     */\n    constructor(accountId, validStart, scheduled = false, nonce = null) {\n        /**\n         * The Account ID that paid for this transaction.\n         *\n         * @readonly\n         */\n        this.accountId = accountId;\n\n        /**\n         * The time from when this transaction is valid.\n         *\n         * When a transaction is submitted there is additionally a validDuration (defaults to 120s)\n         * and together they define a time window that a transaction may be processed in.\n         *\n         * @readonly\n         */\n        this.validStart = validStart;\n\n        this.scheduled = scheduled;\n\n        this.nonce = null;\n        if (nonce != null) {\n            this.setNonce(nonce);\n        }\n\n        Object.freeze(this);\n    }\n\n    /**\n     * @param {Long | number} nonce\n     * @returns {TransactionId}\n     */\n    setNonce(nonce) {\n        this.nonce = typeof nonce === \"number\" ? Long.fromNumber(nonce) : nonce;\n        return this;\n    }\n\n    /**\n     * @param {AccountId} accountId\n     * @param {Timestamp} validStart\n     * @returns {TransactionId}\n     */\n    static withValidStart(accountId, validStart) {\n        return new TransactionId(accountId, validStart, null);\n    }\n\n    /**\n     * Generates a new transaction ID for the given account ID.\n     *\n     * Note that transaction IDs are made of the valid start of the transaction and the account\n     * that will be charged the transaction fees for the transaction.\n     *\n     * @param {AccountId | string} id\n     * @returns {TransactionId}\n     */\n    static generate(id) {\n        return new TransactionId(\n            typeof id === \"string\"\n                ? AccountId.fromString(id)\n                : new AccountId(id),\n            Timestamp.generate()\n        );\n    }\n\n    /**\n     * @param {string} wholeId\n     * @returns {TransactionId}\n     */\n    static fromString(wholeId) {\n        let account, seconds, nanos, isScheduled, nonce;\n        let rest;\n        // 1.1.1@5.4?scheduled/117\n\n        [account, rest] = wholeId.split(\"@\");\n        [seconds, rest] = rest.split(\".\");\n        if (rest.includes(\"?\")) {\n            [nanos, rest] = rest.split(\"?scheduled\");\n            isScheduled = true;\n            if (rest.includes(\"/\")) {\n                nonce = rest.replace(\"/\", \"\");\n            } else {\n                nonce = null;\n            }\n        } else if (rest.includes(\"/\")) {\n            [nanos, nonce] = rest.split(\"/\");\n            isScheduled = false;\n        } else {\n            nanos = rest;\n        }\n\n        return new TransactionId(\n            AccountId.fromString(account),\n            new Timestamp(Long.fromValue(seconds), Long.fromValue(nanos)),\n            isScheduled,\n            nonce != null ? Long.fromString(nonce) : null\n        );\n    }\n\n    /**\n     * @param {boolean} scheduled\n     * @returns {this}\n     */\n    setScheduled(scheduled) {\n        this.scheduled = scheduled;\n        return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        if (this.accountId != null && this.validStart != null) {\n            const nonce =\n                this.nonce != null ? \"/\".concat(this.nonce.toString()) : \"\";\n            const scheduled = this.scheduled ? \"?scheduled\" : \"\";\n            return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${this.validStart.nanos.toString()}${scheduled}${nonce}`;\n        } else {\n            throw new Error(\"neither `accountId` nor `validStart` are set\");\n        }\n    }\n\n    /**\n     * @internal\n     * @param {proto.ITransactionID} id\n     * @returns {TransactionId}\n     */\n    static _fromProtobuf(id) {\n        if (id.accountID != null && id.transactionValidStart != null) {\n            return new TransactionId(\n                AccountId._fromProtobuf(id.accountID),\n                Timestamp._fromProtobuf(id.transactionValidStart),\n                id.scheduled,\n                id.nonce\n            );\n        } else {\n            throw new Error(\n                \"Neither `nonce` or `accountID` and `transactionValidStart` are set\"\n            );\n        }\n    }\n\n    /**\n     * @internal\n     * @returns {proto.ITransactionID}\n     */\n    _toProtobuf() {\n        return {\n            accountID:\n                this.accountId != null ? this.accountId._toProtobuf() : null,\n            transactionValidStart:\n                this.validStart != null ? this.validStart._toProtobuf() : null,\n            scheduled: this.scheduled,\n            nonce: this.nonce != null ? this.nonce.toInt() : null,\n        };\n    }\n\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionId}\n     */\n    static fromBytes(bytes) {\n        return TransactionId._fromProtobuf(proto.TransactionID.decode(bytes));\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return proto.TransactionID.encode(this._toProtobuf()).finish();\n    }\n\n    /**\n     * @returns {TransactionId}\n     */\n    clone() {\n        return new TransactionId(\n            this.accountId,\n            this.validStart,\n            this.scheduled,\n            this.nonce\n        );\n    }\n\n    /**\n     * @param {TransactionId} other\n     * @returns {number}\n     */\n    compare(other) {\n        const comparison = /** @type {AccountId} */ (this.accountId).compare(\n            /** @type {AccountId} */ (other.accountId)\n        );\n\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        return /** @type {Timestamp} */ (this.validStart).compare(\n            /** @type {Timestamp} */ (other.validStart)\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}