{"ast":null,"code":"import Mnemonic from \"./Mnemonic.js\";\nimport BadKeyError from \"./BadKeyError.js\";\nimport Key from \"./Key.js\";\nimport Ed25519PrivateKey from \"./Ed25519PrivateKey.js\";\nimport EcdsaPrivateKey from \"./EcdsaPrivateKey.js\";\nimport PublicKey from \"./PublicKey.js\";\nimport { createKeystore, loadKeystore } from \"./primitive/keystore.js\";\nimport { read as readPem } from \"./encoding/pem.js\";\nimport * as hex from \"./encoding/hex.js\";\nimport * as slip10 from \"./primitive/slip10.js\";\nimport * as derive from \"./util/derive.js\";\n/**\n * @typedef {object} ProtoSignaturePair\n * @property {(Uint8Array | null)=} pubKeyPrefix\n * @property {(Uint8Array | null)=} ed25519\n * @property {(Uint8Array | null)=} ECDSASecp256k1\n */\n\n/**\n * @typedef {object} ProtoSigMap\n * @property {(ProtoSignaturePair[] | null)=} sigPair\n */\n\n/**\n * @typedef {object} ProtoSignedTransaction\n * @property {(Uint8Array | null)=} bodyBytes\n * @property {(ProtoSigMap | null)=} sigMap\n */\n\n/**\n * @typedef {object} Transaction\n * @property {() => boolean} isFrozen\n * @property {ProtoSignedTransaction[]} _signedTransactions\n * @property {Set<string>} _signerPublicKeys\n * @property {(publicKey: PublicKey, signature: Uint8Array) => Transaction} addSignature\n * @property {() => void} _requireFrozen\n * @property {() => Transaction} freeze\n */\n\n/**\n * A private key on the Hedera™ network.\n */\n\nexport default class PrivateKey extends Key {\n  /**\n   * @hideconstructor\n   * @internal\n   * @param {Ed25519PrivateKey | EcdsaPrivateKey} key\n   */\n  constructor(key) {\n    super();\n    /**\n     * @type {Ed25519PrivateKey | EcdsaPrivateKey}\n     * @readonly\n     * @private\n     */\n\n    this._key = key;\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  get _type() {\n    return this._key._type;\n  }\n  /**\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {PrivateKey}\n   */\n\n\n  static generateED25519() {\n    return new PrivateKey(Ed25519PrivateKey.generate());\n  }\n  /**\n   * Generate a random EDSA private key.\n   *\n   * @returns {PrivateKey}\n   */\n\n\n  static generateECDSA() {\n    return new PrivateKey(EcdsaPrivateKey.generate());\n  }\n  /**\n   * Depredated - Use `generateEd25519()` instead\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {PrivateKey}\n   */\n\n\n  static generate() {\n    return PrivateKey.generateED25519();\n  }\n  /**\n   * Depredated - Use `generateEd25519Async()` instead\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async generateAsync() {\n    return PrivateKey.generateED25519Async();\n  }\n  /**\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async generateED25519Async() {\n    return new PrivateKey(await Ed25519PrivateKey.generateAsync());\n  }\n  /**\n   * Generate a random ECDSA private key.\n   *\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async generateECDSAAsync() {\n    return new PrivateKey(await EcdsaPrivateKey.generateAsync());\n  }\n  /**\n   * Construct a private key from bytes. Requires DER header.\n   *\n   * @param {Uint8Array} data\n   * @returns {PrivateKey}\n   */\n\n\n  static fromBytes(data) {\n    try {\n      return new PrivateKey(Ed25519PrivateKey.fromBytes(data));\n    } catch {// Do nothing\n    }\n\n    try {\n      return new PrivateKey(EcdsaPrivateKey.fromBytes(data));\n    } catch {// Do nothing\n    }\n\n    throw new BadKeyError(`invalid private key length: ${data.length} bytes`);\n  }\n  /**\n   * Construct a ECDSA private key from bytes.\n   *\n   * @param {Uint8Array} data\n   * @returns {PrivateKey}\n   */\n\n\n  static fromBytesECDSA(data) {\n    return new PrivateKey(EcdsaPrivateKey.fromBytes(data));\n  }\n  /**\n   * Construct a ED25519 private key from bytes.\n   *\n   * @param {Uint8Array} data\n   * @returns {PrivateKey}\n   */\n\n\n  static fromBytesED25519(data) {\n    return new PrivateKey(Ed25519PrivateKey.fromBytes(data));\n  }\n  /**\n   * Construct a private key from a hex-encoded string. Requires DER header.\n   *\n   * @param {string} text\n   * @returns {PrivateKey}\n   */\n\n\n  static fromString(text) {\n    return PrivateKey.fromBytes(hex.decode(text));\n  }\n  /**\n   * Construct a ECDSA private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {PrivateKey}\n   */\n\n\n  static fromStringECDSA(text) {\n    return PrivateKey.fromBytesECDSA(hex.decode(text));\n  }\n  /**\n   * Construct a Ed25519 private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {PrivateKey}\n   */\n\n\n  static fromStringED25519(text) {\n    return PrivateKey.fromBytesED25519(hex.decode(text));\n  }\n  /**\n   * Recover a private key from a mnemonic phrase (and optionally a password).\n   *\n   * @param {Mnemonic | string} mnemonic\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async fromMnemonic(mnemonic) {\n    let passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return (typeof mnemonic === \"string\" ? await Mnemonic.fromString(mnemonic) : mnemonic).toPrivateKey(passphrase);\n  }\n  /**\n   * Recover a private key from a keystore, previously created by `.toKeystore()`.\n   *\n   * This key will _not_ support child key derivation.\n   *\n   * @param {Uint8Array} data\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.\n   */\n\n\n  static async fromKeystore(data) {\n    let passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return PrivateKey.fromBytes(await loadKeystore(data, passphrase));\n  }\n  /**\n   * Recover a private key from a pem string; the private key may be encrypted.\n   *\n   * This method assumes the .pem file has been converted to a string already.\n   *\n   * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`\n   * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`\n   * section and decodes that as a DER-encoded  private key.\n   *\n   * @param {string} data\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  static async fromPem(data) {\n    let passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    const pem = await readPem(data, passphrase);\n\n    if (pem instanceof Ed25519PrivateKey || pem instanceof EcdsaPrivateKey) {\n      return new PrivateKey(pem);\n    }\n\n    return PrivateKey.fromBytes(pem);\n  }\n  /**\n   * Derive a new private key at the given wallet index.\n   *\n   * Only currently supported for keys created with `fromMnemonic()`; other keys will throw\n   * an error.\n   *\n   * You can check if a key supports derivation with `.supportsDerivation()`\n   *\n   * @param {number} index\n   * @returns {Promise<PrivateKey>}\n   * @throws If this key does not support derivation.\n   */\n\n\n  async derive(index) {\n    // return new PrivateKey(await this._key.derive(index));\n    if (this._key._chainCode == null) {\n      throw new Error(\"this private key does not support key derivation\");\n    }\n\n    const {\n      keyData,\n      chainCode\n    } = await slip10.derive(this.toBytesRaw(), this._key._chainCode, index);\n    /** @type {new (bytes: Uint8Array, chainCode?: Uint8Array) => Ed25519PrivateKey | EcdsaPrivateKey} */\n\n    const constructor =\n    /** @type {any} */\n    this._key.constructor; // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n\n    return new PrivateKey(new constructor(keyData, chainCode));\n  }\n  /**\n   * @param {number} index\n   * @returns {Promise<PrivateKey>}\n   * @throws If this key does not support derivation.\n   */\n\n\n  async legacyDerive(index) {\n    const keyBytes = await derive.legacy(this.toBytesRaw().subarray(0, 32), index);\n    /** @type {new (bytes: Uint8Array) => Ed25519PrivateKey | EcdsaPrivateKey} */\n\n    const constructor =\n    /** @type {any} */\n    this._key.constructor; // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n\n    return new PrivateKey(new constructor(keyBytes));\n  }\n  /**\n   * Get the public key associated with this private key.\n   *\n   * The public key can be freely given and used by other parties to verify\n   * the signatures generated by this private key.\n   *\n   * @returns {PublicKey}\n   */\n\n\n  get publicKey() {\n    return new PublicKey(this._key.publicKey);\n  }\n  /**\n   * Sign a message with this private key.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {Uint8Array} - The signature bytes without the message\n   */\n\n\n  sign(bytes) {\n    return this._key.sign(bytes);\n  }\n  /**\n   * @param {Transaction} transaction\n   * @returns {Uint8Array}\n   */\n\n\n  signTransaction(transaction) {\n    transaction._requireFrozen();\n\n    if (!transaction.isFrozen()) {\n      transaction.freeze();\n    }\n\n    if (transaction._signedTransactions.length != 1) {\n      throw new Error(\"`PrivateKey.signTransaction()` requires `Transaction` to have a single node `AccountId` set\");\n    }\n\n    const tx =\n    /** @type {ProtoSignedTransaction} */\n    transaction._signedTransactions[0];\n    const publicKeyHex = hex.encode(this.publicKey.toBytesRaw());\n\n    if (tx.sigMap == null) {\n      tx.sigMap = {};\n    }\n\n    if (tx.sigMap.sigPair == null) {\n      tx.sigMap.sigPair = [];\n    }\n\n    for (const sigPair of tx.sigMap.sigPair) {\n      if (sigPair.pubKeyPrefix != null && hex.encode(sigPair.pubKeyPrefix) === publicKeyHex) {\n        switch (this._type) {\n          case \"ED25519\":\n            return (\n              /** @type {Uint8Array} */\n              sigPair.ed25519\n            );\n\n          case \"secp256k1\":\n            return (\n              /** @type {Uint8Array} */\n              sigPair.ECDSASecp256k1\n            );\n        }\n      }\n    }\n\n    const siganture = this.sign(tx.bodyBytes != null ? tx.bodyBytes : new Uint8Array());\n    /** @type {ProtoSignaturePair} */\n\n    const protoSignature = {\n      pubKeyPrefix: this.publicKey.toBytesRaw()\n    };\n\n    switch (this._type) {\n      case \"ED25519\":\n        protoSignature.ed25519 = siganture;\n        break;\n\n      case \"secp256k1\":\n        protoSignature.ECDSASecp256k1 = siganture;\n        break;\n    }\n\n    tx.sigMap.sigPair.push(protoSignature);\n\n    transaction._signerPublicKeys.add(publicKeyHex);\n\n    return siganture;\n  }\n  /**\n   * Check if `derive` can be called on this private key.\n   *\n   * This is only the case if the key was created from a mnemonic.\n   *\n   * @returns {boolean}\n   */\n\n\n  isDerivable() {\n    return this._key._chainCode != null;\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    if (this._key instanceof Ed25519PrivateKey) {\n      return this.toBytesRaw();\n    } else {\n      return this.toBytesDer();\n    }\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesDer() {\n    return this._key.toBytesDer();\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesRaw() {\n    return this._key.toBytesRaw();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    return this.toStringDer();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toStringDer() {\n    return hex.encode(this.toBytesDer());\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toStringRaw() {\n    return hex.encode(this.toBytesRaw());\n  }\n  /**\n   * Create a keystore with a given passphrase.\n   *\n   * The key can be recovered later with `fromKeystore()`.\n   *\n   * Note that this will not retain the ancillary data used for\n   * deriving child keys, thus `.derive()` on the restored key will\n   * throw even if this instance supports derivation.\n   *\n   * @param {string} [passphrase]\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  toKeystore() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return createKeystore(this.toBytesRaw(), passphrase);\n  }\n\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/PrivateKey.js"],"names":["Mnemonic","BadKeyError","Key","Ed25519PrivateKey","EcdsaPrivateKey","PublicKey","createKeystore","loadKeystore","read","readPem","hex","slip10","derive","PrivateKey","constructor","key","_key","_type","generateED25519","generate","generateECDSA","generateAsync","generateED25519Async","generateECDSAAsync","fromBytes","data","length","fromBytesECDSA","fromBytesED25519","fromString","text","decode","fromStringECDSA","fromStringED25519","fromMnemonic","mnemonic","passphrase","toPrivateKey","fromKeystore","fromPem","pem","index","_chainCode","Error","keyData","chainCode","toBytesRaw","legacyDerive","keyBytes","legacy","subarray","publicKey","sign","bytes","signTransaction","transaction","_requireFrozen","isFrozen","freeze","_signedTransactions","tx","publicKeyHex","encode","sigMap","sigPair","pubKeyPrefix","ed25519","ECDSASecp256k1","siganture","bodyBytes","Uint8Array","protoSignature","push","_signerPublicKeys","add","isDerivable","toBytes","toBytesDer","toString","toStringDer","toStringRaw","toKeystore"],"mappings":"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","sourcesContent":["import Mnemonic from \"./Mnemonic.js\";\nimport BadKeyError from \"./BadKeyError.js\";\nimport Key from \"./Key.js\";\nimport Ed25519PrivateKey from \"./Ed25519PrivateKey.js\";\nimport EcdsaPrivateKey from \"./EcdsaPrivateKey.js\";\nimport PublicKey from \"./PublicKey.js\";\nimport { createKeystore, loadKeystore } from \"./primitive/keystore.js\";\nimport { read as readPem } from \"./encoding/pem.js\";\nimport * as hex from \"./encoding/hex.js\";\nimport * as slip10 from \"./primitive/slip10.js\";\nimport * as derive from \"./util/derive.js\";\n\n/**\n * @typedef {object} ProtoSignaturePair\n * @property {(Uint8Array | null)=} pubKeyPrefix\n * @property {(Uint8Array | null)=} ed25519\n * @property {(Uint8Array | null)=} ECDSASecp256k1\n */\n\n/**\n * @typedef {object} ProtoSigMap\n * @property {(ProtoSignaturePair[] | null)=} sigPair\n */\n\n/**\n * @typedef {object} ProtoSignedTransaction\n * @property {(Uint8Array | null)=} bodyBytes\n * @property {(ProtoSigMap | null)=} sigMap\n */\n\n/**\n * @typedef {object} Transaction\n * @property {() => boolean} isFrozen\n * @property {ProtoSignedTransaction[]} _signedTransactions\n * @property {Set<string>} _signerPublicKeys\n * @property {(publicKey: PublicKey, signature: Uint8Array) => Transaction} addSignature\n * @property {() => void} _requireFrozen\n * @property {() => Transaction} freeze\n */\n\n/**\n * A private key on the Hedera™ network.\n */\nexport default class PrivateKey extends Key {\n    /**\n     * @hideconstructor\n     * @internal\n     * @param {Ed25519PrivateKey | EcdsaPrivateKey} key\n     */\n    constructor(key) {\n        super();\n\n        /**\n         * @type {Ed25519PrivateKey | EcdsaPrivateKey}\n         * @readonly\n         * @private\n         */\n        this._key = key;\n    }\n\n    /**\n     * @returns {string}\n     */\n    get _type() {\n        return this._key._type;\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generateED25519() {\n        return new PrivateKey(Ed25519PrivateKey.generate());\n    }\n\n    /**\n     * Generate a random EDSA private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generateECDSA() {\n        return new PrivateKey(EcdsaPrivateKey.generate());\n    }\n\n    /**\n     * Depredated - Use `generateEd25519()` instead\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {PrivateKey}\n     */\n    static generate() {\n        return PrivateKey.generateED25519();\n    }\n\n    /**\n     * Depredated - Use `generateEd25519Async()` instead\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateAsync() {\n        return PrivateKey.generateED25519Async();\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateED25519Async() {\n        return new PrivateKey(await Ed25519PrivateKey.generateAsync());\n    }\n\n    /**\n     * Generate a random ECDSA private key.\n     *\n     * @returns {Promise<PrivateKey>}\n     */\n    static async generateECDSAAsync() {\n        return new PrivateKey(await EcdsaPrivateKey.generateAsync());\n    }\n\n    /**\n     * Construct a private key from bytes. Requires DER header.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytes(data) {\n        try {\n            return new PrivateKey(Ed25519PrivateKey.fromBytes(data));\n        } catch {\n            // Do nothing\n        }\n\n        try {\n            return new PrivateKey(EcdsaPrivateKey.fromBytes(data));\n        } catch {\n            // Do nothing\n        }\n\n        throw new BadKeyError(\n            `invalid private key length: ${data.length} bytes`\n        );\n    }\n\n    /**\n     * Construct a ECDSA private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytesECDSA(data) {\n        return new PrivateKey(EcdsaPrivateKey.fromBytes(data));\n    }\n\n    /**\n     * Construct a ED25519 private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {PrivateKey}\n     */\n    static fromBytesED25519(data) {\n        return new PrivateKey(Ed25519PrivateKey.fromBytes(data));\n    }\n\n    /**\n     * Construct a private key from a hex-encoded string. Requires DER header.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromString(text) {\n        return PrivateKey.fromBytes(hex.decode(text));\n    }\n\n    /**\n     * Construct a ECDSA private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringECDSA(text) {\n        return PrivateKey.fromBytesECDSA(hex.decode(text));\n    }\n\n    /**\n     * Construct a Ed25519 private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {PrivateKey}\n     */\n    static fromStringED25519(text) {\n        return PrivateKey.fromBytesED25519(hex.decode(text));\n    }\n\n    /**\n     * Recover a private key from a mnemonic phrase (and optionally a password).\n     *\n     * @param {Mnemonic | string} mnemonic\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromMnemonic(mnemonic, passphrase = \"\") {\n        return (\n            typeof mnemonic === \"string\"\n                ? await Mnemonic.fromString(mnemonic)\n                : mnemonic\n        ).toPrivateKey(passphrase);\n    }\n\n    /**\n     * Recover a private key from a keystore, previously created by `.toKeystore()`.\n     *\n     * This key will _not_ support child key derivation.\n     *\n     * @param {Uint8Array} data\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.\n     */\n    static async fromKeystore(data, passphrase = \"\") {\n        return PrivateKey.fromBytes(await loadKeystore(data, passphrase));\n    }\n\n    /**\n     * Recover a private key from a pem string; the private key may be encrypted.\n     *\n     * This method assumes the .pem file has been converted to a string already.\n     *\n     * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`\n     * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`\n     * section and decodes that as a DER-encoded  private key.\n     *\n     * @param {string} data\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    static async fromPem(data, passphrase = \"\") {\n        const pem = await readPem(data, passphrase);\n\n        if (\n            pem instanceof Ed25519PrivateKey ||\n            pem instanceof EcdsaPrivateKey\n        ) {\n            return new PrivateKey(pem);\n        }\n\n        return PrivateKey.fromBytes(pem);\n    }\n\n    /**\n     * Derive a new private key at the given wallet index.\n     *\n     * Only currently supported for keys created with `fromMnemonic()`; other keys will throw\n     * an error.\n     *\n     * You can check if a key supports derivation with `.supportsDerivation()`\n     *\n     * @param {number} index\n     * @returns {Promise<PrivateKey>}\n     * @throws If this key does not support derivation.\n     */\n    async derive(index) {\n        // return new PrivateKey(await this._key.derive(index));\n        if (this._key._chainCode == null) {\n            throw new Error(\"this private key does not support key derivation\");\n        }\n\n        const { keyData, chainCode } = await slip10.derive(\n            this.toBytesRaw(),\n            this._key._chainCode,\n            index\n        );\n\n        /** @type {new (bytes: Uint8Array, chainCode?: Uint8Array) => Ed25519PrivateKey | EcdsaPrivateKey} */\n        const constructor = /** @type {any} */ (this._key.constructor);\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        return new PrivateKey(new constructor(keyData, chainCode));\n    }\n\n    /**\n     * @param {number} index\n     * @returns {Promise<PrivateKey>}\n     * @throws If this key does not support derivation.\n     */\n    async legacyDerive(index) {\n        const keyBytes = await derive.legacy(\n            this.toBytesRaw().subarray(0, 32),\n            index\n        );\n\n        /** @type {new (bytes: Uint8Array) => Ed25519PrivateKey | EcdsaPrivateKey} */\n        const constructor = /** @type {any} */ (this._key.constructor);\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        return new PrivateKey(new constructor(keyBytes));\n    }\n\n    /**\n     * Get the public key associated with this private key.\n     *\n     * The public key can be freely given and used by other parties to verify\n     * the signatures generated by this private key.\n     *\n     * @returns {PublicKey}\n     */\n    get publicKey() {\n        return new PublicKey(this._key.publicKey);\n    }\n\n    /**\n     * Sign a message with this private key.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {Uint8Array} - The signature bytes without the message\n     */\n    sign(bytes) {\n        return this._key.sign(bytes);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {Uint8Array}\n     */\n    signTransaction(transaction) {\n        transaction._requireFrozen();\n\n        if (!transaction.isFrozen()) {\n            transaction.freeze();\n        }\n\n        if (transaction._signedTransactions.length != 1) {\n            throw new Error(\n                \"`PrivateKey.signTransaction()` requires `Transaction` to have a single node `AccountId` set\"\n            );\n        }\n\n        const tx = /** @type {ProtoSignedTransaction} */ (\n            transaction._signedTransactions[0]\n        );\n\n        const publicKeyHex = hex.encode(this.publicKey.toBytesRaw());\n\n        if (tx.sigMap == null) {\n            tx.sigMap = {};\n        }\n\n        if (tx.sigMap.sigPair == null) {\n            tx.sigMap.sigPair = [];\n        }\n\n        for (const sigPair of tx.sigMap.sigPair) {\n            if (\n                sigPair.pubKeyPrefix != null &&\n                hex.encode(sigPair.pubKeyPrefix) === publicKeyHex\n            ) {\n                switch (this._type) {\n                    case \"ED25519\":\n                        return /** @type {Uint8Array} */ (sigPair.ed25519);\n                    case \"secp256k1\":\n                        return /** @type {Uint8Array} */ (\n                            sigPair.ECDSASecp256k1\n                        );\n                }\n            }\n        }\n\n        const siganture = this.sign(\n            tx.bodyBytes != null ? tx.bodyBytes : new Uint8Array()\n        );\n\n        /** @type {ProtoSignaturePair} */\n        const protoSignature = {\n            pubKeyPrefix: this.publicKey.toBytesRaw(),\n        };\n\n        switch (this._type) {\n            case \"ED25519\":\n                protoSignature.ed25519 = siganture;\n                break;\n            case \"secp256k1\":\n                protoSignature.ECDSASecp256k1 = siganture;\n                break;\n        }\n\n        tx.sigMap.sigPair.push(protoSignature);\n        transaction._signerPublicKeys.add(publicKeyHex);\n\n        return siganture;\n    }\n\n    /**\n     * Check if `derive` can be called on this private key.\n     *\n     * This is only the case if the key was created from a mnemonic.\n     *\n     * @returns {boolean}\n     */\n    isDerivable() {\n        return this._key._chainCode != null;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        if (this._key instanceof Ed25519PrivateKey) {\n            return this.toBytesRaw();\n        } else {\n            return this.toBytesDer();\n        }\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        return this._key.toBytesDer();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        return this._key.toBytesRaw();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringDer() {\n        return hex.encode(this.toBytesDer());\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringRaw() {\n        return hex.encode(this.toBytesRaw());\n    }\n\n    /**\n     * Create a keystore with a given passphrase.\n     *\n     * The key can be recovered later with `fromKeystore()`.\n     *\n     * Note that this will not retain the ancillary data used for\n     * deriving child keys, thus `.derive()` on the restored key will\n     * throw even if this instance supports derivation.\n     *\n     * @param {string} [passphrase]\n     * @returns {Promise<Uint8Array>}\n     */\n    toKeystore(passphrase = \"\") {\n        return createKeystore(this.toBytesRaw(), passphrase);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}