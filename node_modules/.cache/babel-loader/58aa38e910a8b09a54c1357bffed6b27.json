{"ast":null,"code":"\"use strict\";\n\nmodule.exports = BufferWriter; // extends Writer\n\nvar Writer = require(\"./writer\");\n\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\n\n\nfunction BufferWriter() {\n  Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n  /**\n   * Allocates a buffer of the specified size.\n   * @function\n   * @param {number} size Buffer size\n   * @returns {Buffer} Buffer\n   */\n  BufferWriter.alloc = util._Buffer_allocUnsafe;\n  BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n    buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n    // also works for plain array values\n  }\n  /* istanbul ignore next */\n  : function writeBytesBuffer_copy(val, buf, pos) {\n    if (val.copy) // Buffer values\n      val.copy(buf, pos, 0, val.length);else for (var i = 0; i < val.length;) // plain array values\n    buf[pos++] = val[i++];\n  };\n};\n/**\n * @override\n */\n\n\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n  if (util.isString(value)) value = util._Buffer_from(value, \"base64\");\n  var len = value.length >>> 0;\n  this.uint32(len);\n  if (len) this._push(BufferWriter.writeBytesBuffer, len, value);\n  return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n  if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n    util.utf8.write(val, buf, pos);else if (buf.utf8Write) buf.utf8Write(val, pos);else buf.write(val, pos);\n}\n/**\n * @override\n */\n\n\nBufferWriter.prototype.string = function write_string_buffer(value) {\n  var len = util.Buffer.byteLength(value);\n  this.uint32(len);\n  if (len) this._push(writeStringBuffer, len, value);\n  return this;\n};\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\n\nBufferWriter._configure();","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/protobufjs/src/writer_buffer.js"],"names":["module","exports","BufferWriter","Writer","require","prototype","Object","create","constructor","util","call","_configure","alloc","_Buffer_allocUnsafe","writeBytesBuffer","Buffer","Uint8Array","set","name","writeBytesBuffer_set","val","buf","pos","writeBytesBuffer_copy","copy","length","i","bytes","write_bytes_buffer","value","isString","_Buffer_from","len","uint32","_push","writeStringBuffer","utf8","write","utf8Write","string","write_string_buffer","byteLength"],"mappings":"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","sourcesContent":["\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n"]},"metadata":{},"sourceType":"script"}