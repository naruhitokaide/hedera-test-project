{"ast":null,"code":"import AccountId from \"../account/AccountId.js\";\nimport Node from \"../Node.js\";\nimport { PREVIEWNET_ADDRESS_BOOK, TESTNET_ADDRESS_BOOK, MAINNET_ADDRESS_BOOK } from \"../address_book/AddressBooks.js\";\nimport ManagedNetwork from \"./ManagedNetwork.js\";\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../address_book/NodeAddressBook.js\").default} NodeAddressBook\n */\n\n/**\n * @augments {ManagedNetwork<Channel, Node, AccountId>}\n */\n\nexport default class Network extends ManagedNetwork {\n  /**\n   * @param {(address: string) => Channel} createNetworkChannel\n   */\n  constructor(createNetworkChannel) {\n    super(createNetworkChannel);\n    this._maxNodesPerTransaction = -1;\n    /** @type {NodeAddressBook | null} */\n\n    this._addressBook = null;\n  }\n  /**\n   * @param {{[key: string]: (string | AccountId)}} network\n   */\n\n\n  setNetwork(network) {\n    this._setNetwork( // eslint-disable-next-line ie11/no-collection-args\n    new Map( // eslint-disable-next-line ie11/no-collection-args\n    Object.entries(network).map(_ref => {\n      let [key, value] = _ref;\n      return [key, typeof value === \"string\" ? AccountId.fromString(value) : value];\n    })));\n  }\n  /**\n   * @returns {{[key: string]: (string | AccountId)}}\n   */\n\n\n  get network() {\n    /**\n     * @type {{[key: string]: (string | AccountId)}}\n     */\n    var n = {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    for (const node of this._nodes) {\n      n[node.address.toString()] = node.accountId;\n    }\n\n    return n;\n  }\n  /**\n   * @param {string} networkName\n   * @returns {this}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  setNetworkName(networkName) {\n    super.setLedgerId(networkName);\n\n    switch (networkName) {\n      case \"mainnet\":\n        this._addressBook = MAINNET_ADDRESS_BOOK;\n        break;\n\n      case \"testnet\":\n        this._addressBook = TESTNET_ADDRESS_BOOK;\n        break;\n\n      case \"previewnet\":\n        this._addressBook = PREVIEWNET_ADDRESS_BOOK;\n        break;\n    }\n\n    if (this._addressBook != null) {\n      for (const node of this._nodes) {\n        for (const address of this._addressBook.nodeAddresses) {\n          if (address.accountId != null && address.accountId.toString() === node.accountId.toString()) {\n            node.setNodeAddress(address);\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @returns {string | null}\n   */\n\n\n  get networkName() {\n    return this._ledgerId != null ? this._ledgerId.toString() : null;\n  }\n  /**\n   * @abstract\n   * @param {[string, (string | AccountId)]} entry\n   * @returns {Node}\n   */\n\n\n  _createNodeFromNetworkEntry(entry) {\n    const accountId = typeof entry[1] === \"string\" ? AccountId.fromString(entry[1]) : entry[1];\n    return new Node({\n      newNode: {\n        address: entry[0],\n        accountId,\n        channelInitFunction: this._createNetworkChannel\n      }\n    }).setMinBackoff(this._minBackoff);\n  }\n  /**\n   * @abstract\n   * @param {Map<string, AccountId>} network\n   * @returns {number[]}\n   */\n\n\n  _getNodesToRemove(network) {\n    const indexes = [];\n\n    for (let i = this._nodes.length - 1; i >= 0; i--) {\n      const node = this._nodes[i];\n      const accountId = network.get(node.address.toString());\n\n      if (accountId == null || accountId.toString() !== node.accountId.toString()) {\n        indexes.push(i);\n      }\n    }\n\n    return indexes;\n  }\n  /**\n   * @abstract\n   * @param {[string, (string | AccountId)]} entry\n   * @returns {boolean}\n   */\n\n\n  _checkNetworkContainsEntry(entry) {\n    for (const node of this._nodes) {\n      if (node.address.toString() === entry[0]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get maxNodesPerTransaction() {\n    return this._maxNodesPerTransaction;\n  }\n  /**\n   * @param {number} maxNodesPerTransaction\n   * @returns {this}\n   */\n\n\n  setMaxNodesPerTransaction(maxNodesPerTransaction) {\n    this._maxNodesPerTransaction = maxNodesPerTransaction;\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get maxNodeAttempts() {\n    return this._maxNodeAttempts;\n  }\n  /**\n   * @param {number} maxNodeAttempts\n   * @returns {this}\n   */\n\n\n  setMaxNodeAttempts(maxNodeAttempts) {\n    this._maxNodeAttempts = maxNodeAttempts;\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get minBackoff() {\n    return this._minBackoff;\n  }\n  /**\n   * @param {number} minBackoff\n   * @returns {this}\n   */\n\n\n  setMinBackoff(minBackoff) {\n    this._minBackoff = minBackoff;\n\n    for (const node of this._nodes) {\n      node.setMinBackoff(minBackoff);\n    }\n\n    return this;\n  }\n  /**\n   * @internal\n   * @returns {number}\n   */\n\n\n  getNumberOfNodesForTransaction() {\n    if (this._maxNodesPerTransaction > 0) {\n      return this._maxNodesPerTransaction;\n    }\n\n    return (this._nodes.length + 3 - 1) / 3;\n  }\n  /**\n   * @internal\n   * @returns {AccountId[]}\n   */\n\n\n  getNodeAccountIdsForExecute() {\n    return this._getNumberOfMostHealthyNodes(this.getNumberOfNodesForTransaction()).map(node => node.accountId);\n  }\n\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/client/Network.js"],"names":["AccountId","Node","PREVIEWNET_ADDRESS_BOOK","TESTNET_ADDRESS_BOOK","MAINNET_ADDRESS_BOOK","ManagedNetwork","Network","constructor","createNetworkChannel","_maxNodesPerTransaction","_addressBook","setNetwork","network","_setNetwork","Map","Object","entries","map","key","value","fromString","n","node","_nodes","address","toString","accountId","setNetworkName","networkName","setLedgerId","nodeAddresses","setNodeAddress","_ledgerId","_createNodeFromNetworkEntry","entry","newNode","channelInitFunction","_createNetworkChannel","setMinBackoff","_minBackoff","_getNodesToRemove","indexes","i","length","get","push","_checkNetworkContainsEntry","maxNodesPerTransaction","setMaxNodesPerTransaction","maxNodeAttempts","_maxNodeAttempts","setMaxNodeAttempts","minBackoff","getNumberOfNodesForTransaction","getNodeAccountIdsForExecute","_getNumberOfMostHealthyNodes"],"mappings":"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","sourcesContent":["import AccountId from \"../account/AccountId.js\";\nimport Node from \"../Node.js\";\nimport {\n    PREVIEWNET_ADDRESS_BOOK,\n    TESTNET_ADDRESS_BOOK,\n    MAINNET_ADDRESS_BOOK,\n} from \"../address_book/AddressBooks.js\";\nimport ManagedNetwork from \"./ManagedNetwork.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../address_book/NodeAddressBook.js\").default} NodeAddressBook\n */\n\n/**\n * @augments {ManagedNetwork<Channel, Node, AccountId>}\n */\nexport default class Network extends ManagedNetwork {\n    /**\n     * @param {(address: string) => Channel} createNetworkChannel\n     */\n    constructor(createNetworkChannel) {\n        super(createNetworkChannel);\n\n        this._maxNodesPerTransaction = -1;\n\n        /** @type {NodeAddressBook | null} */\n        this._addressBook = null;\n    }\n\n    /**\n     * @param {{[key: string]: (string | AccountId)}} network\n     */\n    setNetwork(network) {\n        this._setNetwork(\n            // eslint-disable-next-line ie11/no-collection-args\n            new Map(\n                // eslint-disable-next-line ie11/no-collection-args\n                Object.entries(network).map(([key, value]) => {\n                    return [\n                        key,\n                        typeof value === \"string\"\n                            ? AccountId.fromString(value)\n                            : value,\n                    ];\n                })\n            )\n        );\n    }\n\n    /**\n     * @returns {{[key: string]: (string | AccountId)}}\n     */\n    get network() {\n        /**\n         * @type {{[key: string]: (string | AccountId)}}\n         */\n        var n = {};\n\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for (const node of this._nodes) {\n            n[node.address.toString()] = node.accountId;\n        }\n\n        return n;\n    }\n\n    /**\n     * @param {string} networkName\n     * @returns {this}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setNetworkName(networkName) {\n        super.setLedgerId(networkName);\n\n        switch (networkName) {\n            case \"mainnet\":\n                this._addressBook = MAINNET_ADDRESS_BOOK;\n                break;\n            case \"testnet\":\n                this._addressBook = TESTNET_ADDRESS_BOOK;\n                break;\n            case \"previewnet\":\n                this._addressBook = PREVIEWNET_ADDRESS_BOOK;\n                break;\n        }\n\n        if (this._addressBook != null) {\n            for (const node of this._nodes) {\n                for (const address of this._addressBook.nodeAddresses) {\n                    if (\n                        address.accountId != null &&\n                        address.accountId.toString() ===\n                            node.accountId.toString()\n                    ) {\n                        node.setNodeAddress(address);\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @returns {string | null}\n     */\n    get networkName() {\n        return this._ledgerId != null ? this._ledgerId.toString() : null;\n    }\n\n    /**\n     * @abstract\n     * @param {[string, (string | AccountId)]} entry\n     * @returns {Node}\n     */\n    _createNodeFromNetworkEntry(entry) {\n        const accountId =\n            typeof entry[1] === \"string\"\n                ? AccountId.fromString(entry[1])\n                : entry[1];\n\n        return new Node({\n            newNode: {\n                address: entry[0],\n                accountId,\n                channelInitFunction: this._createNetworkChannel,\n            },\n        }).setMinBackoff(this._minBackoff);\n    }\n\n    /**\n     * @abstract\n     * @param {Map<string, AccountId>} network\n     * @returns {number[]}\n     */\n    _getNodesToRemove(network) {\n        const indexes = [];\n\n        for (let i = this._nodes.length - 1; i >= 0; i--) {\n            const node = this._nodes[i];\n            const accountId = network.get(node.address.toString());\n\n            if (\n                accountId == null ||\n                accountId.toString() !== node.accountId.toString()\n            ) {\n                indexes.push(i);\n            }\n        }\n\n        return indexes;\n    }\n\n    /**\n     * @abstract\n     * @param {[string, (string | AccountId)]} entry\n     * @returns {boolean}\n     */\n    _checkNetworkContainsEntry(entry) {\n        for (const node of this._nodes) {\n            if (node.address.toString() === entry[0]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxNodesPerTransaction() {\n        return this._maxNodesPerTransaction;\n    }\n\n    /**\n     * @param {number} maxNodesPerTransaction\n     * @returns {this}\n     */\n    setMaxNodesPerTransaction(maxNodesPerTransaction) {\n        this._maxNodesPerTransaction = maxNodesPerTransaction;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxNodeAttempts() {\n        return this._maxNodeAttempts;\n    }\n\n    /**\n     * @param {number} maxNodeAttempts\n     * @returns {this}\n     */\n    setMaxNodeAttempts(maxNodeAttempts) {\n        this._maxNodeAttempts = maxNodeAttempts;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get minBackoff() {\n        return this._minBackoff;\n    }\n\n    /**\n     * @param {number} minBackoff\n     * @returns {this}\n     */\n    setMinBackoff(minBackoff) {\n        this._minBackoff = minBackoff;\n        for (const node of this._nodes) {\n            node.setMinBackoff(minBackoff);\n        }\n        return this;\n    }\n\n    /**\n     * @internal\n     * @returns {number}\n     */\n    getNumberOfNodesForTransaction() {\n        if (this._maxNodesPerTransaction > 0) {\n            return this._maxNodesPerTransaction;\n        }\n\n        return (this._nodes.length + 3 - 1) / 3;\n    }\n\n    /**\n     * @internal\n     * @returns {AccountId[]}\n     */\n    getNodeAccountIdsForExecute() {\n        return this._getNumberOfMostHealthyNodes(\n            this.getNumberOfNodesForTransaction()\n        ).map((node) => node.accountId);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}