{"ast":null,"code":"import Long from \"long\";\nimport * as entity_id from \"../EntityIdHelper.js\";\nimport * as proto from \"@hashgraph/proto\";\nimport Key from \"../Key.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport CACHE from \"../Cache.js\";\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\nconst regex = new RegExp(\"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.((?:[0-9a-fA-F][0-9a-fA-F])+)$\");\n/**\n * The ID for a crypto-currency account on Hedera.\n */\n\nexport default class AccountId {\n  /**\n   * @param {number | Long | import(\"../EntityIdHelper\").IEntityId} props\n   * @param {(number | Long)=} realm\n   * @param {(number | Long | PublicKey)=} numOrAliasKey\n   */\n  constructor(props, realm, numOrAliasKey) {\n    const result = entity_id.constructor(props, realm, numOrAliasKey);\n    this.shard = result.shard;\n    this.realm = result.realm;\n    this.num = result.num;\n    this.aliasKey = result.aliasKey;\n    /**\n     * @type {string | null}\n     */\n\n    this._checksum = null;\n  }\n  /**\n   * @param {string} text\n   * @returns {AccountId}\n   */\n\n\n  static fromString(text) {\n    try {\n      const result = entity_id.fromString(text);\n      const id = new AccountId(result);\n      id._checksum = result.checksum;\n      return id;\n    } catch {\n      let match = regex.exec(text);\n\n      if (match == null) {\n        throw new Error(\"invalid account ID\");\n      }\n\n      return new AccountId(Long.fromString(match[1]), Long.fromString(match[2]), PublicKey.fromString(match[3]));\n    }\n  }\n  /**\n   * @internal\n   * @param {proto.IAccountID} id\n   * @returns {AccountId}\n   */\n\n\n  static _fromProtobuf(id) {\n    let key = id.alias != null && id.alias.length > 0 ? Key._fromProtobufKey(proto.Key.decode(id.alias)) : null;\n\n    if (!(key instanceof PublicKey)) {\n      key = null;\n    }\n\n    const account = key != null ? key :\n    /** @type {Long} */\n    id.accountNum;\n    return new AccountId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, account);\n  }\n  /**\n   * @returns {string | null}\n   */\n\n\n  get checksum() {\n    return this._checksum;\n  }\n  /**\n   * @deprecated - Use `validateChecksum` instead\n   * @param {Client} client\n   */\n\n\n  validate(client) {\n    console.warn(\"Deprecated: Use `validateChecksum` instead\");\n    this.validateChecksum(client);\n  }\n  /**\n   * @param {Client} client\n   */\n\n\n  validateChecksum(client) {\n    if (this.aliasKey != null) {\n      throw new Error(\"cannot calculate checksum with an account ID that has a aliasKey\");\n    }\n\n    entity_id.validateChecksum(this.shard, this.realm, this.num, this._checksum, client);\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {AccountId}\n   */\n\n\n  static fromBytes(bytes) {\n    return AccountId._fromProtobuf(proto.AccountID.decode(bytes));\n  }\n  /**\n   * @param {string} address\n   * @returns {AccountId}\n   */\n\n\n  static fromSolidityAddress(address) {\n    return new AccountId(...entity_id.fromSolidityAddress(address));\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toSolidityAddress() {\n    return entity_id.toSolidityAddress([this.shard, this.realm, this.num]);\n  }\n  /**\n   * @internal\n   * @returns {proto.IAccountID}\n   */\n\n\n  _toProtobuf() {\n    return {\n      alias: this.aliasKey != null ? proto.Key.encode(this.aliasKey._toProtobufKey()).finish() : null,\n      accountNum: this.num,\n      shardNum: this.shard,\n      realmNum: this.realm\n    };\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return proto.AccountID.encode(this._toProtobuf()).finish();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    const account = this.aliasKey != null ? this.aliasKey.toString() : this.num.toString();\n    return `${this.shard.toString()}.${this.realm.toString()}.${account}`;\n  }\n  /**\n   * @param {Client} client\n   * @returns {string}\n   */\n\n\n  toStringWithChecksum(client) {\n    if (this.aliasKey != null) {\n      throw new Error(\"cannot calculate checksum with an account ID that has a aliasKey\");\n    }\n\n    return entity_id.toStringWithChecksum(this.toString(), client);\n  }\n  /**\n   * @param {this} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    let account = false;\n\n    if (this.aliasKey != null && other.aliasKey != null) {\n      account = this.aliasKey.equals(other.aliasKey);\n    } else if (this.aliasKey == null && other.aliasKey == null) {\n      account = this.num.eq(other.num);\n    }\n\n    return this.shard.eq(other.shard) && this.realm.eq(other.realm) && account;\n  }\n  /**\n   * @returns {AccountId}\n   */\n\n\n  clone() {\n    const id = new AccountId(this);\n    id._checksum = this._checksum;\n    return id;\n  }\n  /**\n   * @param {AccountId} other\n   * @returns {number}\n   */\n\n\n  compare(other) {\n    let comparison = this.shard.compare(other.shard);\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    comparison = this.realm.compare(other.realm);\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    if (this.aliasKey != null && other.aliasKey != null) {\n      const t = this.aliasKey.toString();\n      const o = other.aliasKey.toString();\n\n      if (t > o) {\n        return 1;\n      } else if (t < o) {\n        return -1;\n      } else {\n        return 0;\n      }\n    } else if (this.aliasKey == null && other.aliasKey == null) {\n      return this.num.compare(other.num);\n    } else {\n      return 0;\n    }\n  }\n\n}\n\nCACHE.accountIdConstructor = (shard, realm, key) => new AccountId(shard, realm, key);","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/account/AccountId.js"],"names":["Long","entity_id","proto","Key","PublicKey","CACHE","regex","RegExp","AccountId","constructor","props","realm","numOrAliasKey","result","shard","num","aliasKey","_checksum","fromString","text","id","checksum","match","exec","Error","_fromProtobuf","key","alias","length","_fromProtobufKey","decode","account","accountNum","shardNum","realmNum","validate","client","console","warn","validateChecksum","fromBytes","bytes","AccountID","fromSolidityAddress","address","toSolidityAddress","_toProtobuf","encode","_toProtobufKey","finish","toBytes","toString","toStringWithChecksum","equals","other","eq","clone","compare","comparison","t","o","accountIdConstructor"],"mappings":"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","sourcesContent":["import Long from \"long\";\nimport * as entity_id from \"../EntityIdHelper.js\";\nimport * as proto from \"@hashgraph/proto\";\nimport Key from \"../Key.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport CACHE from \"../Cache.js\";\n\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\nconst regex = new RegExp(\n    \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.((?:[0-9a-fA-F][0-9a-fA-F])+)$\"\n);\n\n/**\n * The ID for a crypto-currency account on Hedera.\n */\nexport default class AccountId {\n    /**\n     * @param {number | Long | import(\"../EntityIdHelper\").IEntityId} props\n     * @param {(number | Long)=} realm\n     * @param {(number | Long | PublicKey)=} numOrAliasKey\n     */\n    constructor(props, realm, numOrAliasKey) {\n        const result = entity_id.constructor(props, realm, numOrAliasKey);\n\n        this.shard = result.shard;\n        this.realm = result.realm;\n        this.num = result.num;\n        this.aliasKey = result.aliasKey;\n\n        /**\n         * @type {string | null}\n         */\n        this._checksum = null;\n    }\n\n    /**\n     * @param {string} text\n     * @returns {AccountId}\n     */\n    static fromString(text) {\n        try {\n            const result = entity_id.fromString(text);\n            const id = new AccountId(result);\n            id._checksum = result.checksum;\n            return id;\n        } catch {\n            let match = regex.exec(text);\n            if (match == null) {\n                throw new Error(\"invalid account ID\");\n            }\n\n            return new AccountId(\n                Long.fromString(match[1]),\n                Long.fromString(match[2]),\n                PublicKey.fromString(match[3])\n            );\n        }\n    }\n\n    /**\n     * @internal\n     * @param {proto.IAccountID} id\n     * @returns {AccountId}\n     */\n    static _fromProtobuf(id) {\n        let key =\n            id.alias != null && id.alias.length > 0\n                ? Key._fromProtobufKey(proto.Key.decode(id.alias))\n                : null;\n\n        if (!(key instanceof PublicKey)) {\n            key = null;\n        }\n\n        const account = key != null ? key : /** @type {Long} */ (id.accountNum);\n\n        return new AccountId(\n            id.shardNum != null ? id.shardNum : 0,\n            id.realmNum != null ? id.realmNum : 0,\n            account\n        );\n    }\n\n    /**\n     * @returns {string | null}\n     */\n    get checksum() {\n        return this._checksum;\n    }\n\n    /**\n     * @deprecated - Use `validateChecksum` instead\n     * @param {Client} client\n     */\n    validate(client) {\n        console.warn(\"Deprecated: Use `validateChecksum` instead\");\n        this.validateChecksum(client);\n    }\n\n    /**\n     * @param {Client} client\n     */\n    validateChecksum(client) {\n        if (this.aliasKey != null) {\n            throw new Error(\n                \"cannot calculate checksum with an account ID that has a aliasKey\"\n            );\n        }\n\n        entity_id.validateChecksum(\n            this.shard,\n            this.realm,\n            this.num,\n            this._checksum,\n            client\n        );\n    }\n\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountId}\n     */\n    static fromBytes(bytes) {\n        return AccountId._fromProtobuf(proto.AccountID.decode(bytes));\n    }\n\n    /**\n     * @param {string} address\n     * @returns {AccountId}\n     */\n    static fromSolidityAddress(address) {\n        return new AccountId(...entity_id.fromSolidityAddress(address));\n    }\n\n    /**\n     * @returns {string}\n     */\n    toSolidityAddress() {\n        return entity_id.toSolidityAddress([this.shard, this.realm, this.num]);\n    }\n\n    /**\n     * @internal\n     * @returns {proto.IAccountID}\n     */\n    _toProtobuf() {\n        return {\n            alias:\n                this.aliasKey != null\n                    ? proto.Key.encode(this.aliasKey._toProtobufKey()).finish()\n                    : null,\n            accountNum: this.num,\n            shardNum: this.shard,\n            realmNum: this.realm,\n        };\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return proto.AccountID.encode(this._toProtobuf()).finish();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        const account =\n            this.aliasKey != null\n                ? this.aliasKey.toString()\n                : this.num.toString();\n\n        return `${this.shard.toString()}.${this.realm.toString()}.${account}`;\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {string}\n     */\n    toStringWithChecksum(client) {\n        if (this.aliasKey != null) {\n            throw new Error(\n                \"cannot calculate checksum with an account ID that has a aliasKey\"\n            );\n        }\n\n        return entity_id.toStringWithChecksum(this.toString(), client);\n    }\n\n    /**\n     * @param {this} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        let account = false;\n\n        if (this.aliasKey != null && other.aliasKey != null) {\n            account = this.aliasKey.equals(other.aliasKey);\n        } else if (this.aliasKey == null && other.aliasKey == null) {\n            account = this.num.eq(other.num);\n        }\n\n        return (\n            this.shard.eq(other.shard) && this.realm.eq(other.realm) && account\n        );\n    }\n\n    /**\n     * @returns {AccountId}\n     */\n    clone() {\n        const id = new AccountId(this);\n        id._checksum = this._checksum;\n        return id;\n    }\n\n    /**\n     * @param {AccountId} other\n     * @returns {number}\n     */\n    compare(other) {\n        let comparison = this.shard.compare(other.shard);\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        comparison = this.realm.compare(other.realm);\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        if (this.aliasKey != null && other.aliasKey != null) {\n            const t = this.aliasKey.toString();\n            const o = other.aliasKey.toString();\n\n            if (t > o) {\n                return 1;\n            } else if (t < o) {\n                return -1;\n            } else {\n                return 0;\n            }\n        } else if (this.aliasKey == null && other.aliasKey == null) {\n            return this.num.compare(other.num);\n        } else {\n            return 0;\n        }\n    }\n}\n\nCACHE.accountIdConstructor = (shard, realm, key) =>\n    new AccountId(shard, realm, key);\n"]},"metadata":{},"sourceType":"module"}