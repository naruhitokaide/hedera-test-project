{"ast":null,"code":"import TransactionId from \"../transaction/TransactionId.js\";\nimport Hbar from \"../Hbar.js\";\nimport Executable from \"../Executable.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport { _makePaymentTransaction, COST_QUERY } from \"./Query.js\";\nimport { ResponseType as ProtoResponseType } from \"@hashgraph/proto\";\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IQuery} proto.IQuery\n * @typedef {import(\"@hashgraph/proto\").IResponse} proto.IResponse\n * @typedef {import(\"@hashgraph/proto\").IQueryHeader} proto.IQueryHeader\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../Status.js\").default} Status\n * @typedef {import(\"../Executable.js\").ExecutionState} ExecutionState\n */\n\n/**\n * @template OutputT\n * @augments {Executable<proto.IQuery, proto.IResponse, Hbar>}\n */\n\nexport default class CostQuery extends Executable {\n  /**\n   * @param {import(\"./Query.js\").default<OutputT>} query\n   */\n  constructor(query) {\n    super();\n    this._query = query;\n    this._nodeIds = query._nodeIds;\n    /**\n     * @type {proto.IQueryHeader | null}\n     */\n\n    this._header = null;\n  }\n  /**\n   * @returns {TransactionId}\n   */\n\n\n  _getTransactionId() {\n    return this._query._getTransactionId();\n  }\n  /**\n   * @abstract\n   * @protected\n   * @param {import(\"../client/Client.js\").default<*, *>} client\n   * @returns {Promise<void>}\n   */\n\n\n  async _beforeExecute(client) {\n    if (client == null) {\n      throw new Error(\"Cannot do CostQuery without Client\");\n    }\n\n    const operator = client._operator;\n\n    if (operator == null) {\n      throw new Error(\"`client` must have an `operator` or an explicit payment transaction must be provided\");\n    }\n\n    if (this._query._nodeIds.length == 0) {\n      this._query._nodeIds = client._network.getNodeAccountIdsForExecute();\n    }\n\n    this._header = {\n      payment: await _makePaymentTransaction(\n      /** @type {import(\"../transaction/TransactionId.js\").default} */\n      TransactionId.generate(new AccountId(0)), new AccountId(0), operator, new Hbar(0)),\n      responseType: ProtoResponseType.COST_ANSWER\n    };\n  }\n  /**\n   * @abstract\n   * @internal\n   * @returns {Promise<proto.IQuery>}\n   */\n\n\n  _makeRequestAsync() {\n    return Promise.resolve(this._query._onMakeRequest(\n    /** @type {proto.IQueryHeader} */\n    this._header));\n  }\n  /**\n   * @abstract\n   * @internal\n   * @param {proto.IQuery} request\n   * @param {proto.IResponse} response\n   * @returns {ExecutionState}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _shouldRetry(request, response) {\n    return this._query._shouldRetry(request, response);\n  }\n  /**\n   * @abstract\n   * @internal\n   * @param {proto.IQuery} request\n   * @param {proto.IResponse} response\n   * @returns {Error}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapStatusError(request, response) {\n    return this._query._mapStatusError(request, response);\n  }\n  /**\n   * @override\n   * @internal\n   * @param {proto.IResponse} response\n   * @param {AccountId} nodeAccountId\n   * @param {proto.IQuery} request\n   * @returns {Promise<Hbar>}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapResponse(response, nodeAccountId, request) {\n    const cost = this._query._mapResponseHeader(response).cost;\n\n    return Promise.resolve(Hbar.fromTinybars(\n    /** @type {Long | number} */\n    cost));\n  }\n  /**\n   * @override\n   * @internal\n   * @param {Channel} channel\n   * @param {proto.IQuery} request\n   * @returns {Promise<proto.IResponse>}\n   */\n\n\n  _execute(channel, request) {\n    return this._query._execute(channel, request);\n  }\n  /**\n   * @override\n   * @returns {AccountId}\n   */\n\n\n  _getNodeAccountId() {\n    if (this._nodeIds.length > 0) {\n      // if there are payment transactions,\n      // we need to use the node of the current payment transaction\n      return this._nodeIds[this._nextNodeIndex];\n    } else {\n      throw new Error(\"(BUG) nodeAccountIds were not set for query before executing\");\n    }\n  }\n\n}\nCOST_QUERY.push(query => new CostQuery(query));","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/query/CostQuery.js"],"names":["TransactionId","Hbar","Executable","AccountId","_makePaymentTransaction","COST_QUERY","ResponseType","ProtoResponseType","CostQuery","constructor","query","_query","_nodeIds","_header","_getTransactionId","_beforeExecute","client","Error","operator","_operator","length","_network","getNodeAccountIdsForExecute","payment","generate","responseType","COST_ANSWER","_makeRequestAsync","Promise","resolve","_onMakeRequest","_shouldRetry","request","response","_mapStatusError","_mapResponse","nodeAccountId","cost","_mapResponseHeader","fromTinybars","_execute","channel","_getNodeAccountId","_nextNodeIndex","push"],"mappings":"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","sourcesContent":["import TransactionId from \"../transaction/TransactionId.js\";\nimport Hbar from \"../Hbar.js\";\nimport Executable from \"../Executable.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport { _makePaymentTransaction, COST_QUERY } from \"./Query.js\";\nimport { ResponseType as ProtoResponseType } from \"@hashgraph/proto\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IQuery} proto.IQuery\n * @typedef {import(\"@hashgraph/proto\").IResponse} proto.IResponse\n * @typedef {import(\"@hashgraph/proto\").IQueryHeader} proto.IQueryHeader\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../Status.js\").default} Status\n * @typedef {import(\"../Executable.js\").ExecutionState} ExecutionState\n */\n\n/**\n * @template OutputT\n * @augments {Executable<proto.IQuery, proto.IResponse, Hbar>}\n */\nexport default class CostQuery extends Executable {\n    /**\n     * @param {import(\"./Query.js\").default<OutputT>} query\n     */\n    constructor(query) {\n        super();\n\n        this._query = query;\n        this._nodeIds = query._nodeIds;\n\n        /**\n         * @type {proto.IQueryHeader | null}\n         */\n        this._header = null;\n    }\n\n    /**\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        return this._query._getTransactionId();\n    }\n\n    /**\n     * @abstract\n     * @protected\n     * @param {import(\"../client/Client.js\").default<*, *>} client\n     * @returns {Promise<void>}\n     */\n    async _beforeExecute(client) {\n        if (client == null) {\n            throw new Error(\"Cannot do CostQuery without Client\");\n        }\n\n        const operator = client._operator;\n\n        if (operator == null) {\n            throw new Error(\n                \"`client` must have an `operator` or an explicit payment transaction must be provided\"\n            );\n        }\n\n        if (this._query._nodeIds.length == 0) {\n            this._query._nodeIds =\n                client._network.getNodeAccountIdsForExecute();\n        }\n\n        this._header = {\n            payment: await _makePaymentTransaction(\n                /** @type {import(\"../transaction/TransactionId.js\").default} */\n                (TransactionId.generate(new AccountId(0))),\n                new AccountId(0),\n                operator,\n                new Hbar(0)\n            ),\n            responseType: ProtoResponseType.COST_ANSWER,\n        };\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @returns {Promise<proto.IQuery>}\n     */\n    _makeRequestAsync() {\n        return Promise.resolve(\n            this._query._onMakeRequest(\n                /** @type {proto.IQueryHeader} */ (this._header)\n            )\n        );\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {proto.IQuery} request\n     * @param {proto.IResponse} response\n     * @returns {ExecutionState}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        return this._query._shouldRetry(request, response);\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {proto.IQuery} request\n     * @param {proto.IResponse} response\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response) {\n        return this._query._mapStatusError(request, response);\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {proto.IResponse} response\n     * @param {AccountId} nodeAccountId\n     * @param {proto.IQuery} request\n     * @returns {Promise<Hbar>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapResponse(response, nodeAccountId, request) {\n        const cost = this._query._mapResponseHeader(response).cost;\n        return Promise.resolve(\n            Hbar.fromTinybars(/** @type {Long | number} */ (cost))\n        );\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {proto.IQuery} request\n     * @returns {Promise<proto.IResponse>}\n     */\n    _execute(channel, request) {\n        return this._query._execute(channel, request);\n    }\n\n    /**\n     * @override\n     * @returns {AccountId}\n     */\n    _getNodeAccountId() {\n        if (this._nodeIds.length > 0) {\n            // if there are payment transactions,\n            // we need to use the node of the current payment transaction\n            return this._nodeIds[this._nextNodeIndex];\n        } else {\n            throw new Error(\n                \"(BUG) nodeAccountIds were not set for query before executing\"\n            );\n        }\n    }\n}\n\nCOST_QUERY.push((query) => new CostQuery(query));\n"]},"metadata":{},"sourceType":"module"}