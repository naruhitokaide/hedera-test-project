{"ast":null,"code":"\"use strict\";\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\n\nvar base64 = exports;\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\n\nbase64.length = function length(string) {\n  var p = string.length;\n  if (!p) return 0;\n  var n = 0;\n\n  while (--p % 4 > 1 && string.charAt(p) === \"=\") ++n;\n\n  return Math.ceil(string.length * 3) / 4 - n;\n}; // Base64 encoding table\n\n\nvar b64 = new Array(64); // Base64 decoding table\n\nvar s64 = new Array(123); // 65..90, 97..122, 48..57, 43, 47\n\nfor (var i = 0; i < 64;) s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\n\n\nbase64.encode = function encode(buffer, start, end) {\n  var parts = null,\n      chunk = [];\n  var i = 0,\n      // output index\n  j = 0,\n      // goto index\n  t; // temporary\n\n  while (start < end) {\n    var b = buffer[start++];\n\n    switch (j) {\n      case 0:\n        chunk[i++] = b64[b >> 2];\n        t = (b & 3) << 4;\n        j = 1;\n        break;\n\n      case 1:\n        chunk[i++] = b64[t | b >> 4];\n        t = (b & 15) << 2;\n        j = 2;\n        break;\n\n      case 2:\n        chunk[i++] = b64[t | b >> 6];\n        chunk[i++] = b64[b & 63];\n        j = 0;\n        break;\n    }\n\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n      i = 0;\n    }\n  }\n\n  if (j) {\n    chunk[i++] = b64[t];\n    chunk[i++] = 61;\n    if (j === 1) chunk[i++] = 61;\n  }\n\n  if (parts) {\n    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n\nvar invalidEncoding = \"invalid encoding\";\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\n\nbase64.decode = function decode(string, buffer, offset) {\n  var start = offset;\n  var j = 0,\n      // goto index\n  t; // temporary\n\n  for (var i = 0; i < string.length;) {\n    var c = string.charCodeAt(i++);\n    if (c === 61 && j > 1) break;\n    if ((c = s64[c]) === undefined) throw Error(invalidEncoding);\n\n    switch (j) {\n      case 0:\n        t = c;\n        j = 1;\n        break;\n\n      case 1:\n        buffer[offset++] = t << 2 | (c & 48) >> 4;\n        t = c;\n        j = 2;\n        break;\n\n      case 2:\n        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n        t = c;\n        j = 3;\n        break;\n\n      case 3:\n        buffer[offset++] = (t & 3) << 6 | c;\n        j = 0;\n        break;\n    }\n  }\n\n  if (j === 1) throw Error(invalidEncoding);\n  return offset - start;\n};\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\n\n\nbase64.test = function test(string) {\n  return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n};","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@protobufjs/base64/index.js"],"names":["base64","exports","length","string","p","n","charAt","Math","ceil","b64","Array","s64","i","encode","buffer","start","end","parts","chunk","j","t","b","push","String","fromCharCode","apply","slice","join","invalidEncoding","decode","offset","c","charCodeAt","undefined","Error","test"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}