{"ast":null,"code":"import BadKeyError from \"./BadKeyError.js\";\nimport EcdsaPublicKey from \"./EcdsaPublicKey.js\";\nimport * as hex from \"./encoding/hex.js\";\nimport * as ecdsa from \"./primitive/ecdsa.js\";\nimport { arrayStartsWith } from \"./util/array.js\";\nconst derPrefix = \"3030020100300706052b8104000a04220420\";\nconst derPrefixBytes = hex.decode(derPrefix);\n/**\n * @typedef {object} KeyPair\n * @property {Uint8Array} publicKey\n * @property {Uint8Array} privateKey\n */\n\nexport default class EcdsaPrivateKey {\n  /**\n   * @hideconstructor\n   * @internal\n   * @param {KeyPair} keyPair\n   * @param {(Uint8Array)=} chainCode\n   */\n  constructor(keyPair, chainCode) {\n    /**\n     * @type {KeyPair}\n     * @readonly\n     * @private\n     */\n    this._keyPair = keyPair;\n    /**\n     * @type {?Uint8Array}\n     * @readonly\n     */\n\n    this._chainCode = chainCode != null ? chainCode : null;\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  get _type() {\n    return \"secp256k1\";\n  }\n  /**\n   * Generate a random ECDSA private key.\n   *\n   * @returns {EcdsaPrivateKey}\n   */\n\n\n  static generate() {\n    return new EcdsaPrivateKey(ecdsa.generate());\n  }\n  /**\n   * Generate a random Ed25519 private key.\n   *\n   * @returns {Promise<EcdsaPrivateKey>}\n   */\n\n\n  static async generateAsync() {\n    return new EcdsaPrivateKey(await ecdsa.generateAsync());\n  }\n  /**\n   * Construct a private key from bytes.\n   *\n   * @param {Uint8Array} data\n   * @returns {EcdsaPrivateKey}\n   */\n\n\n  static fromBytes(data) {\n    switch (data.length) {\n      case 32:\n        return EcdsaPrivateKey.fromBytesRaw(data);\n\n      case 50:\n        return EcdsaPrivateKey.fromBytesDer(data);\n\n      default:\n        throw new BadKeyError(`invalid private key length: ${data.length} bytes`);\n    }\n  }\n  /**\n   * Construct a private key from bytes.\n   *\n   * @param {Uint8Array} data\n   * @returns {EcdsaPrivateKey}\n   */\n\n\n  static fromBytesDer(data) {\n    if (data.length != 32 && !arrayStartsWith(data, derPrefixBytes)) {\n      throw new BadKeyError(\"invalid der header\");\n    }\n\n    return new EcdsaPrivateKey(ecdsa.fromBytes(data.subarray(derPrefixBytes.length)));\n  }\n  /**\n   * Construct a private key from bytes.\n   *\n   * @param {Uint8Array} data\n   * @returns {EcdsaPrivateKey}\n   */\n\n\n  static fromBytesRaw(data) {\n    return new EcdsaPrivateKey(ecdsa.fromBytes(data));\n  }\n  /**\n   * Construct a private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {EcdsaPrivateKey}\n   */\n\n\n  static fromString(text) {\n    return EcdsaPrivateKey.fromBytes(hex.decode(text));\n  }\n  /**\n   * Construct a private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {EcdsaPrivateKey}\n   */\n\n\n  static fromStringDer(text) {\n    return EcdsaPrivateKey.fromBytesDer(hex.decode(text));\n  }\n  /**\n   * Construct a private key from a hex-encoded string.\n   *\n   * @param {string} text\n   * @returns {EcdsaPrivateKey}\n   */\n\n\n  static fromStringRaw(text) {\n    return EcdsaPrivateKey.fromBytesRaw(hex.decode(text));\n  }\n  /**\n   * Get the public key associated with this private key.\n   *\n   * The public key can be freely given and used by other parties to verify\n   * the signatures generated by this private key.\n   *\n   * @returns {EcdsaPublicKey}\n   */\n\n\n  get publicKey() {\n    return new EcdsaPublicKey(this._keyPair.publicKey);\n  }\n  /**\n   * Sign a message with this private key.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {Uint8Array} - The signature bytes without the message\n   */\n\n\n  sign(bytes) {\n    return ecdsa.sign(this._keyPair.privateKey, bytes);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesDer() {\n    const bytes = new Uint8Array(derPrefixBytes.length + 32);\n    bytes.set(derPrefixBytes, 0);\n    bytes.set(this._keyPair.privateKey.subarray(0, 32), derPrefixBytes.length);\n    return bytes;\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesRaw() {\n    return this._keyPair.privateKey.slice(0, 32);\n  }\n\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/EcdsaPrivateKey.js"],"names":["BadKeyError","EcdsaPublicKey","hex","ecdsa","arrayStartsWith","derPrefix","derPrefixBytes","decode","EcdsaPrivateKey","constructor","keyPair","chainCode","_keyPair","_chainCode","_type","generate","generateAsync","fromBytes","data","length","fromBytesRaw","fromBytesDer","subarray","fromString","text","fromStringDer","fromStringRaw","publicKey","sign","bytes","privateKey","toBytesDer","Uint8Array","set","toBytesRaw","slice"],"mappings":"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","sourcesContent":["import BadKeyError from \"./BadKeyError.js\";\nimport EcdsaPublicKey from \"./EcdsaPublicKey.js\";\nimport * as hex from \"./encoding/hex.js\";\nimport * as ecdsa from \"./primitive/ecdsa.js\";\nimport { arrayStartsWith } from \"./util/array.js\";\n\nconst derPrefix = \"3030020100300706052b8104000a04220420\";\nconst derPrefixBytes = hex.decode(derPrefix);\n\n/**\n * @typedef {object} KeyPair\n * @property {Uint8Array} publicKey\n * @property {Uint8Array} privateKey\n */\n\nexport default class EcdsaPrivateKey {\n    /**\n     * @hideconstructor\n     * @internal\n     * @param {KeyPair} keyPair\n     * @param {(Uint8Array)=} chainCode\n     */\n    constructor(keyPair, chainCode) {\n        /**\n         * @type {KeyPair}\n         * @readonly\n         * @private\n         */\n        this._keyPair = keyPair;\n\n        /**\n         * @type {?Uint8Array}\n         * @readonly\n         */\n        this._chainCode = chainCode != null ? chainCode : null;\n    }\n\n    /**\n     * @returns {string}\n     */\n    get _type() {\n        return \"secp256k1\";\n    }\n\n    /**\n     * Generate a random ECDSA private key.\n     *\n     * @returns {EcdsaPrivateKey}\n     */\n    static generate() {\n        return new EcdsaPrivateKey(ecdsa.generate());\n    }\n\n    /**\n     * Generate a random Ed25519 private key.\n     *\n     * @returns {Promise<EcdsaPrivateKey>}\n     */\n    static async generateAsync() {\n        return new EcdsaPrivateKey(await ecdsa.generateAsync());\n    }\n\n    /**\n     * Construct a private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {EcdsaPrivateKey}\n     */\n    static fromBytes(data) {\n        switch (data.length) {\n            case 32:\n                return EcdsaPrivateKey.fromBytesRaw(data);\n            case 50:\n                return EcdsaPrivateKey.fromBytesDer(data);\n            default:\n                throw new BadKeyError(\n                    `invalid private key length: ${data.length} bytes`\n                );\n        }\n    }\n\n    /**\n     * Construct a private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {EcdsaPrivateKey}\n     */\n    static fromBytesDer(data) {\n        if (data.length != 32 && !arrayStartsWith(data, derPrefixBytes)) {\n            throw new BadKeyError(\"invalid der header\");\n        }\n\n        return new EcdsaPrivateKey(\n            ecdsa.fromBytes(data.subarray(derPrefixBytes.length))\n        );\n    }\n\n    /**\n     * Construct a private key from bytes.\n     *\n     * @param {Uint8Array} data\n     * @returns {EcdsaPrivateKey}\n     */\n    static fromBytesRaw(data) {\n        return new EcdsaPrivateKey(ecdsa.fromBytes(data));\n    }\n\n    /**\n     * Construct a private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {EcdsaPrivateKey}\n     */\n    static fromString(text) {\n        return EcdsaPrivateKey.fromBytes(hex.decode(text));\n    }\n\n    /**\n     * Construct a private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {EcdsaPrivateKey}\n     */\n    static fromStringDer(text) {\n        return EcdsaPrivateKey.fromBytesDer(hex.decode(text));\n    }\n\n    /**\n     * Construct a private key from a hex-encoded string.\n     *\n     * @param {string} text\n     * @returns {EcdsaPrivateKey}\n     */\n    static fromStringRaw(text) {\n        return EcdsaPrivateKey.fromBytesRaw(hex.decode(text));\n    }\n\n    /**\n     * Get the public key associated with this private key.\n     *\n     * The public key can be freely given and used by other parties to verify\n     * the signatures generated by this private key.\n     *\n     * @returns {EcdsaPublicKey}\n     */\n    get publicKey() {\n        return new EcdsaPublicKey(this._keyPair.publicKey);\n    }\n\n    /**\n     * Sign a message with this private key.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {Uint8Array} - The signature bytes without the message\n     */\n    sign(bytes) {\n        return ecdsa.sign(this._keyPair.privateKey, bytes);\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        const bytes = new Uint8Array(derPrefixBytes.length + 32);\n\n        bytes.set(derPrefixBytes, 0);\n        bytes.set(\n            this._keyPair.privateKey.subarray(0, 32),\n            derPrefixBytes.length\n        );\n\n        return bytes;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        return this._keyPair.privateKey.slice(0, 32);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}