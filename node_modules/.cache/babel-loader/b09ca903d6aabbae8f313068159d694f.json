{"ast":null,"code":"import Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IKey} proto.IKey\n * @typedef {import(\"@hashgraph/proto\").IKeyList} proto.IKeyList\n * @typedef {import(\"@hashgraph/proto\").IThresholdKey} proto.IThresholdKey\n */\n\n/**\n * A list of Keys (`Key`) with an optional threshold.\n */\n\nexport default class KeyList extends Key {\n  /**\n   * @param {?Key[]} [keys]\n   * @param {?number} [threshold]\n   */\n  constructor(keys, threshold) {\n    super();\n    /**\n     * @private\n     * @type {Key[]}\n     */\n\n    this._keys = keys == null ? [] : keys;\n    /**\n     * @type {?number}\n     */\n\n    this._threshold = threshold == null ? null : threshold;\n  }\n  /**\n   * @param {Key[]} keys\n   * @returns {KeyList}\n   */\n\n\n  static of() {\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n\n    return new KeyList(keys, null);\n  }\n  /**\n   * @template T\n   * @param {ArrayLike<Key>} arrayLike\n   * @param {((key: Key) => Key)} [mapFn]\n   * @param {T} [thisArg]\n   * @returns {KeyList}\n   */\n\n\n  static from(arrayLike, mapFn, thisArg) {\n    if (mapFn == null) {\n      return new KeyList(Array.from(arrayLike));\n    }\n\n    return new KeyList(Array.from(arrayLike, mapFn, thisArg));\n  }\n  /**\n   * @returns {?number}\n   */\n\n\n  get threshold() {\n    return this._threshold;\n  }\n  /**\n   * @param {number} threshold\n   * @returns {this}\n   */\n\n\n  setThreshold(threshold) {\n    this._threshold = threshold;\n    return this;\n  }\n  /**\n   * @param {Key[]} keys\n   * @returns {number}\n   */\n\n\n  push() {\n    return this._keys.push(...arguments);\n  }\n  /**\n   * @param {number} start\n   * @param {number} deleteCount\n   * @param {Key[]} items\n   * @returns {KeyList}\n   */\n\n\n  splice(start, deleteCount) {\n    for (var _len2 = arguments.length, items = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      items[_key2 - 2] = arguments[_key2];\n    }\n\n    return new KeyList(this._keys.splice(start, deleteCount, ...items), this.threshold);\n  }\n  /**\n   * @param {number=} start\n   * @param {number=} end\n   * @returns {KeyList}\n   */\n\n\n  slice(start, end) {\n    return new KeyList(this._keys.slice(start, end), this.threshold);\n  }\n  /**\n   * @returns {Iterator<Key>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this._keys[Symbol.iterator]();\n  }\n  /**\n   * @returns {Key[]}\n   */\n\n\n  toArray() {\n    return this._keys.slice();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    return JSON.stringify({\n      threshold: this._threshold,\n      keys: this._keys.toString()\n    });\n  }\n  /**\n   * @returns {proto.IKey}\n   */\n\n\n  _toProtobufKey() {\n    const keys = this._keys.map(key => key._toProtobufKey());\n\n    if (this.threshold == null) {\n      return {\n        keyList: {\n          keys\n        }\n      };\n    } else {\n      return {\n        thresholdKey: {\n          threshold: this.threshold,\n          keys: {\n            keys\n          }\n        }\n      };\n    }\n  }\n  /**\n   * @param {proto.IKeyList} key\n   * @returns {KeyList}\n   */\n\n\n  static __fromProtobufKeyList(key) {\n    const keys = (key.keys != null ? key.keys : []).map(key => Key._fromProtobufKey(key));\n    return new KeyList(keys);\n  }\n  /**\n   * @param {proto.IThresholdKey} key\n   * @returns {KeyList}\n   */\n\n\n  static __fromProtobufThresoldKey(key) {\n    const list = KeyList.__fromProtobufKeyList(key.keys != null ? key.keys : {});\n\n    list.setThreshold(key.threshold != null ? key.threshold : 0);\n    return list;\n  }\n\n}\n\nCACHE.keyList = key => KeyList.__fromProtobufKeyList(key);\n\nCACHE.thresholdKey = key => KeyList.__fromProtobufThresoldKey(key);","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/KeyList.js"],"names":["Key","CACHE","KeyList","constructor","keys","threshold","_keys","_threshold","of","from","arrayLike","mapFn","thisArg","Array","setThreshold","push","splice","start","deleteCount","items","slice","end","Symbol","iterator","toArray","toString","JSON","stringify","_toProtobufKey","map","key","keyList","thresholdKey","__fromProtobufKeyList","_fromProtobufKey","__fromProtobufThresoldKey","list"],"mappings":"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","sourcesContent":["import Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").IKey} proto.IKey\n * @typedef {import(\"@hashgraph/proto\").IKeyList} proto.IKeyList\n * @typedef {import(\"@hashgraph/proto\").IThresholdKey} proto.IThresholdKey\n */\n\n/**\n * A list of Keys (`Key`) with an optional threshold.\n */\nexport default class KeyList extends Key {\n    /**\n     * @param {?Key[]} [keys]\n     * @param {?number} [threshold]\n     */\n    constructor(keys, threshold) {\n        super();\n\n        /**\n         * @private\n         * @type {Key[]}\n         */\n        this._keys = keys == null ? [] : keys;\n\n        /**\n         * @type {?number}\n         */\n        this._threshold = threshold == null ? null : threshold;\n    }\n\n    /**\n     * @param {Key[]} keys\n     * @returns {KeyList}\n     */\n    static of(...keys) {\n        return new KeyList(keys, null);\n    }\n\n    /**\n     * @template T\n     * @param {ArrayLike<Key>} arrayLike\n     * @param {((key: Key) => Key)} [mapFn]\n     * @param {T} [thisArg]\n     * @returns {KeyList}\n     */\n    static from(arrayLike, mapFn, thisArg) {\n        if (mapFn == null) {\n            return new KeyList(Array.from(arrayLike));\n        }\n\n        return new KeyList(Array.from(arrayLike, mapFn, thisArg));\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get threshold() {\n        return this._threshold;\n    }\n\n    /**\n     * @param {number} threshold\n     * @returns {this}\n     */\n    setThreshold(threshold) {\n        this._threshold = threshold;\n        return this;\n    }\n\n    /**\n     * @param {Key[]} keys\n     * @returns {number}\n     */\n    push(...keys) {\n        return this._keys.push(...keys);\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} deleteCount\n     * @param {Key[]} items\n     * @returns {KeyList}\n     */\n    splice(start, deleteCount, ...items) {\n        return new KeyList(\n            this._keys.splice(start, deleteCount, ...items),\n            this.threshold\n        );\n    }\n\n    /**\n     * @param {number=} start\n     * @param {number=} end\n     * @returns {KeyList}\n     */\n    slice(start, end) {\n        return new KeyList(this._keys.slice(start, end), this.threshold);\n    }\n\n    /**\n     * @returns {Iterator<Key>}\n     */\n    [Symbol.iterator]() {\n        return this._keys[Symbol.iterator]();\n    }\n\n    /**\n     * @returns {Key[]}\n     */\n    toArray() {\n        return this._keys.slice();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return JSON.stringify({\n            threshold: this._threshold,\n            keys: this._keys.toString(),\n        });\n    }\n\n    /**\n     * @returns {proto.IKey}\n     */\n    _toProtobufKey() {\n        const keys = this._keys.map((key) => key._toProtobufKey());\n\n        if (this.threshold == null) {\n            return { keyList: { keys } };\n        } else {\n            return {\n                thresholdKey: {\n                    threshold: this.threshold,\n                    keys: { keys },\n                },\n            };\n        }\n    }\n\n    /**\n     * @param {proto.IKeyList} key\n     * @returns {KeyList}\n     */\n    static __fromProtobufKeyList(key) {\n        const keys = (key.keys != null ? key.keys : []).map((key) =>\n            Key._fromProtobufKey(key)\n        );\n        return new KeyList(keys);\n    }\n\n    /**\n     * @param {proto.IThresholdKey} key\n     * @returns {KeyList}\n     */\n    static __fromProtobufThresoldKey(key) {\n        const list = KeyList.__fromProtobufKeyList(\n            key.keys != null ? key.keys : {}\n        );\n        list.setThreshold(key.threshold != null ? key.threshold : 0);\n        return list;\n    }\n}\n\nCACHE.keyList = (key) => KeyList.__fromProtobufKeyList(key);\nCACHE.thresholdKey = (key) => KeyList.__fromProtobufThresoldKey(key);\n"]},"metadata":{},"sourceType":"module"}