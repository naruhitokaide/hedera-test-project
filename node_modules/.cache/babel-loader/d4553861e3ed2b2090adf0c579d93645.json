{"ast":null,"code":"\"use strict\";\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\n\nvar utf8 = exports;\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\n\nutf8.length = function utf8_length(string) {\n  var len = 0,\n      c = 0;\n\n  for (var i = 0; i < string.length; ++i) {\n    c = string.charCodeAt(i);\n    if (c < 128) len += 1;else if (c < 2048) len += 2;else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i;\n      len += 4;\n    } else len += 3;\n  }\n\n  return len;\n};\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\n\n\nutf8.read = function utf8_read(buffer, start, end) {\n  var len = end - start;\n  if (len < 1) return \"\";\n  var parts = null,\n      chunk = [],\n      i = 0,\n      // char offset\n  t; // temporary\n\n  while (start < end) {\n    t = buffer[start++];\n    if (t < 128) chunk[i++] = t;else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n      chunk[i++] = 0xD800 + (t >> 10);\n      chunk[i++] = 0xDC00 + (t & 1023);\n    } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n      i = 0;\n    }\n  }\n\n  if (parts) {\n    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\n\n\nutf8.write = function utf8_write(string, buffer, offset) {\n  var start = offset,\n      c1,\n      // character 1\n  c2; // character 2\n\n  for (var i = 0; i < string.length; ++i) {\n    c1 = string.charCodeAt(i);\n\n    if (c1 < 128) {\n      buffer[offset++] = c1;\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192;\n      buffer[offset++] = c1 & 63 | 128;\n    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n      ++i;\n      buffer[offset++] = c1 >> 18 | 240;\n      buffer[offset++] = c1 >> 12 & 63 | 128;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    } else {\n      buffer[offset++] = c1 >> 12 | 224;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    }\n  }\n\n  return offset - start;\n};","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@protobufjs/utf8/index.js"],"names":["utf8","exports","length","utf8_length","string","len","c","i","charCodeAt","read","utf8_read","buffer","start","end","parts","chunk","t","push","String","fromCharCode","apply","slice","join","write","utf8_write","offset","c1","c2"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}