{"ast":null,"code":"import PrivateKey from \"./PrivateKey.js\";\nimport Ed25519PrivateKey from \"./Ed25519PrivateKey.js\";\nimport BadMnemonicError from \"./BadMnemonicError.js\";\nimport BadMnemonicReason from \"./BadMnemonicReason.js\";\nimport legacyWords from \"./words/legacy.js\";\nimport bip39Words from \"./words/bip39.js\";\nimport nacl from \"tweetnacl\";\nimport * as sha256 from \"./primitive/sha256.js\";\nimport * as pbkdf2 from \"./primitive/pbkdf2.js\";\nimport * as hmac from \"./primitive/hmac.js\";\nimport * as slip10 from \"./primitive/slip10.js\";\nimport * as entropy from \"./util/entropy.js\";\nimport * as random from \"./primitive/random.js\"; // import EcdsaPrivateKey from \"./EcdsaPrivateKey.js\";\n\n/**\n * Multi-word mnemonic phrase (BIP-39).\n *\n * Compatible with the official Hedera mobile\n * wallets (24-words or 22-words) and BRD (12-words).\n */\n\nexport default class Mnemonic {\n  /**\n   * @param {Object} props\n   * @param {string[]} props.words\n   * @param {boolean} props.legacy\n   * @throws {BadMnemonicError}\n   * @hideconstructor\n   * @private\n   */\n  constructor(_ref) {\n    let {\n      words,\n      legacy\n    } = _ref;\n    this.words = words;\n    this._isLegacy = legacy;\n  }\n  /**\n   * Returns a new random 24-word mnemonic from the BIP-39\n   * standard English word list.\n   *\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static generate() {\n    return Mnemonic._generate(24);\n  }\n  /**\n   * Returns a new random 12-word mnemonic from the BIP-39\n   * standard English word list.\n   *\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static generate12() {\n    return Mnemonic._generate(12);\n  }\n  /**\n   * @param {number} length\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async _generate(length) {\n    // only 12-word or 24-word lengths are supported\n    let neededEntropy;\n    if (length === 12) neededEntropy = 16;else if (length === 24) neededEntropy = 32;else {\n      throw new Error(`unsupported phrase length ${length}, only 12 or 24 are supported`);\n    } // inlined from (ISC) with heavy alternations for modern crypto\n    // https://github.com/bitcoinjs/bip39/blob/8461e83677a1d2c685d0d5a9ba2a76bd228f74c6/ts_src/index.ts#L125\n\n    const seed = await random.bytesAsync(neededEntropy);\n    const entropyBits = bytesToBinary(Array.from(seed));\n    const checksumBits = await deriveChecksumBits(seed);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = (chunks != null ? chunks : []).map(binary => bip39Words[binaryToByte(binary)]);\n    return new Mnemonic({\n      words,\n      legacy: false\n    });\n  }\n  /**\n   * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.\n   *\n   * An exception of BadMnemonicError will be thrown if the mnemonic\n   * contains unknown words or fails the checksum. An invalid mnemonic\n   * can still be used to create private keys, the exception will\n   * contain the failing mnemonic in case you wish to ignore the\n   * validation error and continue.\n   *\n   * @param {string[]} words\n   * @throws {BadMnemonicError}\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async fromWords(words) {\n    return await new Mnemonic({\n      words,\n      legacy: words.length === 22\n    })._validate();\n  }\n  /**\n   * Recover a private key from this mnemonic phrase, with an\n   * optional passphrase.\n   *\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toPrivateKey() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n    if (this._isLegacy) {\n      if (passphrase.length > 0) {\n        throw new Error(\"legacy 22-word mnemonics do not support passphrases\");\n      }\n\n      return this.toLegacyPrivateKey();\n    }\n\n    return await this._toPrivateKey(passphrase);\n  } // /**\n  //  * Recover an ecdsa private key from this mnemonic phrase, with an\n  //  * optional passphrase.\n  //  *\n  //  * @param {string} [passphrase]\n  //  * @returns {Promise<EcdsaPrivateKey>}\n  //  */\n  //      async toEcdsaPrivateKey(passphrase = \"\") {\n  //         if (this._isLegacy) {\n  //             if (passphrase.length > 0) {\n  //                 throw new Error(\n  //                     \"legacy 22-word mnemonics do not support passphrases\"\n  //                 );\n  //             }\n  //             return this.toLegacyPrivateKey();\n  //         }\n  //         return await this._toEcdsaPrivateKey(passphrase);\n  //     }\n\n  /**\n   * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.\n   *\n   * @param {string} mnemonic\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async fromString(mnemonic) {\n    return Mnemonic.fromWords(mnemonic.split(/\\s|,/));\n  }\n  /**\n   * @returns {Promise<Mnemonic>}\n   * @private\n   */\n\n\n  async _validate() {\n    // Validate that this is a valid BIP-39 mnemonic\n    // as generated by BIP-39's rules.\n    // Technically, invalid mnemonics can still be used to generate valid private keys,\n    // but if they became invalid due to user error then it will be difficult for the user\n    // to tell the difference unless they compare the generated keys.\n    // During validation, the following conditions are checked in order\n    //  1)) 24 or 12 words\n    //  2) All strings in {@link this.words} exist in the BIP-39\n    //     standard English word list (no normalization is done)\n    //  3) The calculated checksum for the mnemonic equals the\n    //     checksum encoded in the mnemonic\n    if (this._isLegacy) {\n      if (this.words.length !== 22) {\n        throw new BadMnemonicError(this, BadMnemonicReason.BadLength, []);\n      }\n\n      const unknownWordIndices = this.words.reduce((\n      /** @type {number[]} */\n      unknowns, word, index) => legacyWords.includes(word.toLowerCase()) ? unknowns : [...unknowns, index], []);\n\n      if (unknownWordIndices.length > 0) {\n        throw new BadMnemonicError(this, BadMnemonicReason.UnknownWords, unknownWordIndices);\n      }\n\n      const [seed, checksum] = entropy.legacy1(this.words, legacyWords);\n      const newChecksum = entropy.crc8(seed);\n\n      if (checksum !== newChecksum) {\n        throw new BadMnemonicError(this, BadMnemonicReason.ChecksumMismatch, []);\n      }\n    } else {\n      if (!(this.words.length === 12 || this.words.length === 24)) {\n        throw new BadMnemonicError(this, BadMnemonicReason.BadLength, []);\n      }\n\n      const unknownWordIndices = this.words.reduce((\n      /** @type {number[]} */\n      unknowns, word, index) => bip39Words.includes(word) ? unknowns : [...unknowns, index], []);\n\n      if (unknownWordIndices.length > 0) {\n        throw new BadMnemonicError(this, BadMnemonicReason.UnknownWords, unknownWordIndices);\n      } // FIXME: calculate checksum and compare\n      // https://github.com/bitcoinjs/bip39/blob/master/ts_src/index.ts#L112\n\n\n      const bits = this.words.map(word => {\n        return bip39Words.indexOf(word).toString(2).padStart(11, \"0\");\n      }).join(\"\");\n      const dividerIndex = Math.floor(bits.length / 33) * 32;\n      const entropyBits = bits.slice(0, dividerIndex);\n      const checksumBits = bits.slice(dividerIndex);\n      const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);\n      const entropyBytes =\n      /** @type {RegExpMatchArray} */\n      entropyBitsRegex.map(binaryToByte);\n      const newChecksum = await deriveChecksumBits(Uint8Array.from(entropyBytes));\n\n      if (newChecksum !== checksumBits) {\n        throw new BadMnemonicError(this, BadMnemonicReason.ChecksumMismatch, []);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * @param {string} passphrase\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async _toPrivateKey() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    const input = this.words.join(\" \");\n    const salt = `mnemonic${passphrase}`;\n    const seed = await pbkdf2.deriveKey(hmac.HashAlgorithm.Sha512, input, salt, 2048, 64);\n    const digest = await hmac.hash(hmac.HashAlgorithm.Sha512, \"ed25519 seed\", seed);\n    let keyData = digest.subarray(0, 32);\n    let chainCode = digest.subarray(32);\n\n    for (const index of [44, 3030, 0, 0]) {\n      ({\n        keyData,\n        chainCode\n      } = await slip10.derive(keyData, chainCode, index));\n    }\n\n    const keyPair = nacl.sign.keyPair.fromSeed(keyData);\n    return new PrivateKey(new Ed25519PrivateKey(keyPair, chainCode));\n  }\n  /**\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toLegacyPrivateKey() {\n    let seed;\n\n    if (this._isLegacy) {\n      [seed] = entropy.legacy1(this.words, legacyWords);\n    } else {\n      seed = await entropy.legacy2(this.words, bip39Words);\n    }\n\n    return PrivateKey.fromBytes(seed);\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    return this.words.join(\" \");\n  }\n\n}\n/**\n * @param {string} bin\n * @returns {number}\n */\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n/**\n * @param {number[]} bytes\n * @returns {string}\n */\n\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, \"0\")).join(\"\");\n}\n/**\n * @param {Uint8Array} entropyBuffer\n * @returns {Promise<string>}\n */\n\n\nasync function deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = await sha256.digest(entropyBuffer);\n  return bytesToBinary(Array.from(hash)).slice(0, CS);\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/Mnemonic.js"],"names":["PrivateKey","Ed25519PrivateKey","BadMnemonicError","BadMnemonicReason","legacyWords","bip39Words","nacl","sha256","pbkdf2","hmac","slip10","entropy","random","Mnemonic","constructor","words","legacy","_isLegacy","generate","_generate","generate12","length","neededEntropy","Error","seed","bytesAsync","entropyBits","bytesToBinary","Array","from","checksumBits","deriveChecksumBits","bits","chunks","match","map","binary","binaryToByte","fromWords","_validate","toPrivateKey","passphrase","toLegacyPrivateKey","_toPrivateKey","fromString","mnemonic","split","BadLength","unknownWordIndices","reduce","unknowns","word","index","includes","toLowerCase","UnknownWords","checksum","legacy1","newChecksum","crc8","ChecksumMismatch","indexOf","toString","padStart","join","dividerIndex","Math","floor","slice","entropyBitsRegex","entropyBytes","Uint8Array","input","salt","deriveKey","HashAlgorithm","Sha512","digest","hash","keyData","subarray","chainCode","derive","keyPair","sign","fromSeed","legacy2","fromBytes","bin","parseInt","bytes","x","entropyBuffer","ENT","CS"],"mappings":"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","sourcesContent":["import PrivateKey from \"./PrivateKey.js\";\nimport Ed25519PrivateKey from \"./Ed25519PrivateKey.js\";\nimport BadMnemonicError from \"./BadMnemonicError.js\";\nimport BadMnemonicReason from \"./BadMnemonicReason.js\";\nimport legacyWords from \"./words/legacy.js\";\nimport bip39Words from \"./words/bip39.js\";\nimport nacl from \"tweetnacl\";\nimport * as sha256 from \"./primitive/sha256.js\";\nimport * as pbkdf2 from \"./primitive/pbkdf2.js\";\nimport * as hmac from \"./primitive/hmac.js\";\nimport * as slip10 from \"./primitive/slip10.js\";\nimport * as entropy from \"./util/entropy.js\";\nimport * as random from \"./primitive/random.js\";\n// import EcdsaPrivateKey from \"./EcdsaPrivateKey.js\";\n\n/**\n * Multi-word mnemonic phrase (BIP-39).\n *\n * Compatible with the official Hedera mobile\n * wallets (24-words or 22-words) and BRD (12-words).\n */\nexport default class Mnemonic {\n    /**\n     * @param {Object} props\n     * @param {string[]} props.words\n     * @param {boolean} props.legacy\n     * @throws {BadMnemonicError}\n     * @hideconstructor\n     * @private\n     */\n    constructor({ words, legacy }) {\n        this.words = words;\n        this._isLegacy = legacy;\n    }\n\n    /**\n     * Returns a new random 24-word mnemonic from the BIP-39\n     * standard English word list.\n     *\n     * @returns {Promise<Mnemonic>}\n     */\n    static generate() {\n        return Mnemonic._generate(24);\n    }\n\n    /**\n     * Returns a new random 12-word mnemonic from the BIP-39\n     * standard English word list.\n     *\n     * @returns {Promise<Mnemonic>}\n     */\n    static generate12() {\n        return Mnemonic._generate(12);\n    }\n\n    /**\n     * @param {number} length\n     * @returns {Promise<Mnemonic>}\n     */\n    static async _generate(length) {\n        // only 12-word or 24-word lengths are supported\n        let neededEntropy;\n\n        if (length === 12) neededEntropy = 16;\n        else if (length === 24) neededEntropy = 32;\n        else {\n            throw new Error(\n                `unsupported phrase length ${length}, only 12 or 24 are supported`\n            );\n        }\n\n        // inlined from (ISC) with heavy alternations for modern crypto\n        // https://github.com/bitcoinjs/bip39/blob/8461e83677a1d2c685d0d5a9ba2a76bd228f74c6/ts_src/index.ts#L125\n        const seed = await random.bytesAsync(neededEntropy);\n        const entropyBits = bytesToBinary(Array.from(seed));\n        const checksumBits = await deriveChecksumBits(seed);\n        const bits = entropyBits + checksumBits;\n        const chunks = bits.match(/(.{1,11})/g);\n\n        const words = (chunks != null ? chunks : []).map(\n            (binary) => bip39Words[binaryToByte(binary)]\n        );\n\n        return new Mnemonic({ words, legacy: false });\n    }\n\n    /**\n     * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.\n     *\n     * An exception of BadMnemonicError will be thrown if the mnemonic\n     * contains unknown words or fails the checksum. An invalid mnemonic\n     * can still be used to create private keys, the exception will\n     * contain the failing mnemonic in case you wish to ignore the\n     * validation error and continue.\n     *\n     * @param {string[]} words\n     * @throws {BadMnemonicError}\n     * @returns {Promise<Mnemonic>}\n     */\n    static async fromWords(words) {\n        return await new Mnemonic({\n            words,\n            legacy: words.length === 22,\n        })._validate();\n    }\n\n    /**\n     * Recover a private key from this mnemonic phrase, with an\n     * optional passphrase.\n     *\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    async toPrivateKey(passphrase = \"\") {\n        if (this._isLegacy) {\n            if (passphrase.length > 0) {\n                throw new Error(\n                    \"legacy 22-word mnemonics do not support passphrases\"\n                );\n            }\n\n            return this.toLegacyPrivateKey();\n        }\n\n        return await this._toPrivateKey(passphrase);\n    }\n\n    // /**\n    //  * Recover an ecdsa private key from this mnemonic phrase, with an\n    //  * optional passphrase.\n    //  *\n    //  * @param {string} [passphrase]\n    //  * @returns {Promise<EcdsaPrivateKey>}\n    //  */\n    //      async toEcdsaPrivateKey(passphrase = \"\") {\n    //         if (this._isLegacy) {\n    //             if (passphrase.length > 0) {\n    //                 throw new Error(\n    //                     \"legacy 22-word mnemonics do not support passphrases\"\n    //                 );\n    //             }\n\n    //             return this.toLegacyPrivateKey();\n    //         }\n\n    //         return await this._toEcdsaPrivateKey(passphrase);\n    //     }\n\n    /**\n     * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.\n     *\n     * @param {string} mnemonic\n     * @returns {Promise<Mnemonic>}\n     */\n    static async fromString(mnemonic) {\n        return Mnemonic.fromWords(mnemonic.split(/\\s|,/));\n    }\n\n    /**\n     * @returns {Promise<Mnemonic>}\n     * @private\n     */\n    async _validate() {\n        // Validate that this is a valid BIP-39 mnemonic\n        // as generated by BIP-39's rules.\n\n        // Technically, invalid mnemonics can still be used to generate valid private keys,\n        // but if they became invalid due to user error then it will be difficult for the user\n        // to tell the difference unless they compare the generated keys.\n\n        // During validation, the following conditions are checked in order\n\n        //  1)) 24 or 12 words\n\n        //  2) All strings in {@link this.words} exist in the BIP-39\n        //     standard English word list (no normalization is done)\n\n        //  3) The calculated checksum for the mnemonic equals the\n        //     checksum encoded in the mnemonic\n\n        if (this._isLegacy) {\n            if (this.words.length !== 22) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.BadLength,\n                    []\n                );\n            }\n\n            const unknownWordIndices = this.words.reduce(\n                (/** @type {number[]} */ unknowns, word, index) =>\n                    legacyWords.includes(word.toLowerCase())\n                        ? unknowns\n                        : [...unknowns, index],\n                []\n            );\n\n            if (unknownWordIndices.length > 0) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.UnknownWords,\n                    unknownWordIndices\n                );\n            }\n\n            const [seed, checksum] = entropy.legacy1(this.words, legacyWords);\n            const newChecksum = entropy.crc8(seed);\n\n            if (checksum !== newChecksum) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.ChecksumMismatch,\n                    []\n                );\n            }\n        } else {\n            if (!(this.words.length === 12 || this.words.length === 24)) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.BadLength,\n                    []\n                );\n            }\n\n            const unknownWordIndices = this.words.reduce(\n                (/** @type {number[]} */ unknowns, word, index) =>\n                    bip39Words.includes(word) ? unknowns : [...unknowns, index],\n                []\n            );\n\n            if (unknownWordIndices.length > 0) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.UnknownWords,\n                    unknownWordIndices\n                );\n            }\n\n            // FIXME: calculate checksum and compare\n            // https://github.com/bitcoinjs/bip39/blob/master/ts_src/index.ts#L112\n\n            const bits = this.words\n                .map((word) => {\n                    return bip39Words\n                        .indexOf(word)\n                        .toString(2)\n                        .padStart(11, \"0\");\n                })\n                .join(\"\");\n\n            const dividerIndex = Math.floor(bits.length / 33) * 32;\n            const entropyBits = bits.slice(0, dividerIndex);\n            const checksumBits = bits.slice(dividerIndex);\n            const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);\n            const entropyBytes = /** @type {RegExpMatchArray} */ (\n                entropyBitsRegex\n            ).map(binaryToByte);\n\n            const newChecksum = await deriveChecksumBits(\n                Uint8Array.from(entropyBytes)\n            );\n\n            if (newChecksum !== checksumBits) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.ChecksumMismatch,\n                    []\n                );\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {string} passphrase\n     * @returns {Promise<PrivateKey>}\n     */\n    async _toPrivateKey(passphrase = \"\") {\n        const input = this.words.join(\" \");\n        const salt = `mnemonic${passphrase}`;\n\n        const seed = await pbkdf2.deriveKey(\n            hmac.HashAlgorithm.Sha512,\n            input,\n            salt,\n            2048,\n            64\n        );\n\n        const digest = await hmac.hash(\n            hmac.HashAlgorithm.Sha512,\n            \"ed25519 seed\",\n            seed\n        );\n\n        let keyData = digest.subarray(0, 32);\n        let chainCode = digest.subarray(32);\n\n        for (const index of [44, 3030, 0, 0]) {\n            ({ keyData, chainCode } = await slip10.derive(\n                keyData,\n                chainCode,\n                index\n            ));\n        }\n\n        const keyPair = nacl.sign.keyPair.fromSeed(keyData);\n\n        return new PrivateKey(new Ed25519PrivateKey(keyPair, chainCode));\n    }\n\n    /**\n     * @returns {Promise<PrivateKey>}\n     */\n    async toLegacyPrivateKey() {\n        let seed;\n        if (this._isLegacy) {\n            [seed] = entropy.legacy1(this.words, legacyWords);\n        } else {\n            seed = await entropy.legacy2(this.words, bip39Words);\n        }\n\n        return PrivateKey.fromBytes(seed);\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this.words.join(\" \");\n    }\n}\n\n/**\n * @param {string} bin\n * @returns {number}\n */\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\n\n/**\n * @param {number[]} bytes\n * @returns {string}\n */\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => x.toString(2).padStart(8, \"0\")).join(\"\");\n}\n\n/**\n * @param {Uint8Array} entropyBuffer\n * @returns {Promise<string>}\n */\nasync function deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = await sha256.digest(entropyBuffer);\n\n    return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\n"]},"metadata":{},"sourceType":"module"}