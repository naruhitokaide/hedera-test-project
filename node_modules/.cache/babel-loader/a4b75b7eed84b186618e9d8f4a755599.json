{"ast":null,"code":"import * as hex from \"./encoding/hex.js\";\nexport default class LedgerId {\n  /**\n   * @hideconstructor\n   * @internal\n   * @param {Uint8Array} ledgerId\n   */\n  constructor(ledgerId) {\n    /**\n     * @readonly\n     * @type {Uint8Array}\n     */\n    this._ledgerId = ledgerId;\n    Object.freeze(this);\n  }\n  /**\n   * @param {string} ledgerId\n   * @returns {LedgerId}\n   */\n\n\n  static fromString(ledgerId) {\n    switch (ledgerId) {\n      case NETNAMES[0]:\n      case \"0\":\n        return LedgerId.MAINNET;\n\n      case NETNAMES[1]:\n      case \"1\":\n        return LedgerId.TESTNET;\n\n      case NETNAMES[2]:\n      case \"2\":\n        return LedgerId.PREVIEWNET;\n\n      default:\n        {\n          let ledgerIdDecoded = hex.decode(ledgerId);\n\n          if (ledgerIdDecoded.length == 0 && ledgerId.length != 0) {\n            throw new Error(\"Default reached for fromString\");\n          } else {\n            return new LedgerId(ledgerIdDecoded);\n          }\n        }\n    }\n  }\n  /**\n   * If the ledger ID is a known value such as `[0]`, `[1]`, `[2]` this method\n   * will instead return \"mainnet\", \"testnet\", or \"previewnet\", otherwise it will\n   * hex encode the bytes.\n   *\n   * @returns {string}\n   */\n\n\n  toString() {\n    if (this._ledgerId.length == 1) {\n      switch (this._ledgerId[0]) {\n        case 0:\n          return NETNAMES[0];\n\n        case 1:\n          return NETNAMES[1];\n\n        case 2:\n          return NETNAMES[2];\n\n        default:\n          return hex.encode(this._ledgerId);\n      }\n    } else {\n      return hex.encode(this._ledgerId);\n    }\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  _toStringForChecksum() {\n    // legacy checksum logic from NetworkName\n    if (this._ledgerId.length == 1) {\n      switch (this._ledgerId[0]) {\n        case 0:\n          return \"0\";\n\n        case 1:\n          return \"1\";\n\n        case 2:\n          return \"2\";\n\n        default:\n          return hex.encode(this._ledgerId);\n      }\n    } else {\n      return hex.encode(this._ledgerId);\n    }\n  }\n  /**\n   * Using the UTF-8 byte representation of \"mainnet\", \"testnet\",\n   * or \"previewnet\" is NOT supported.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {LedgerId}\n   */\n\n\n  static fromBytes(bytes) {\n    return new LedgerId(bytes);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return this._ledgerId;\n  }\n  /**\n   * @returns {boolean}\n   */\n\n\n  isMainnet() {\n    return this.toString() == NETNAMES[0];\n  }\n  /**\n   * @returns {boolean}\n   */\n\n\n  isTestnet() {\n    return this.toString() == NETNAMES[1];\n  }\n  /**\n   * @returns {boolean}\n   */\n\n\n  isPreviewnet() {\n    return this.toString() == NETNAMES[2];\n  }\n\n}\nconst NETNAMES = [\"mainnet\", \"testnet\", \"previewnet\"];\nLedgerId.MAINNET = new LedgerId(new Uint8Array([0]));\nLedgerId.TESTNET = new LedgerId(new Uint8Array([1]));\nLedgerId.PREVIEWNET = new LedgerId(new Uint8Array([2]));","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/LedgerId.js"],"names":["hex","LedgerId","constructor","ledgerId","_ledgerId","Object","freeze","fromString","NETNAMES","MAINNET","TESTNET","PREVIEWNET","ledgerIdDecoded","decode","length","Error","toString","encode","_toStringForChecksum","fromBytes","bytes","toBytes","isMainnet","isTestnet","isPreviewnet","Uint8Array"],"mappings":"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","sourcesContent":["import * as hex from \"./encoding/hex.js\";\n\nexport default class LedgerId {\n    /**\n     * @hideconstructor\n     * @internal\n     * @param {Uint8Array} ledgerId\n     */\n    constructor(ledgerId) {\n        /**\n         * @readonly\n         * @type {Uint8Array}\n         */\n        this._ledgerId = ledgerId;\n\n        Object.freeze(this);\n    }\n\n    /**\n     * @param {string} ledgerId\n     * @returns {LedgerId}\n     */\n    static fromString(ledgerId) {\n        switch (ledgerId) {\n            case NETNAMES[0]:\n            case \"0\":\n                return LedgerId.MAINNET;\n            case NETNAMES[1]:\n            case \"1\":\n                return LedgerId.TESTNET;\n            case NETNAMES[2]:\n            case \"2\":\n                return LedgerId.PREVIEWNET;\n            default: {\n                let ledgerIdDecoded = hex.decode(ledgerId);\n                if (ledgerIdDecoded.length == 0 && ledgerId.length != 0) {\n                    throw new Error(\"Default reached for fromString\");\n                } else {\n                    return new LedgerId(ledgerIdDecoded);\n                }\n            }\n        }\n    }\n\n    /**\n     * If the ledger ID is a known value such as `[0]`, `[1]`, `[2]` this method\n     * will instead return \"mainnet\", \"testnet\", or \"previewnet\", otherwise it will\n     * hex encode the bytes.\n     *\n     * @returns {string}\n     */\n    toString() {\n        if (this._ledgerId.length == 1) {\n            switch (this._ledgerId[0]) {\n                case 0:\n                    return NETNAMES[0];\n                case 1:\n                    return NETNAMES[1];\n                case 2:\n                    return NETNAMES[2];\n                default:\n                    return hex.encode(this._ledgerId);\n            }\n        } else {\n            return hex.encode(this._ledgerId);\n        }\n    }\n\n    /**\n     * @returns {string}\n     */\n    _toStringForChecksum() {\n        // legacy checksum logic from NetworkName\n        if (this._ledgerId.length == 1) {\n            switch (this._ledgerId[0]) {\n                case 0:\n                    return \"0\";\n                case 1:\n                    return \"1\";\n                case 2:\n                    return \"2\";\n                default:\n                    return hex.encode(this._ledgerId);\n            }\n        } else {\n            return hex.encode(this._ledgerId);\n        }\n    }\n\n    /**\n     * Using the UTF-8 byte representation of \"mainnet\", \"testnet\",\n     * or \"previewnet\" is NOT supported.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {LedgerId}\n     */\n    static fromBytes(bytes) {\n        return new LedgerId(bytes);\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return this._ledgerId;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isMainnet() {\n        return this.toString() == NETNAMES[0];\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTestnet() {\n        return this.toString() == NETNAMES[1];\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isPreviewnet() {\n        return this.toString() == NETNAMES[2];\n    }\n}\n\nconst NETNAMES = [\"mainnet\", \"testnet\", \"previewnet\"];\n\nLedgerId.MAINNET = new LedgerId(new Uint8Array([0]));\n\nLedgerId.TESTNET = new LedgerId(new Uint8Array([1]));\n\nLedgerId.PREVIEWNET = new LedgerId(new Uint8Array([2]));\n"]},"metadata":{},"sourceType":"module"}