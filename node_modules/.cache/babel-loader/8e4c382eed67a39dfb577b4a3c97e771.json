{"ast":null,"code":"import * as utf8 from \"../encoding/utf8.js\";\n/**\n * @typedef {import(\"./hmac.js\").HashAlgorithm} HashAlgorithm\n */\n\n/**\n * @param {HashAlgorithm} algorithm\n * @param {Uint8Array | string} password\n * @param {Uint8Array | string} salt\n * @param {number} iterations\n * @param {number} length\n * @returns {Promise<Uint8Array>}\n */\n\nexport async function deriveKey(algorithm, password, salt, iterations, length) {\n  const pass = typeof password === \"string\" ? // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8\n  // should be fine if only valid ASCII characters are used in the password\n  utf8.encode(password) : password;\n  const nacl = typeof salt === \"string\" ? utf8.encode(salt) : salt;\n\n  try {\n    const key = await window.crypto.subtle.importKey(\"raw\", pass, {\n      name: \"PBKDF2\",\n      hash: algorithm\n    }, false, [\"deriveBits\"]);\n    return new Uint8Array(await window.crypto.subtle.deriveBits({\n      name: \"PBKDF2\",\n      hash: algorithm,\n      salt: nacl,\n      iterations\n    }, key, length << 3));\n  } catch {\n    throw new Error(\"(BUG) Non-Exhaustive switch statement for algorithms\");\n  }\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/cryptography/src/primitive/pbkdf2.browser.js"],"names":["utf8","deriveKey","algorithm","password","salt","iterations","length","pass","encode","nacl","key","window","crypto","subtle","importKey","name","hash","Uint8Array","deriveBits","Error"],"mappings":"AAAA,OAAO,KAAKA,IAAZ,MAAsB,qBAAtB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeC,SAAf,CAAyBC,SAAzB,EAAoCC,QAApC,EAA8CC,IAA9C,EAAoDC,UAApD,EAAgEC,MAAhE,EAAwE;AAC3E,QAAMC,IAAI,GACN,OAAOJ,QAAP,KAAoB,QAApB,GACM;AACA;AACAH,EAAAA,IAAI,CAACQ,MAAL,CAAYL,QAAZ,CAHN,GAIMA,QALV;AAOA,QAAMM,IAAI,GAAG,OAAOL,IAAP,KAAgB,QAAhB,GAA2BJ,IAAI,CAACQ,MAAL,CAAYJ,IAAZ,CAA3B,GAA+CA,IAA5D;;AAEA,MAAI;AACA,UAAMM,GAAG,GAAG,MAAMC,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBC,SAArB,CACd,KADc,EAEdP,IAFc,EAGd;AACIQ,MAAAA,IAAI,EAAE,QADV;AAEIC,MAAAA,IAAI,EAAEd;AAFV,KAHc,EAOd,KAPc,EAQd,CAAC,YAAD,CARc,CAAlB;AAWA,WAAO,IAAIe,UAAJ,CACH,MAAMN,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBK,UAArB,CACF;AACIH,MAAAA,IAAI,EAAE,QADV;AAEIC,MAAAA,IAAI,EAAEd,SAFV;AAGIE,MAAAA,IAAI,EAAEK,IAHV;AAIIJ,MAAAA;AAJJ,KADE,EAOFK,GAPE,EAQFJ,MAAM,IAAI,CARR,CADH,CAAP;AAYH,GAxBD,CAwBE,MAAM;AACJ,UAAM,IAAIa,KAAJ,CAAU,sDAAV,CAAN;AACH;AACJ","sourcesContent":["import * as utf8 from \"../encoding/utf8.js\";\n\n/**\n * @typedef {import(\"./hmac.js\").HashAlgorithm} HashAlgorithm\n */\n\n/**\n * @param {HashAlgorithm} algorithm\n * @param {Uint8Array | string} password\n * @param {Uint8Array | string} salt\n * @param {number} iterations\n * @param {number} length\n * @returns {Promise<Uint8Array>}\n */\nexport async function deriveKey(algorithm, password, salt, iterations, length) {\n    const pass =\n        typeof password === \"string\"\n            ? // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8\n              // should be fine if only valid ASCII characters are used in the password\n              utf8.encode(password)\n            : password;\n\n    const nacl = typeof salt === \"string\" ? utf8.encode(salt) : salt;\n\n    try {\n        const key = await window.crypto.subtle.importKey(\n            \"raw\",\n            pass,\n            {\n                name: \"PBKDF2\",\n                hash: algorithm,\n            },\n            false,\n            [\"deriveBits\"]\n        );\n\n        return new Uint8Array(\n            await window.crypto.subtle.deriveBits(\n                {\n                    name: \"PBKDF2\",\n                    hash: algorithm,\n                    salt: nacl,\n                    iterations,\n                },\n                key,\n                length << 3\n            )\n        );\n    } catch {\n        throw new Error(\"(BUG) Non-Exhaustive switch statement for algorithms\");\n    }\n}\n"]},"metadata":{},"sourceType":"module"}