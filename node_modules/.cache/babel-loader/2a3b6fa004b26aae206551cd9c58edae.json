{"ast":null,"code":"import Hbar from \"../Hbar.js\";\nimport Transaction, { TRANSACTION_REGISTRY, CHUNK_SIZE } from \"../transaction/Transaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport FileId from \"./FileId.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").TransactionBody} proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionResponse} proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").IFileAppendTransactionBody} proto.IFileAppendTransactionBody\n * @typedef {import(\"@hashgraph/proto\").IFileID} proto.IFileID\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<Channel, *>} Client\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n */\n\n/**\n * A transaction specifically to append data to a file on the network.\n *\n * If a file has multiple keys, all keys must sign to modify its contents.\n */\n\nexport default class FileAppendTransaction extends Transaction {\n  /**\n   * @param {object} [props]\n   * @param {FileId | string} [props.fileId]\n   * @param {Uint8Array | string} [props.contents]\n   * @param {number} [props.maxChunks]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    /**\n     * @private\n     * @type {?FileId}\n     */\n\n    this._fileId = null;\n    /**\n     * @private\n     * @type {?Uint8Array}\n     */\n\n    this._contents = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._maxChunks = 20;\n    this.setMaxTransactionFee(new Hbar(5));\n\n    if (props.fileId != null) {\n      this.setFileId(props.fileId);\n    }\n\n    if (props.contents != null) {\n      this.setContents(props.contents);\n    }\n\n    if (props.maxChunks != null) {\n      this.setMaxChunks(props.maxChunks);\n    }\n    /** @type {number} */\n\n\n    this._startIndex = 0;\n    /** @type {TransactionId[]} */\n\n    this._transactionIds = [];\n  }\n  /**\n   * @internal\n   * @param {proto.ITransaction[]} transactions\n   * @param {proto.ISignedTransaction[]} signedTransactions\n   * @param {TransactionId[]} transactionIds\n   * @param {AccountId[]} nodeIds\n   * @param {proto.ITransactionBody[]} bodies\n   * @returns {FileAppendTransaction}\n   */\n\n\n  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {\n    const body = bodies[0];\n    const append =\n    /** @type {proto.IFileAppendTransactionBody} */\n    body.fileAppend;\n    let contents;\n\n    for (let i = 0; i < bodies.length; i += nodeIds.length) {\n      const fileAppend =\n      /** @type {proto.IFileAppendTransactionBody} */\n      bodies[i].fileAppend;\n\n      if (fileAppend.contents == null) {\n        break;\n      }\n\n      if (contents == null) {\n        contents = new Uint8Array(\n        /** @type {Uint8Array} */\n        fileAppend.contents);\n        continue;\n      }\n      /** @type {Uint8Array} */\n\n\n      const concat = new Uint8Array(contents.length +\n      /** @type {Uint8Array} */\n      fileAppend.contents.length);\n      concat.set(contents, 0);\n      concat.set(\n      /** @type {Uint8Array} */\n      fileAppend.contents, contents.length);\n      contents = concat;\n    }\n\n    return Transaction._fromProtobufTransactions(new FileAppendTransaction({\n      fileId: append.fileID != null ? FileId._fromProtobuf(\n      /** @type {proto.IFileID} */\n      append.fileID) : undefined,\n      contents: contents\n    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);\n  }\n  /**\n   * @param {TransactionId} transactionId\n   * @returns {this}\n   */\n\n\n  setTransactionId(transactionId) {\n    this._requireNotFrozen();\n\n    if (transactionId.accountId == null || transactionId.validStart == null) {\n      throw new Error(\"`FileAppendTransaction` does not support `TransactionId` built from `nonce`\");\n    }\n\n    this._transactionIds = [transactionId];\n    return this;\n  }\n  /**\n   * @returns {?FileId}\n   */\n\n\n  get fileId() {\n    return this._fileId;\n  }\n  /**\n   * Set the keys which must sign any transactions modifying this file. Required.\n   *\n   * All keys must sign to modify the file's contents or keys. No key is required\n   * to sign for extending the expiration time (except the one for the operator account\n   * paying for the transaction). Only one key must sign to delete the file, however.\n   *\n   * To require more than one key to sign to delete a file, add them to a\n   * KeyList and pass that here.\n   *\n   * The network currently requires a file to have at least one key (or key list or threshold key)\n   * but this requirement may be lifted in the future.\n   *\n   * @param {FileId | string} fileId\n   * @returns {this}\n   */\n\n\n  setFileId(fileId) {\n    this._requireNotFrozen();\n\n    this._fileId = typeof fileId === \"string\" ? FileId.fromString(fileId) : fileId.clone();\n    return this;\n  }\n  /**\n   * @returns {?Uint8Array}\n   */\n\n\n  get contents() {\n    return this._contents;\n  }\n  /**\n   * Set the given byte array as the file's contents.\n   *\n   * This may be omitted to append an empty file.\n   *\n   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n   * network; if you exceed this you may receive a HederaPreCheckStatusException\n   * with Status#TransactionOversize.\n   *\n   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n   * transaction with the first chunk and then use FileAppendTransaction with\n   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n   *\n   * @param {Uint8Array | string} contents\n   * @returns {this}\n   */\n\n\n  setContents(contents) {\n    this._requireNotFrozen();\n\n    this._contents = contents instanceof Uint8Array ? contents : utf8.encode(contents);\n    return this;\n  }\n  /**\n   * @returns {?number}\n   */\n\n\n  get maxChunks() {\n    return this._maxChunks;\n  }\n  /**\n   * @param {number} maxChunks\n   * @returns {this}\n   */\n\n\n  setMaxChunks(maxChunks) {\n    this._requireNotFrozen();\n\n    this._maxChunks = maxChunks;\n    return this;\n  }\n  /**\n   * Freeze this transaction from further modification to prepare for\n   * signing or serialization.\n   *\n   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n   * nodes to prepare this transaction for.\n   *\n   * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {this}\n   */\n\n\n  freezeWith(client) {\n    super.freezeWith(client);\n\n    if (this._contents == null) {\n      return this;\n    }\n\n    const chunks = Math.floor((this._contents.length + (CHUNK_SIZE - 1)) / CHUNK_SIZE);\n\n    if (chunks > this._maxChunks) {\n      throw new Error(`Contents with size ${this._contents.length} too long for ${this._maxChunks} chunks`);\n    }\n\n    let nextTransactionId = this.transactionId;\n    super._transactions = [];\n    super._transactionIds = [];\n    super._signedTransactions = [];\n    super._nextTransactionIndex = 0;\n\n    for (let chunk = 0; chunk < chunks; chunk++) {\n      this._startIndex = chunk * CHUNK_SIZE;\n\n      this._transactionIds.push(nextTransactionId);\n\n      for (const nodeAccountId of this._nodeIds) {\n        this._signedTransactions.push(this._makeSignedTransaction(nodeAccountId));\n      }\n\n      nextTransactionId = new TransactionId(\n      /** @type {AccountId} */\n      nextTransactionId.accountId, new Timestamp(\n      /** @type {Timestamp} */\n      nextTransactionId.validStart.seconds,\n      /** @type {Timestamp} */\n      nextTransactionId.validStart.nanos.add(1)));\n      super._nextTransactionIndex = this._nextTransactionIndex + 1;\n    }\n\n    this._startIndex = 0;\n    super._nextTransactionIndex = 0;\n    return this;\n  }\n  /**\n   * @returns {ScheduleCreateTransaction}\n   */\n\n\n  schedule() {\n    this._requireNotFrozen();\n\n    if (this._contents != null && this._contents.length > CHUNK_SIZE) {\n      throw new Error(`cannot scheduled \\`FileAppendTransaction\\` with message over ${CHUNK_SIZE} bytes`);\n    }\n\n    return super.schedule();\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<TransactionResponse>}\n   */\n\n\n  async execute(client) {\n    return (await this.executeAll(client))[0];\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<TransactionResponse[]>}\n   */\n\n\n  async executeAll(client) {\n    if (!super._isFrozen()) {\n      this.freezeWith(client);\n    } // on execute, sign each transaction with the operator, if present\n    // and we are signing a transaction that used the default transaction ID\n\n\n    const transactionId = this.transactionId;\n    const operatorAccountId = client.operatorAccountId;\n\n    if (operatorAccountId != null && operatorAccountId.equals(\n    /** @type {AccountId} */\n    transactionId.accountId)) {\n      await super.signWithOperator(client);\n    }\n\n    const responses = [];\n\n    for (let i = 0; i < this._transactionIds.length; i++) {\n      const response = await super.execute(client);\n      await response.getReceipt(client);\n      responses.push(response);\n    }\n\n    return responses;\n  }\n  /**\n   * @param {Client} client\n   */\n\n\n  _validateChecksums(client) {\n    if (this._fileId != null) {\n      this._fileId.validateChecksum(client);\n    }\n  }\n  /**\n   * @override\n   * @internal\n   * @param {Channel} channel\n   * @param {proto.ITransaction} request\n   * @returns {Promise<proto.ITransactionResponse>}\n   */\n\n\n  _execute(channel, request) {\n    return channel.file.appendContent(request);\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {NonNullable<proto.TransactionBody[\"data\"]>}\n   */\n\n\n  _getTransactionDataCase() {\n    return \"fileAppend\";\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {proto.IFileAppendTransactionBody}\n   */\n\n\n  _makeTransactionData() {\n    const length = this._contents != null ? this._contents.length : 0;\n    let endIndex = this._startIndex + CHUNK_SIZE;\n\n    if (endIndex > length) {\n      endIndex = length;\n    }\n\n    return {\n      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,\n      contents: this._contents != null ? this._contents.slice(this._startIndex, endIndex) : null\n    };\n  }\n\n} // eslint-disable-next-line @typescript-eslint/unbound-method\n\nTRANSACTION_REGISTRY.set(\"fileAppend\", FileAppendTransaction._fromProtobuf);","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/file/FileAppendTransaction.js"],"names":["Hbar","Transaction","TRANSACTION_REGISTRY","CHUNK_SIZE","utf8","FileId","TransactionId","Timestamp","FileAppendTransaction","constructor","props","_fileId","_contents","_maxChunks","setMaxTransactionFee","fileId","setFileId","contents","setContents","maxChunks","setMaxChunks","_startIndex","_transactionIds","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","body","append","fileAppend","i","length","Uint8Array","concat","set","_fromProtobufTransactions","fileID","undefined","setTransactionId","transactionId","_requireNotFrozen","accountId","validStart","Error","fromString","clone","encode","freezeWith","client","chunks","Math","floor","nextTransactionId","_transactions","_signedTransactions","_nextTransactionIndex","chunk","push","nodeAccountId","_nodeIds","_makeSignedTransaction","seconds","nanos","add","schedule","execute","executeAll","_isFrozen","operatorAccountId","equals","signWithOperator","responses","response","getReceipt","_validateChecksums","validateChecksum","_execute","channel","request","file","appendContent","_getTransactionDataCase","_makeTransactionData","endIndex","_toProtobuf","slice"],"mappings":"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","sourcesContent":["import Hbar from \"../Hbar.js\";\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n    CHUNK_SIZE,\n} from \"../transaction/Transaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport FileId from \"./FileId.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").ITransaction} proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").ISignedTransaction} proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").TransactionBody} proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionBody} proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").ITransactionResponse} proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").IFileAppendTransactionBody} proto.IFileAppendTransactionBody\n * @typedef {import(\"@hashgraph/proto\").IFileID} proto.IFileID\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<Channel, *>} Client\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n */\n\n/**\n * A transaction specifically to append data to a file on the network.\n *\n * If a file has multiple keys, all keys must sign to modify its contents.\n */\nexport default class FileAppendTransaction extends Transaction {\n    /**\n     * @param {object} [props]\n     * @param {FileId | string} [props.fileId]\n     * @param {Uint8Array | string} [props.contents]\n     * @param {number} [props.maxChunks]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._fileId = null;\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._contents = null;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._maxChunks = 20;\n\n        this.setMaxTransactionFee(new Hbar(5));\n\n        if (props.fileId != null) {\n            this.setFileId(props.fileId);\n        }\n\n        if (props.contents != null) {\n            this.setContents(props.contents);\n        }\n\n        if (props.maxChunks != null) {\n            this.setMaxChunks(props.maxChunks);\n        }\n\n        /** @type {number} */\n        this._startIndex = 0;\n\n        /** @type {TransactionId[]} */\n        this._transactionIds = [];\n    }\n\n    /**\n     * @internal\n     * @param {proto.ITransaction[]} transactions\n     * @param {proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {proto.ITransactionBody[]} bodies\n     * @returns {FileAppendTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies\n    ) {\n        const body = bodies[0];\n        const append = /** @type {proto.IFileAppendTransactionBody} */ (\n            body.fileAppend\n        );\n\n        let contents;\n        for (let i = 0; i < bodies.length; i += nodeIds.length) {\n            const fileAppend = /** @type {proto.IFileAppendTransactionBody} */ (\n                bodies[i].fileAppend\n            );\n            if (fileAppend.contents == null) {\n                break;\n            }\n\n            if (contents == null) {\n                contents = new Uint8Array(\n                    /** @type {Uint8Array} */ (fileAppend.contents)\n                );\n                continue;\n            }\n\n            /** @type {Uint8Array} */\n            const concat = new Uint8Array(\n                contents.length +\n                    /** @type {Uint8Array} */ (fileAppend.contents).length\n            );\n            concat.set(contents, 0);\n            concat.set(\n                /** @type {Uint8Array} */ (fileAppend.contents),\n                contents.length\n            );\n            contents = concat;\n        }\n\n        return Transaction._fromProtobufTransactions(\n            new FileAppendTransaction({\n                fileId:\n                    append.fileID != null\n                        ? FileId._fromProtobuf(\n                              /** @type {proto.IFileID} */ (append.fileID)\n                          )\n                        : undefined,\n                contents: contents,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies\n        );\n    }\n\n    /**\n     * @param {TransactionId} transactionId\n     * @returns {this}\n     */\n    setTransactionId(transactionId) {\n        this._requireNotFrozen();\n\n        if (\n            transactionId.accountId == null ||\n            transactionId.validStart == null\n        ) {\n            throw new Error(\n                \"`FileAppendTransaction` does not support `TransactionId` built from `nonce`\"\n            );\n        }\n\n        this._transactionIds = [transactionId];\n\n        return this;\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get fileId() {\n        return this._fileId;\n    }\n\n    /**\n     * Set the keys which must sign any transactions modifying this file. Required.\n     *\n     * All keys must sign to modify the file's contents or keys. No key is required\n     * to sign for extending the expiration time (except the one for the operator account\n     * paying for the transaction). Only one key must sign to delete the file, however.\n     *\n     * To require more than one key to sign to delete a file, add them to a\n     * KeyList and pass that here.\n     *\n     * The network currently requires a file to have at least one key (or key list or threshold key)\n     * but this requirement may be lifted in the future.\n     *\n     * @param {FileId | string} fileId\n     * @returns {this}\n     */\n    setFileId(fileId) {\n        this._requireNotFrozen();\n        this._fileId =\n            typeof fileId === \"string\"\n                ? FileId.fromString(fileId)\n                : fileId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get contents() {\n        return this._contents;\n    }\n\n    /**\n     * Set the given byte array as the file's contents.\n     *\n     * This may be omitted to append an empty file.\n     *\n     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n     * network; if you exceed this you may receive a HederaPreCheckStatusException\n     * with Status#TransactionOversize.\n     *\n     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n     * transaction with the first chunk and then use FileAppendTransaction with\n     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n     *\n     * @param {Uint8Array | string} contents\n     * @returns {this}\n     */\n    setContents(contents) {\n        this._requireNotFrozen();\n        this._contents =\n            contents instanceof Uint8Array ? contents : utf8.encode(contents);\n\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get maxChunks() {\n        return this._maxChunks;\n    }\n\n    /**\n     * @param {number} maxChunks\n     * @returns {this}\n     */\n    setMaxChunks(maxChunks) {\n        this._requireNotFrozen();\n        this._maxChunks = maxChunks;\n        return this;\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        super.freezeWith(client);\n\n        if (this._contents == null) {\n            return this;\n        }\n\n        const chunks = Math.floor(\n            (this._contents.length + (CHUNK_SIZE - 1)) / CHUNK_SIZE\n        );\n\n        if (chunks > this._maxChunks) {\n            throw new Error(\n                `Contents with size ${this._contents.length} too long for ${this._maxChunks} chunks`\n            );\n        }\n\n        let nextTransactionId = this.transactionId;\n\n        super._transactions = [];\n        super._transactionIds = [];\n        super._signedTransactions = [];\n        super._nextTransactionIndex = 0;\n\n        for (let chunk = 0; chunk < chunks; chunk++) {\n            this._startIndex = chunk * CHUNK_SIZE;\n\n            this._transactionIds.push(nextTransactionId);\n\n            for (const nodeAccountId of this._nodeIds) {\n                this._signedTransactions.push(\n                    this._makeSignedTransaction(nodeAccountId)\n                );\n            }\n\n            nextTransactionId = new TransactionId(\n                /** @type {AccountId} */ (nextTransactionId.accountId),\n                new Timestamp(\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).seconds,\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).nanos.add(1)\n                )\n            );\n\n            super._nextTransactionIndex = this._nextTransactionIndex + 1;\n        }\n\n        this._startIndex = 0;\n        super._nextTransactionIndex = 0;\n\n        return this;\n    }\n\n    /**\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (this._contents != null && this._contents.length > CHUNK_SIZE) {\n            throw new Error(\n                `cannot scheduled \\`FileAppendTransaction\\` with message over ${CHUNK_SIZE} bytes`\n            );\n        }\n\n        return super.schedule();\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<TransactionResponse>}\n     */\n    async execute(client) {\n        return (await this.executeAll(client))[0];\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<TransactionResponse[]>}\n     */\n    async executeAll(client) {\n        if (!super._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        // on execute, sign each transaction with the operator, if present\n        // and we are signing a transaction that used the default transaction ID\n\n        const transactionId = this.transactionId;\n        const operatorAccountId = client.operatorAccountId;\n\n        if (\n            operatorAccountId != null &&\n            operatorAccountId.equals(\n                /** @type {AccountId} */ (transactionId.accountId)\n            )\n        ) {\n            await super.signWithOperator(client);\n        }\n\n        const responses = [];\n        for (let i = 0; i < this._transactionIds.length; i++) {\n            const response = await super.execute(client);\n            await response.getReceipt(client);\n            responses.push(response);\n        }\n\n        return responses;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    _validateChecksums(client) {\n        if (this._fileId != null) {\n            this._fileId.validateChecksum(client);\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {proto.ITransaction} request\n     * @returns {Promise<proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.file.appendContent(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"fileAppend\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {proto.IFileAppendTransactionBody}\n     */\n    _makeTransactionData() {\n        const length = this._contents != null ? this._contents.length : 0;\n        let endIndex = this._startIndex + CHUNK_SIZE;\n        if (endIndex > length) {\n            endIndex = length;\n        }\n\n        return {\n            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,\n            contents:\n                this._contents != null\n                    ? this._contents.slice(this._startIndex, endIndex)\n                    : null,\n        };\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nTRANSACTION_REGISTRY.set(\"fileAppend\", FileAppendTransaction._fromProtobuf);\n"]},"metadata":{},"sourceType":"module"}