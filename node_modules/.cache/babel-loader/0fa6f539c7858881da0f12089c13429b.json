{"ast":null,"code":"import GrpcServiceError from \"./grpc/GrpcServiceError.js\";\nimport GrpcStatus from \"./grpc/GrpcStatus.js\";\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * @enum {string}\n */\n\nexport const ExecutionState = {\n  Finished: \"Finished\",\n  Retry: \"Retry\",\n  Error: \"Error\"\n};\nexport const RST_STREAM = /\\brst[^0-9a-zA-Z]stream\\b/i;\n/**\n * @abstract\n * @internal\n * @template RequestT\n * @template ResponseT\n * @template OutputT\n */\n\nexport default class Executable {\n  constructor() {\n    /**\n     * The number of times we can retry the grpc call\n     *\n     * @private\n     * @type {number}\n     */\n    this._maxAttempts = 10;\n    /**\n     * The index of the next transaction to be executed.\n     *\n     * @protected\n     * @type {number}\n     */\n\n    this._nextNodeIndex = 0;\n    /**\n     * List of node account IDs for each transaction that has been\n     * built.\n     *\n     * @internal\n     * @type {AccountId[]}\n     */\n\n    this._nodeIds = [];\n    /** @type {number | null} */\n\n    this._minBackoff = null;\n    /** @type {number | null} */\n\n    this._maxBackoff = null;\n  }\n  /**\n   * @returns {?AccountId[]}\n   */\n\n\n  get nodeAccountIds() {\n    return this._nodeIds.length != 0 ? this._nodeIds : null;\n  }\n  /**\n   * @param {AccountId[]} nodeIds\n   * @returns {this}\n   */\n\n\n  setNodeAccountIds(nodeIds) {\n    this._nodeIds = nodeIds;\n    return this;\n  }\n  /**\n   * @deprecated\n   * @returns {number}\n   */\n\n\n  get maxRetries() {\n    console.warn(\"Deprecated: use maxAttempts instead\");\n    return this.maxAttempts;\n  }\n  /**\n   * @param {number} maxRetries\n   * @returns {this}\n   */\n\n\n  setMaxRetries(maxRetries) {\n    console.warn(\"Deprecated: use setMaxAttempts() instead\");\n    return this.setMaxAttempts(maxRetries);\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get maxAttempts() {\n    return this._maxAttempts;\n  }\n  /**\n   * @param {number} maxAttempts\n   * @returns {this}\n   */\n\n\n  setMaxAttempts(maxAttempts) {\n    this._maxAttempts = maxAttempts;\n    return this;\n  }\n  /**\n   * @param {number} minBackoff\n   * @returns {this}\n   */\n\n\n  setMinBackoff(minBackoff) {\n    if (minBackoff == null) {\n      throw new Error(\"minBackoff cannot be null.\");\n    } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {\n      throw new Error(\"minBackoff cannot be larger than maxBackoff.\");\n    }\n\n    this._minBackoff = minBackoff;\n    return this;\n  }\n  /**\n   * @returns {number | null}\n   */\n\n\n  get minBackoff() {\n    return this._minBackoff;\n  }\n  /**\n   * @param {?number} maxBackoff\n   * @returns {this}\n   */\n\n\n  setMaxBackoff(maxBackoff) {\n    if (maxBackoff == null) {\n      throw new Error(\"maxBackoff cannot be null.\");\n    } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {\n      throw new Error(\"maxBackoff cannot be smaller than minBackoff.\");\n    }\n\n    this._maxBackoff = maxBackoff;\n    return this;\n  }\n  /**\n   * @returns {number | null}\n   */\n\n\n  get maxBackoff() {\n    return this._maxBackoff;\n  } // /**\n  //  * @param {?number} minBackoff\n  //  * @param {?number} maxBackoff\n  //  * @returns {this}\n  //  */\n  // _setBackoff(minBackoff, maxBackoff) {\n  //     if (minBackoff == null) {\n  //         throw new Error(\"minBackoff cannot be null.\");\n  //     }\n  //     if (maxBackoff == null) {\n  //         throw new Error(\"maxBackoff cannot be null.\");\n  //     }\n  //     if (minBackoff > maxBackoff) {\n  //         throw new Error(\"minBackoff cannot be larger than maxBackoff.\");\n  //     }\n  //     this._minBackoff = minBackoff;\n  //     this._maxAttempts = maxBackoff;\n  //     return this;\n  // }\n  // /**\n  //  * @typedef {Object} Backoff\n  //  * @property {number | null} minBackoff\n  //  * @property {number | null} maxBackoff\n  //  * @returns {Backoff}\n  //  */\n  // get _backoff() {\n  //     return { minBackoff: this._minBackoff, maxBackoff: this._maxBackoff };\n  // }\n\n  /**\n   * @abstract\n   * @protected\n   * @param {import(\"./client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<void>}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _beforeExecute(client) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @protected\n   * @returns {Promise<RequestT>}\n   */\n\n\n  _makeRequestAsync() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @internal\n   * @param {RequestT} request\n   * @param {ResponseT} response\n   * @returns {Error}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapStatusError(request, response) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @protected\n   * @param {ResponseT} response\n   * @param {AccountId} nodeAccountId\n   * @param {RequestT} request\n   * @returns {Promise<OutputT>}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapResponse(response, nodeAccountId, request) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @internal\n   * @param {Channel} channel\n   * @param {RequestT} request\n   * @returns {Promise<ResponseT>}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _execute(channel, request) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @protected\n   * @returns {AccountId}\n   */\n\n\n  _getNodeAccountId() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @protected\n   * @returns {TransactionId}\n   */\n\n\n  _getTransactionId() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @protected\n   * @returns {void}\n   */\n\n\n  _advanceRequest() {\n    // each time we move our cursor to the next transaction\n    // wrapping around to ensure we are cycling\n    this._nextNodeIndex = (this._nextNodeIndex + 1) % this._nodeIds.length;\n  }\n  /**\n   * @abstract\n   * @protected\n   * @param {RequestT} request\n   * @param {ResponseT} response\n   * @returns {ExecutionState}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _shouldRetry(request, response) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @protected\n   * @param {GrpcServiceError} error\n   * @returns {boolean}\n   */\n\n\n  _shouldRetryExceptionally(error) {\n    return error.status._code === GrpcStatus.Unavailable._code || error.status._code === GrpcStatus.ResourceExhausted._code || error.status._code === GrpcStatus.Internal._code && RST_STREAM.test(error.message);\n  }\n  /**\n   * @template {Channel} ChannelT\n   * @template MirrorChannelT\n   * @param {import(\"./client/Client.js\").default<ChannelT, MirrorChannelT>} client\n   * @returns {Promise<OutputT>}\n   */\n\n\n  async execute(client) {\n    await this._beforeExecute(client);\n\n    if (this._maxBackoff == null) {\n      this._maxBackoff = client.maxBackoff;\n    }\n\n    if (this._minBackoff == null) {\n      this._minBackoff = client.minBackoff;\n    }\n\n    const maxAttempts = client._maxAttempts != null ? client._maxAttempts : this._maxAttempts;\n\n    for (let attempt = 1\n    /* loop forever */\n    ;; attempt += 1) {\n      const nodeAccountId = this._getNodeAccountId();\n\n      const node = client._network.getNode(nodeAccountId);\n\n      if (node == null) {\n        throw new Error(`NodeAccountId not recognized: ${nodeAccountId.toString()}`);\n      }\n\n      const channel = node.getChannel();\n      const request = await this._makeRequestAsync(); // advance the internal index\n      // non-free queries and transactions map to more than 1 actual transaction and this will cause\n      // the next invocation of makeRequest to return the _next_ transaction\n\n      this._advanceRequest();\n\n      let response;\n\n      if (!node.isHealthy()) {\n        await node.wait();\n      }\n\n      try {\n        response = await this._execute(channel, request);\n      } catch (err) {\n        const error = GrpcServiceError._fromResponse(\n        /** @type {Error} */\n        err);\n\n        if (error instanceof GrpcServiceError && this._shouldRetryExceptionally(error) && attempt <= maxAttempts) {\n          node.increaseDelay();\n          continue;\n        }\n\n        throw err;\n      }\n\n      node.decreaseDelay();\n\n      switch (this._shouldRetry(request, response)) {\n        case ExecutionState.Retry:\n          await delayForAttempt(attempt, this._minBackoff, this._maxBackoff);\n          continue;\n\n        case ExecutionState.Finished:\n          return this._mapResponse(response, nodeAccountId, request);\n\n        case ExecutionState.Error:\n          throw this._mapStatusError(request, response);\n\n        default:\n          throw new Error(\"(BUG) non-exhuastive switch statement for `ExecutionState`\");\n      }\n    }\n  }\n\n}\n/**\n * @param {number} attempt\n * @param {number} minBackoff\n * @param {number} maxBackoff\n * @returns {Promise<void>}\n */\n\nfunction delayForAttempt(attempt, minBackoff, maxBackoff) {\n  // 0.1s, 0.2s, 0.4s, 0.8s, ...\n  const ms = Math.min(Math.floor(minBackoff * Math.pow(2, attempt)), maxBackoff);\n  return new Promise(resolve => setTimeout(resolve, ms));\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/Executable.js"],"names":["GrpcServiceError","GrpcStatus","ExecutionState","Finished","Retry","Error","RST_STREAM","Executable","constructor","_maxAttempts","_nextNodeIndex","_nodeIds","_minBackoff","_maxBackoff","nodeAccountIds","length","setNodeAccountIds","nodeIds","maxRetries","console","warn","maxAttempts","setMaxRetries","setMaxAttempts","setMinBackoff","minBackoff","setMaxBackoff","maxBackoff","_beforeExecute","client","_makeRequestAsync","_mapStatusError","request","response","_mapResponse","nodeAccountId","_execute","channel","_getNodeAccountId","_getTransactionId","_advanceRequest","_shouldRetry","_shouldRetryExceptionally","error","status","_code","Unavailable","ResourceExhausted","Internal","test","message","execute","attempt","node","_network","getNode","toString","getChannel","isHealthy","wait","err","_fromResponse","increaseDelay","decreaseDelay","delayForAttempt","ms","Math","min","floor","pow","Promise","resolve","setTimeout"],"mappings":"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","sourcesContent":["import GrpcServiceError from \"./grpc/GrpcServiceError.js\";\nimport GrpcStatus from \"./grpc/GrpcStatus.js\";\n\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * @enum {string}\n */\nexport const ExecutionState = {\n    Finished: \"Finished\",\n    Retry: \"Retry\",\n    Error: \"Error\",\n};\n\nexport const RST_STREAM = /\\brst[^0-9a-zA-Z]stream\\b/i;\n\n/**\n * @abstract\n * @internal\n * @template RequestT\n * @template ResponseT\n * @template OutputT\n */\nexport default class Executable {\n    constructor() {\n        /**\n         * The number of times we can retry the grpc call\n         *\n         * @private\n         * @type {number}\n         */\n        this._maxAttempts = 10;\n\n        /**\n         * The index of the next transaction to be executed.\n         *\n         * @protected\n         * @type {number}\n         */\n        this._nextNodeIndex = 0;\n\n        /**\n         * List of node account IDs for each transaction that has been\n         * built.\n         *\n         * @internal\n         * @type {AccountId[]}\n         */\n        this._nodeIds = [];\n\n        /** @type {number | null} */\n        this._minBackoff = null;\n\n        /** @type {number | null} */\n        this._maxBackoff = null;\n    }\n\n    /**\n     * @returns {?AccountId[]}\n     */\n    get nodeAccountIds() {\n        return this._nodeIds.length != 0 ? this._nodeIds : null;\n    }\n\n    /**\n     * @param {AccountId[]} nodeIds\n     * @returns {this}\n     */\n    setNodeAccountIds(nodeIds) {\n        this._nodeIds = nodeIds;\n\n        return this;\n    }\n\n    /**\n     * @deprecated\n     * @returns {number}\n     */\n    get maxRetries() {\n        console.warn(\"Deprecated: use maxAttempts instead\");\n        return this.maxAttempts;\n    }\n\n    /**\n     * @param {number} maxRetries\n     * @returns {this}\n     */\n    setMaxRetries(maxRetries) {\n        console.warn(\"Deprecated: use setMaxAttempts() instead\");\n        return this.setMaxAttempts(maxRetries);\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxAttempts() {\n        return this._maxAttempts;\n    }\n\n    /**\n     * @param {number} maxAttempts\n     * @returns {this}\n     */\n    setMaxAttempts(maxAttempts) {\n        this._maxAttempts = maxAttempts;\n\n        return this;\n    }\n\n    /**\n     * @param {number} minBackoff\n     * @returns {this}\n     */\n    setMinBackoff(minBackoff) {\n        if (minBackoff == null) {\n            throw new Error(\"minBackoff cannot be null.\");\n        } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {\n            throw new Error(\"minBackoff cannot be larger than maxBackoff.\");\n        }\n        this._minBackoff = minBackoff;\n        return this;\n    }\n\n    /**\n     * @returns {number | null}\n     */\n    get minBackoff() {\n        return this._minBackoff;\n    }\n\n    /**\n     * @param {?number} maxBackoff\n     * @returns {this}\n     */\n    setMaxBackoff(maxBackoff) {\n        if (maxBackoff == null) {\n            throw new Error(\"maxBackoff cannot be null.\");\n        } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {\n            throw new Error(\"maxBackoff cannot be smaller than minBackoff.\");\n        }\n        this._maxBackoff = maxBackoff;\n        return this;\n    }\n\n    /**\n     * @returns {number | null}\n     */\n    get maxBackoff() {\n        return this._maxBackoff;\n    }\n\n    // /**\n    //  * @param {?number} minBackoff\n    //  * @param {?number} maxBackoff\n    //  * @returns {this}\n    //  */\n    // _setBackoff(minBackoff, maxBackoff) {\n    //     if (minBackoff == null) {\n    //         throw new Error(\"minBackoff cannot be null.\");\n    //     }\n    //     if (maxBackoff == null) {\n    //         throw new Error(\"maxBackoff cannot be null.\");\n    //     }\n    //     if (minBackoff > maxBackoff) {\n    //         throw new Error(\"minBackoff cannot be larger than maxBackoff.\");\n    //     }\n    //     this._minBackoff = minBackoff;\n    //     this._maxAttempts = maxBackoff;\n    //     return this;\n    // }\n\n    // /**\n    //  * @typedef {Object} Backoff\n    //  * @property {number | null} minBackoff\n    //  * @property {number | null} maxBackoff\n    //  * @returns {Backoff}\n    //  */\n    // get _backoff() {\n    //     return { minBackoff: this._minBackoff, maxBackoff: this._maxBackoff };\n    // }\n\n    /**\n     * @abstract\n     * @protected\n     * @param {import(\"./client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<void>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _beforeExecute(client) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @protected\n     * @returns {Promise<RequestT>}\n     */\n    _makeRequestAsync() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {RequestT} request\n     * @param {ResponseT} response\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @protected\n     * @param {ResponseT} response\n     * @param {AccountId} nodeAccountId\n     * @param {RequestT} request\n     * @returns {Promise<OutputT>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapResponse(response, nodeAccountId, request) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {Channel} channel\n     * @param {RequestT} request\n     * @returns {Promise<ResponseT>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _execute(channel, request) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @protected\n     * @returns {AccountId}\n     */\n    _getNodeAccountId() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @protected\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @protected\n     * @returns {void}\n     */\n    _advanceRequest() {\n        // each time we move our cursor to the next transaction\n        // wrapping around to ensure we are cycling\n        this._nextNodeIndex = (this._nextNodeIndex + 1) % this._nodeIds.length;\n    }\n\n    /**\n     * @abstract\n     * @protected\n     * @param {RequestT} request\n     * @param {ResponseT} response\n     * @returns {ExecutionState}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @protected\n     * @param {GrpcServiceError} error\n     * @returns {boolean}\n     */\n    _shouldRetryExceptionally(error) {\n        return (\n            error.status._code === GrpcStatus.Unavailable._code ||\n            error.status._code === GrpcStatus.ResourceExhausted._code ||\n            (error.status._code === GrpcStatus.Internal._code &&\n                RST_STREAM.test(error.message))\n        );\n    }\n\n    /**\n     * @template {Channel} ChannelT\n     * @template MirrorChannelT\n     * @param {import(\"./client/Client.js\").default<ChannelT, MirrorChannelT>} client\n     * @returns {Promise<OutputT>}\n     */\n    async execute(client) {\n        await this._beforeExecute(client);\n\n        if (this._maxBackoff == null) {\n            this._maxBackoff = client.maxBackoff;\n        }\n        if (this._minBackoff == null) {\n            this._minBackoff = client.minBackoff;\n        }\n\n        const maxAttempts =\n            client._maxAttempts != null\n                ? client._maxAttempts\n                : this._maxAttempts;\n\n        for (let attempt = 1 /* loop forever */; ; attempt += 1) {\n            const nodeAccountId = this._getNodeAccountId();\n            const node = client._network.getNode(nodeAccountId);\n\n            if (node == null) {\n                throw new Error(\n                    `NodeAccountId not recognized: ${nodeAccountId.toString()}`\n                );\n            }\n\n            const channel = node.getChannel();\n            const request = await this._makeRequestAsync();\n\n            // advance the internal index\n            // non-free queries and transactions map to more than 1 actual transaction and this will cause\n            // the next invocation of makeRequest to return the _next_ transaction\n            this._advanceRequest();\n\n            let response;\n\n            if (!node.isHealthy()) {\n                await node.wait();\n            }\n\n            try {\n                response = await this._execute(channel, request);\n            } catch (err) {\n                const error = GrpcServiceError._fromResponse(\n                    /** @type {Error} */ (err)\n                );\n\n                if (\n                    error instanceof GrpcServiceError &&\n                    this._shouldRetryExceptionally(error) &&\n                    attempt <= maxAttempts\n                ) {\n                    node.increaseDelay();\n                    continue;\n                }\n\n                throw err;\n            }\n\n            node.decreaseDelay();\n\n            switch (this._shouldRetry(request, response)) {\n                case ExecutionState.Retry:\n                    await delayForAttempt(\n                        attempt,\n                        this._minBackoff,\n                        this._maxBackoff\n                    );\n                    continue;\n                case ExecutionState.Finished:\n                    return this._mapResponse(response, nodeAccountId, request);\n                case ExecutionState.Error:\n                    throw this._mapStatusError(request, response);\n                default:\n                    throw new Error(\n                        \"(BUG) non-exhuastive switch statement for `ExecutionState`\"\n                    );\n            }\n        }\n    }\n}\n\n/**\n * @param {number} attempt\n * @param {number} minBackoff\n * @param {number} maxBackoff\n * @returns {Promise<void>}\n */\nfunction delayForAttempt(attempt, minBackoff, maxBackoff) {\n    // 0.1s, 0.2s, 0.4s, 0.8s, ...\n    const ms = Math.min(\n        Math.floor(minBackoff * Math.pow(2, attempt)),\n        maxBackoff\n    );\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"]},"metadata":{},"sourceType":"module"}