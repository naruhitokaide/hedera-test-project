{"ast":null,"code":"import Long from \"long\";\nimport * as hex from \"./encoding/hex.js\";\nimport BadEntityIdError from \"./BadEntityIdError.js\";\nimport * as util from \"./util.js\";\nimport PublicKey from \"./PublicKey.js\";\n/**\n * @typedef {import(\"./client/Client.js\").default<*, *>} Client\n */\n\n/**\n * @typedef {object} IEntityId\n * @property {(PublicKey | null)=} aliasKey\n * @property {number | Long} num\n * @property {(number | Long)=} shard\n * @property {(number | Long)=} realm\n */\n\n/**\n * @typedef {object} IEntityIdResult\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n * @property {(PublicKey | null)=} aliasKey\n */\n\n/**\n * @typedef {object} IEntityIdResultWithChecksum\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n * @property {string | null} checksum\n * @property {PublicKey | null} aliasKey\n */\n\nconst regex = RegExp(\"^(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))(?:-([a-z]{5}))?$\");\n/**\n * @param {number | Long | IEntityId} props\n * @param {(number | null | Long)=} realm\n * @param {(number | null | Long | PublicKey)=} numOrAliasKey\n * @returns {IEntityIdResult}\n */\n\nexport function constructor(props, realm, numOrAliasKey) {\n  let shard_ = Long.ZERO;\n  let realm_ = Long.ZERO;\n  let num_ = Long.ZERO;\n  let aliasKey_;\n\n  if (numOrAliasKey instanceof PublicKey) {\n    aliasKey_ = numOrAliasKey;\n  }\n\n  if (typeof props === \"number\" || Long.isLong(props)) {\n    if (realm == null || typeof realm === \"string\") {\n      num_ = Long.fromValue(props);\n    } else {\n      shard_ = Long.fromValue(props);\n      realm_ = Long.fromValue(realm);\n      num_ = numOrAliasKey != null && !(numOrAliasKey instanceof PublicKey) ? Long.fromValue(numOrAliasKey) : Long.ZERO;\n    }\n  } else {\n    shard_ = Long.fromValue(props.shard != null ? props.shard : 0);\n    realm_ = Long.fromValue(props.realm != null ? props.realm : 0);\n    num_ = Long.fromValue(props.num != null ? props.num : 0);\n    aliasKey_ = props.aliasKey;\n  }\n\n  if (shard_.isNegative() || realm_.isNegative() || num_.isNegative()) {\n    throw new Error(\"negative numbers are not allowed in IDs\");\n  }\n\n  return {\n    shard: shard_,\n    realm: realm_,\n    num: num_,\n    aliasKey: aliasKey_\n  };\n}\n/**\n * @param {[Long, Long, Long]} a\n * @param {[Long, Long, Long]} b\n * @returns {number}\n */\n\nexport function compare(a, b) {\n  let comparison = a[0].compare(b[0]);\n\n  if (comparison != 0) {\n    return comparison;\n  }\n\n  comparison = a[1].compare(b[1]);\n\n  if (comparison != 0) {\n    return comparison;\n  }\n\n  return a[2].compare(b[2]);\n}\n/**\n * @typedef {object} ParseAddressResult\n * @property {number} status\n * @property {Long} [num1]\n * @property {Long} [num2]\n * @property {Long} [num3]\n * @property {string} [correctChecksum]\n * @property {string} [givenChecksum]\n * @property {string} [noChecksumFormat]\n * @property {string} [withChecksumFormat]\n */\n\n/**\n * @param {string} text\n * @returns {IEntityIdResultWithChecksum}\n */\n\nexport function fromString(text) {\n  const [id, checksum] = text.split(\"-\");\n  const parts = id.split(\".\");\n\n  for (const part of parts) {\n    if (part === \"\") {\n      throw new Error(\"invalid format for entity ID\");\n    }\n  }\n\n  const components = parts.map(Number);\n\n  for (const component of components) {\n    if (Number.isNaN(component)) {\n      throw new Error(\"invalid format for entity ID\");\n    }\n  }\n\n  let shard = Long.ZERO;\n  let realm = Long.ZERO;\n  let num;\n\n  if (components.length === 1) {\n    num = Long.fromNumber(components[0]);\n  } else if (components.length === 3) {\n    shard = Long.fromNumber(components[0]);\n    realm = Long.fromNumber(components[1]);\n    num = Long.fromNumber(components[2]);\n  } else {\n    throw new Error(\"invalid format for entity ID\");\n  }\n\n  return {\n    shard,\n    realm,\n    num,\n    checksum,\n    aliasKey: null\n  };\n}\n/**\n * @param {string} address\n * @returns {[Long, Long, Long]}\n */\n\nexport function fromSolidityAddress(address) {\n  const addr = address.startsWith(\"0x\") ? hex.decode(address.slice(2)) : hex.decode(address);\n\n  if (addr.length !== 20) {\n    throw new Error(`Invalid hex encoded solidity address length:\n                expected length 40, got length ${address.length}`);\n  }\n\n  const shard = Long.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);\n  const realm = Long.fromBytesBE(Array.from(addr.slice(4, 12)));\n  const num = Long.fromBytesBE(Array.from(addr.slice(12, 20)));\n  return [shard, realm, num];\n}\n/**\n * @param {[Long,Long,Long] | [number,number,number]} address\n * @returns {string}\n */\n\nexport function toSolidityAddress(address) {\n  const buffer = new Uint8Array(20);\n  const view = util.safeView(buffer);\n  const [shard, realm, num] = address;\n  view.setUint32(0, util.convertToNumber(shard));\n  view.setUint32(8, util.convertToNumber(realm));\n  view.setUint32(16, util.convertToNumber(num));\n  return hex.encode(buffer);\n}\n/**\n * Parse the address string addr and return an object with the results (8 fields).\n * The first four fields are numbers, which could be implemented as signed 32 bit\n * integers, and the last four are strings.\n *\n *   status;  //the status of the parsed address\n *            //   0 = syntax error\n *            //   1 = an invalid with-checksum address (bad checksum)\n *            //   2 = a valid no-checksum address\n *            //   3 = a valid with-checksum address\n *   num1;    //the 3 numbers in the address, such as 1.2.3, with leading zeros removed\n *   num2;\n *   num3;\n *   correctchecksum;    //the correct checksum\n *   givenChecksum;      //the checksum in the address that was parsed\n *   noChecksumFormat;   //the address in no-checksum format\n *   withChecksumFormat; //the address in with-checksum format\n *\n * @param {string} ledgerId\n * @param {string} addr\n * @returns {ParseAddressResult}\n */\n\nexport function _parseAddress(ledgerId, addr) {\n  let match = regex.exec(addr);\n\n  if (match === null) {\n    let result = {\n      status: 0\n    }; // When status == 0, the rest of the fields should be ignored\n\n    return result;\n  }\n\n  let a = [Long.fromString(match[1]), Long.fromString(match[2]), Long.fromString(match[3])];\n  let ad = `${a[0].toString()}.${a[1].toString()}.${a[2].toString()}`;\n\n  let c = _checksum(ledgerId, ad);\n\n  let s = match[4] === undefined ? 2 : c == match[4] ? 3 : 1; //the status\n\n  let result = {\n    status: s,\n    num1: a[0],\n    num2: a[1],\n    num3: a[2],\n    givenChecksum: match[4],\n    correctChecksum: c,\n    noChecksumFormat: ad,\n    withChecksumFormat: `${ad}-${c}`\n  };\n  return result;\n}\n/**\n * Given an address like \"0.0.123\", return a checksum like \"laujm\"\n *\n * @param {string} ledgerId\n * @param {string} addr\n * @returns {string}\n */\n\nexport function _checksum(ledgerId, addr) {\n  let answer = \"\";\n  let d = []; // Digits with 10 for \".\", so if addr == \"0.0.123\" then d == [0, 10, 0, 10, 1, 2, 3]\n\n  let s0 = 0; // Sum of even positions (mod 11)\n\n  let s1 = 0; // Sum of odd positions (mod 11)\n\n  let s = 0; // Weighted sum of all positions (mod p3)\n\n  let sh = 0; // Hash of the ledger ID\n\n  let c = 0; // The checksum, as a single number\n\n  const p3 = 26 * 26 * 26; // 3 digits in base 26\n\n  const p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26\n\n  const ascii_a = \"a\".charCodeAt(0); // 97\n\n  const m = 1000003; // Min prime greater than a million. Used for the final permutation.\n\n  const w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.\n\n  let id = ledgerId + \"000000000000\";\n  let h = [];\n\n  for (var i = 0; i < id.length; i += 2) {\n    h.push(parseInt(id.substring(i, i + 2), 16));\n  }\n\n  for (let i = 0; i < addr.length; i++) {\n    d.push(addr[i] === \".\" ? 10 : parseInt(addr[i], 10));\n  }\n\n  for (let i = 0; i < d.length; i++) {\n    s = (w * s + d[i]) % p3;\n\n    if (i % 2 === 0) {\n      s0 = (s0 + d[i]) % 11;\n    } else {\n      s1 = (s1 + d[i]) % 11;\n    }\n  }\n\n  for (let i = 0; i < h.length; i++) {\n    sh = (w * sh + h[i]) % p5;\n  }\n\n  c = (((addr.length % 5 * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;\n  c = c * m % p5;\n\n  for (let i = 0; i < 5; i++) {\n    answer = String.fromCharCode(ascii_a + c % 26) + answer;\n    c /= 26;\n  }\n\n  return answer;\n}\n/**\n * @param {Long} shard\n * @param {Long} realm\n * @param {Long} num\n * @param {string | null} checksum\n * @param {Client} client\n */\n\nexport function validateChecksum(shard, realm, num, checksum, client) {\n  if (client._network._ledgerId == null || checksum == null) {\n    return;\n  }\n\n  const expectedChecksum = _checksum(client._network._ledgerId._toStringForChecksum(), `${shard.toString()}.${realm.toString()}.${num.toString()}`);\n\n  if (checksum != expectedChecksum) {\n    throw new BadEntityIdError(shard, realm, num, checksum, expectedChecksum);\n  }\n}\n/**\n * @param {string} string\n * @param {Client} client\n * @returns {string}\n */\n\nexport function toStringWithChecksum(string, client) {\n  if (client._network._ledgerId == null) {\n    throw new Error(\"cannot calculate checksum with a client that does not contain a recognzied ledger ID\");\n  }\n\n  const checksum = _checksum(client._network._ledgerId._toStringForChecksum(), string);\n\n  return `${string}-${checksum}`;\n}","map":{"version":3,"sources":["C:/Work/coding-sandbox/react-again/dapp-days/node_modules/@hashgraph/sdk/src/EntityIdHelper.js"],"names":["Long","hex","BadEntityIdError","util","PublicKey","regex","RegExp","constructor","props","realm","numOrAliasKey","shard_","ZERO","realm_","num_","aliasKey_","isLong","fromValue","shard","num","aliasKey","isNegative","Error","compare","a","b","comparison","fromString","text","id","checksum","split","parts","part","components","map","Number","component","isNaN","length","fromNumber","fromSolidityAddress","address","addr","startsWith","decode","slice","fromBytesBE","Array","from","toSolidityAddress","buffer","Uint8Array","view","safeView","setUint32","convertToNumber","encode","_parseAddress","ledgerId","match","exec","result","status","ad","toString","c","_checksum","s","undefined","num1","num2","num3","givenChecksum","correctChecksum","noChecksumFormat","withChecksumFormat","answer","d","s0","s1","sh","p3","p5","ascii_a","charCodeAt","m","w","h","i","push","parseInt","substring","String","fromCharCode","validateChecksum","client","_network","_ledgerId","expectedChecksum","_toStringForChecksum","toStringWithChecksum","string"],"mappings":"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","sourcesContent":["import Long from \"long\";\nimport * as hex from \"./encoding/hex.js\";\nimport BadEntityIdError from \"./BadEntityIdError.js\";\nimport * as util from \"./util.js\";\nimport PublicKey from \"./PublicKey.js\";\n\n/**\n * @typedef {import(\"./client/Client.js\").default<*, *>} Client\n */\n\n/**\n * @typedef {object} IEntityId\n * @property {(PublicKey | null)=} aliasKey\n * @property {number | Long} num\n * @property {(number | Long)=} shard\n * @property {(number | Long)=} realm\n */\n\n/**\n * @typedef {object} IEntityIdResult\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n * @property {(PublicKey | null)=} aliasKey\n */\n\n/**\n * @typedef {object} IEntityIdResultWithChecksum\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n * @property {string | null} checksum\n * @property {PublicKey | null} aliasKey\n */\n\nconst regex = RegExp(\n    \"^(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))(?:-([a-z]{5}))?$\"\n);\n\n/**\n * @param {number | Long | IEntityId} props\n * @param {(number | null | Long)=} realm\n * @param {(number | null | Long | PublicKey)=} numOrAliasKey\n * @returns {IEntityIdResult}\n */\nexport function constructor(props, realm, numOrAliasKey) {\n    let shard_ = Long.ZERO;\n    let realm_ = Long.ZERO;\n    let num_ = Long.ZERO;\n    let aliasKey_;\n\n    if (numOrAliasKey instanceof PublicKey) {\n        aliasKey_ = numOrAliasKey;\n    }\n\n    if (typeof props === \"number\" || Long.isLong(props)) {\n        if (realm == null || typeof realm === \"string\") {\n            num_ = Long.fromValue(props);\n        } else {\n            shard_ = Long.fromValue(props);\n            realm_ = Long.fromValue(realm);\n            num_ =\n                numOrAliasKey != null && !(numOrAliasKey instanceof PublicKey)\n                    ? Long.fromValue(numOrAliasKey)\n                    : Long.ZERO;\n        }\n    } else {\n        shard_ = Long.fromValue(props.shard != null ? props.shard : 0);\n        realm_ = Long.fromValue(props.realm != null ? props.realm : 0);\n        num_ = Long.fromValue(props.num != null ? props.num : 0);\n        aliasKey_ = props.aliasKey;\n    }\n\n    if (shard_.isNegative() || realm_.isNegative() || num_.isNegative()) {\n        throw new Error(\"negative numbers are not allowed in IDs\");\n    }\n\n    return {\n        shard: shard_,\n        realm: realm_,\n        num: num_,\n        aliasKey: aliasKey_,\n    };\n}\n\n/**\n * @param {[Long, Long, Long]} a\n * @param {[Long, Long, Long]} b\n * @returns {number}\n */\nexport function compare(a, b) {\n    let comparison = a[0].compare(b[0]);\n    if (comparison != 0) {\n        return comparison;\n    }\n\n    comparison = a[1].compare(b[1]);\n    if (comparison != 0) {\n        return comparison;\n    }\n\n    return a[2].compare(b[2]);\n}\n\n/**\n * @typedef {object} ParseAddressResult\n * @property {number} status\n * @property {Long} [num1]\n * @property {Long} [num2]\n * @property {Long} [num3]\n * @property {string} [correctChecksum]\n * @property {string} [givenChecksum]\n * @property {string} [noChecksumFormat]\n * @property {string} [withChecksumFormat]\n */\n\n/**\n * @param {string} text\n * @returns {IEntityIdResultWithChecksum}\n */\nexport function fromString(text) {\n    const [id, checksum] = text.split(\"-\");\n    const parts = id.split(\".\");\n\n    for (const part of parts) {\n        if (part === \"\") {\n            throw new Error(\"invalid format for entity ID\");\n        }\n    }\n\n    const components = parts.map(Number);\n\n    for (const component of components) {\n        if (Number.isNaN(component)) {\n            throw new Error(\"invalid format for entity ID\");\n        }\n    }\n\n    let shard = Long.ZERO;\n    let realm = Long.ZERO;\n    let num;\n\n    if (components.length === 1) {\n        num = Long.fromNumber(components[0]);\n    } else if (components.length === 3) {\n        shard = Long.fromNumber(components[0]);\n        realm = Long.fromNumber(components[1]);\n        num = Long.fromNumber(components[2]);\n    } else {\n        throw new Error(\"invalid format for entity ID\");\n    }\n\n    return {\n        shard,\n        realm,\n        num,\n        checksum,\n        aliasKey: null,\n    };\n}\n\n/**\n * @param {string} address\n * @returns {[Long, Long, Long]}\n */\nexport function fromSolidityAddress(address) {\n    const addr = address.startsWith(\"0x\")\n        ? hex.decode(address.slice(2))\n        : hex.decode(address);\n\n    if (addr.length !== 20) {\n        throw new Error(`Invalid hex encoded solidity address length:\n                expected length 40, got length ${address.length}`);\n    }\n\n    const shard = Long.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);\n    const realm = Long.fromBytesBE(Array.from(addr.slice(4, 12)));\n    const num = Long.fromBytesBE(Array.from(addr.slice(12, 20)));\n\n    return [shard, realm, num];\n}\n\n/**\n * @param {[Long,Long,Long] | [number,number,number]} address\n * @returns {string}\n */\nexport function toSolidityAddress(address) {\n    const buffer = new Uint8Array(20);\n    const view = util.safeView(buffer);\n    const [shard, realm, num] = address;\n\n    view.setUint32(0, util.convertToNumber(shard));\n    view.setUint32(8, util.convertToNumber(realm));\n    view.setUint32(16, util.convertToNumber(num));\n\n    return hex.encode(buffer);\n}\n\n/**\n * Parse the address string addr and return an object with the results (8 fields).\n * The first four fields are numbers, which could be implemented as signed 32 bit\n * integers, and the last four are strings.\n *\n *   status;  //the status of the parsed address\n *            //   0 = syntax error\n *            //   1 = an invalid with-checksum address (bad checksum)\n *            //   2 = a valid no-checksum address\n *            //   3 = a valid with-checksum address\n *   num1;    //the 3 numbers in the address, such as 1.2.3, with leading zeros removed\n *   num2;\n *   num3;\n *   correctchecksum;    //the correct checksum\n *   givenChecksum;      //the checksum in the address that was parsed\n *   noChecksumFormat;   //the address in no-checksum format\n *   withChecksumFormat; //the address in with-checksum format\n *\n * @param {string} ledgerId\n * @param {string} addr\n * @returns {ParseAddressResult}\n */\nexport function _parseAddress(ledgerId, addr) {\n    let match = regex.exec(addr);\n    if (match === null) {\n        let result = { status: 0 }; // When status == 0, the rest of the fields should be ignored\n        return result;\n    }\n    let a = [\n        Long.fromString(match[1]),\n        Long.fromString(match[2]),\n        Long.fromString(match[3]),\n    ];\n    let ad = `${a[0].toString()}.${a[1].toString()}.${a[2].toString()}`;\n    let c = _checksum(ledgerId, ad);\n    let s = match[4] === undefined ? 2 : c == match[4] ? 3 : 1; //the status\n    let result = {\n        status: s,\n        num1: a[0],\n        num2: a[1],\n        num3: a[2],\n        givenChecksum: match[4],\n        correctChecksum: c,\n        noChecksumFormat: ad,\n        withChecksumFormat: `${ad}-${c}`,\n    };\n    return result;\n}\n\n/**\n * Given an address like \"0.0.123\", return a checksum like \"laujm\"\n *\n * @param {string} ledgerId\n * @param {string} addr\n * @returns {string}\n */\nexport function _checksum(ledgerId, addr) {\n    let answer = \"\";\n    let d = []; // Digits with 10 for \".\", so if addr == \"0.0.123\" then d == [0, 10, 0, 10, 1, 2, 3]\n    let s0 = 0; // Sum of even positions (mod 11)\n    let s1 = 0; // Sum of odd positions (mod 11)\n    let s = 0; // Weighted sum of all positions (mod p3)\n    let sh = 0; // Hash of the ledger ID\n    let c = 0; // The checksum, as a single number\n    const p3 = 26 * 26 * 26; // 3 digits in base 26\n    const p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26\n    const ascii_a = \"a\".charCodeAt(0); // 97\n    const m = 1000003; // Min prime greater than a million. Used for the final permutation.\n    const w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.\n\n    let id = ledgerId + \"000000000000\";\n    let h = [];\n    for (var i = 0; i < id.length; i += 2) {\n        h.push(parseInt(id.substring(i, i + 2), 16));\n    }\n    for (let i = 0; i < addr.length; i++) {\n        d.push(addr[i] === \".\" ? 10 : parseInt(addr[i], 10));\n    }\n    for (let i = 0; i < d.length; i++) {\n        s = (w * s + d[i]) % p3;\n        if (i % 2 === 0) {\n            s0 = (s0 + d[i]) % 11;\n        } else {\n            s1 = (s1 + d[i]) % 11;\n        }\n    }\n    for (let i = 0; i < h.length; i++) {\n        sh = (w * sh + h[i]) % p5;\n    }\n    c = ((((addr.length % 5) * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;\n    c = (c * m) % p5;\n\n    for (let i = 0; i < 5; i++) {\n        answer = String.fromCharCode(ascii_a + (c % 26)) + answer;\n        c /= 26;\n    }\n\n    return answer;\n}\n\n/**\n * @param {Long} shard\n * @param {Long} realm\n * @param {Long} num\n * @param {string | null} checksum\n * @param {Client} client\n */\nexport function validateChecksum(shard, realm, num, checksum, client) {\n    if (client._network._ledgerId == null || checksum == null) {\n        return;\n    }\n\n    const expectedChecksum = _checksum(\n        client._network._ledgerId._toStringForChecksum(),\n        `${shard.toString()}.${realm.toString()}.${num.toString()}`\n    );\n\n    if (checksum != expectedChecksum) {\n        throw new BadEntityIdError(\n            shard,\n            realm,\n            num,\n            checksum,\n            expectedChecksum\n        );\n    }\n}\n\n/**\n * @param {string} string\n * @param {Client} client\n * @returns {string}\n */\nexport function toStringWithChecksum(string, client) {\n    if (client._network._ledgerId == null) {\n        throw new Error(\n            \"cannot calculate checksum with a client that does not contain a recognzied ledger ID\"\n        );\n    }\n\n    const checksum = _checksum(\n        client._network._ledgerId._toStringForChecksum(),\n        string\n    );\n\n    return `${string}-${checksum}`;\n}\n"]},"metadata":{},"sourceType":"module"}