{"version":3,"file":"ExpoCrypto.web.js","sourceRoot":"","sources":["../src/ExpoCrypto.web.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,kBAAkB,CAAC;AAE9C,OAAO,EAAyB,cAAc,EAAuB,MAAM,gBAAgB,CAAC;AAE5F,eAAe;IACb,IAAI,IAAI;QACN,OAAO,YAAY,CAAC;IACtB,CAAC;IACD,KAAK,CAAC,iBAAiB,CACrB,SAAgC,EAChC,IAAY,EACZ,OAA4B;QAE5B,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YAClB,MAAM,IAAI,UAAU,CAClB,wBAAwB,EACxB,sEAAsE,CACvE,CAAC;SACH;QACD,MAAM,OAAO,GAAG,IAAI,WAAW,EAAE,CAAC;QAClC,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACpC,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;QACjE,IAAI,OAAO,CAAC,QAAQ,KAAK,cAAc,CAAC,GAAG,EAAE;YAC3C,OAAO,SAAS,CAAC,UAAU,CAAC,CAAC;SAC9B;aAAM,IAAI,OAAO,CAAC,QAAQ,KAAK,cAAc,CAAC,MAAM,EAAE;YACrD,OAAO,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;SACjE;QACD,MAAM,IAAI,UAAU,CAAC,mBAAmB,EAAE,iCAAiC,CAAC,CAAC;IAC/E,CAAC;CACF,CAAC;AAEF,SAAS,SAAS,CAAC,MAAmB;IACpC,MAAM,SAAS,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;IAEzC,MAAM,QAAQ,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QAC1C,MAAM,OAAO,GAAG,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QACnC,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;QAC/C,OAAO,aAAa,CAAC;IACvB,CAAC,CAAC,CAAC;IAEH,OAAO,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AAC3B,CAAC","sourcesContent":["import { CodedError } from '@unimodules/core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions } from './Crypto.types';\n\nexport default {\n  get name(): string {\n    return 'ExpoCrypto';\n  },\n  async digestStringAsync(\n    algorithm: CryptoDigestAlgorithm,\n    data: string,\n    options: CryptoDigestOptions\n  ): Promise<string> {\n    if (!crypto.subtle) {\n      throw new CodedError(\n        'ERR_CRYPTO_UNAVAILABLE',\n        'Access to the WebCrypto API is restricted to secure origins (https).'\n      );\n    }\n    const encoder = new TextEncoder();\n    const buffer = encoder.encode(data);\n    const hashedData = await crypto.subtle.digest(algorithm, buffer);\n    if (options.encoding === CryptoEncoding.HEX) {\n      return hexString(hashedData);\n    } else if (options.encoding === CryptoEncoding.BASE64) {\n      return btoa(String.fromCharCode(...new Uint8Array(hashedData)));\n    }\n    throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n  },\n};\n\nfunction hexString(buffer: ArrayBuffer): string {\n  const byteArray = new Uint8Array(buffer);\n\n  const hexCodes = [...byteArray].map(value => {\n    const hexCode = value.toString(16);\n    const paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n\n  return hexCodes.join('');\n}\n"]}