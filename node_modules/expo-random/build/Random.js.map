{"version":3,"file":"Random.js","sourceRoot":"","sources":["../src/Random.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,mBAAmB,EAAE,MAAM,kBAAkB,CAAC;AACvD,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAExC,OAAO,UAAU,MAAM,cAAc,CAAC;AAEtC,SAAS,eAAe,CAAC,KAAU,EAAE,UAAkB;IACrD,IACE,OAAO,KAAK,KAAK,QAAQ;QACzB,KAAK,CAAC,KAAK,CAAC;QACZ,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC;QACrB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,IAAI,EACxB;QACA,MAAM,IAAI,SAAS,CACjB,gBAAgB,UAAU,IAAI,KAAK,+CAA+C,CACnF,CAAC;KACH;AACH,CAAC;AAED,cAAc;AACd;;;;;GAKG;AACH,MAAM,UAAU,cAAc,CAAC,SAAiB;IAC9C,eAAe,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;IAC7C,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IAC7C,IAAI,UAAU,CAAC,cAAc,EAAE;QAC7B,OAAO,UAAU,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;KAClD;SAAM,IAAI,UAAU,CAAC,qBAAqB,EAAE;QAC3C,MAAM,MAAM,GAAG,UAAU,CAAC,qBAAqB,CAAC,cAAc,CAAC,CAAC;QAChE,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC;KAC5B;SAAM;QACL,MAAM,IAAI,mBAAmB,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC;KAChE;AACH,CAAC;AAED,cAAc;AACd;;;;;GAKG;AACH,MAAM,CAAC,KAAK,UAAU,mBAAmB,CAAC,SAAiB;IACzD,eAAe,CAAC,SAAS,EAAE,qBAAqB,CAAC,CAAC;IAClD,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IAC7C,IAAI,UAAU,CAAC,mBAAmB,EAAE;QAClC,OAAO,MAAM,UAAU,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC;KAC7D;SAAM,IAAI,UAAU,CAAC,0BAA0B,EAAE;QAChD,MAAM,MAAM,GAAG,MAAM,UAAU,CAAC,0BAA0B,CAAC,cAAc,CAAC,CAAC;QAC3E,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC;KAC5B;SAAM;QACL,MAAM,IAAI,mBAAmB,CAAC,aAAa,EAAE,qBAAqB,CAAC,CAAC;KACrE;AACH,CAAC","sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\nimport { toByteArray } from 'base64-js';\n\nimport ExpoRandom from './ExpoRandom';\n\nfunction assertByteCount(value: any, methodName: string): void {\n  if (\n    typeof value !== 'number' ||\n    isNaN(value) ||\n    Math.floor(value) < 0 ||\n    Math.floor(value) > 1024\n  ) {\n    throw new TypeError(\n      `expo-random: ${methodName}(${value}) expected a valid number from range 0...1024`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return An array of random bytes with the same length as the `byteCount`.\n */\nexport function getRandomBytes(byteCount: number): Uint8Array {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytes) {\n    return ExpoRandom.getRandomBytes(validByteCount);\n  } else if (ExpoRandom.getRandomBase64String) {\n    const base64 = ExpoRandom.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return A promise that fulfills with an array of random bytes with the same length as the `byteCount`.\n */\nexport async function getRandomBytesAsync(byteCount: number): Promise<Uint8Array> {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytesAsync) {\n    return await ExpoRandom.getRandomBytesAsync(validByteCount);\n  } else if (ExpoRandom.getRandomBase64StringAsync) {\n    const base64 = await ExpoRandom.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytesAsync');\n  }\n}\n"]}